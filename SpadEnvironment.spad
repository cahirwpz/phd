)abbrev domain SPENV SpadEnvironment
SpadEnvironment() : Exports == Implementation where
  N ==> SpadNode
  APP ==> SpadApply(N)
  TD ==> SpadTypeDecl(N)
  TG ==> SpadTypeGuard(N)
  TI ==> SpadTypeInfo(N)
  TO ==> SpadTypeOrigin(N)
  TV ==> SpadTypeVar(N)
  PF ==> PrintableForm
  KEY ==> Union(Symbol, APP)
  MEMBER ==> Record(key : KEY, entry : List(N))
  SCOPE ==> HashTable(KEY, List(N), "UEQUAL")

  Exports ==> CoercibleTo(PrintableForm) with
    new : () -> %

    coerce : KEY -> PF
    coerce : SCOPE -> PF

    addDomain : (APP, %) -> %
    addDomainAs : (APP, KEY, %) -> %

    key? : (KEY, %) -> Boolean

    ++ returns empty list if nothing was found
    search : (KEY, %) -> List(N)
    ++ crashes if nothing was found
    elt : (%, KEY) -> List(N)
    setelt! : (%, KEY, N) -> %

    reset! : (%, KEY) -> %

    createScope : % -> %
    discardScope : % -> %

    mergeEnv: (%, %, %) -> %

  Implementation ==> add
    Rep := List SCOPE

    import SpadNodeFactory
    import SpadTypeEvaluator
    import TypeUnifier
    import Logger('Env)
    import Printer

    -- create empty environment
    new() == [empty()$SCOPE]

    coerce (key : KEY) : PF ==
      key case APP => key :: APP :: PF
      key :: Symbol :: PF

    importDomain (ti : TI, dom : N, env : %) : % ==
      for n in ti.body.list repeat
        n' := substitute(n, typeVar() :: TV, dom)
        guard := emptyNode()
        if typeGuard? n' then
          tg := n' :: TG
          n' := tg.expr
          guard := tg.type
        if typeOrigin? n' then
          to := n' :: TO
          n' := to.expr
        td := n' :: TD
        n' := nodeTypeOrigin(td.type, dom)
        if not emptyNode? guard then
          n' := nodeTypeGuard(n', guard)
        env(td.expr :: Symbol) := n'
      env

    addDomain (dom : APP, env : %) : % ==
      key? (dom, env) => env
      notice ["Adding type" :: PF, bold (dom :: PF), "to the environment!" :: PF]
      ti := getTypeInfo(dom)
      env(dom) := [ti]
      importDomain(ti, [dom], env)

    addDomainAs (dom : APP, key : KEY, env : %) : % ==
      key? (dom, env) => env
      notice(["Adding" :: PF, bold (dom :: PF), "as" :: PF, bold (key :: PF), 
              "to the environment!" :: PF])
      ti := getTypeInfo(dom)
      env(key) := [ti]
      n : N :=
        key case APP => [key :: APP]
        [key :: Symbol]
      importDomain(ti, n, env)

    key? (key : KEY, env : %) : Boolean ==
      for level in env repeat
        if key? (key, level) then
          return true
      false

    search (key : KEY, env : %) : List(N) ==
      empty? env => []
      top := first env
      -- 1) if the symbol is found at first level the return it
      result := search(key, top)
      result case List(N) => result
      -- 2) if it is found deeper then (deep-)copy it to top level and return it
      value : List(N) := []
      for level in rest env repeat
        result := search(key, level)
        result case List(N) =>
          value := copy(result :: List(N))
          top(key) := value
          break
      value

    setelt! (env : %, key : KEY, value : N) : % ==
      values := search(key, env)
      top := first env
      member?(value, values) => env
      top(key) := [value, :values]
      env

    reset! (env : %, key : KEY) : % ==
      top := first env
      top(key) := []
      env

    elt (env : %, key : KEY) : List(N) ==
      result := search(key, env)
      empty? result =>
        fail [string bold(key :: PF), "missing from environment!" :: PF]
        error ""
      result

    flatten (env : %) : % ==
      empty? env => new()
      newenv : SCOPE := empty()
      for level in env repeat
        for e in members(level)@List(MEMBER) repeat
          if not key?(e.key, newenv) then
            newenv(e.key) := e.entry
      [newenv]

    createScope env ==
      cons(empty(), env)

    discardScope env ==
      rest env

    mergeEnv (env : %, left : %, right : %) : % ==
      top := [k :: Symbol for k in keys first env | k case Symbol]
      lks := [k :: Symbol for k in keys first left | k case Symbol]
      rks := [k :: Symbol for k in keys first right | k case Symbol]
      for k in setIntersection(lks, rks) repeat
        if not member?(k, top) then
          for n in concat(left k, right k) repeat
            env(k) := n
      env

    coerce (env : %) : PF ==
      empty? env => "()" :: PF
      (first flatten env) :: PF

    coerce (scope : SCOPE) : PF ==
      entries : List(PF) := []
      empty? scope => "()" :: PF
      for e in members(scope)@List(MEMBER) repeat
        sym := hconcat [bold cyan(e.key :: PF), ":" :: PF]
        mms := [mm :: PF for mm in e.entry]
        of :=
          empty? mms =>
            of := spaces [sym, "[]" :: PF]
          pile [sym, :mms]
        entries := [of, :entries]
      vconcat reverse entries

)abbrev domain SPENVT SpadEnvironmentTest
SpadEnvironmentTest() : Exports == Implementation where
  N ==> SpadNode
  APP ==> SpadApply(N)
  PF ==> PrintableForm

  Exports ==> with
    test1 : () -> Void
    test2 : () -> Void
    test3 : () -> Void

  Implementation ==> add
    import SpadEnvironment
    import SExpression
    import SpadNode
    import SpadNodeFactory
    import Printer
    import MainLogger

    test1 () ==
      loggerDefaultLevel "info"
      resetTime()

      env := new()
      dom1 := [['Integer], []] $ APP
      dom2 := [['List], [['Integer]]] $ APP
      env := addDomain(dom1, env)
      env := addDomain(dom2, env)
      println (env :: PF)

    test2 () ==
      loggerDefaultLevel "info"
      resetTime()

      env := new()
      dom0 := [['Polynomial], [emptyNode()]] $ APP
      dom1 := [['Polynomial], [nodeApp(['Integer], [])]] $ APP
      dom2 := [['Integer], []] $ APP
      env := addDomain(dom0, env)
      env := addDomain(dom1, env)
      env := addDomain(dom2, env)
      modemaps := env('*)
      println pile([hconcat [bold cyan ("*" :: PF), ":" :: PF],
                    :[(modemap :: PF) for modemap in modemaps]])
