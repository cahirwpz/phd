)abbrev domain SPMM SpadModemap
SpadModemap() : Exports == Implementation where
  N ==> SpadNode
  PF ==> PrintableForm
  MT ==> SpadMappingType(N)
  SEX ==> SExpression

  Exports ==> CoercibleTo(PrintableForm) with
    modemap : N -> %
    modemap : (N, N) -> %
    modemap : (N, N, N) -> %

    elt : (%, "origin") -> N
    elt : (%, "type") -> N
    elt : (%, "guard") -> N

    qualifiedType : % -> N

  Implementation ==> add
    import SpadNode
    import SExpression

    Rep := Record(mm_type : N, mm_origin : N, mm_guard : N)

    modemap(type) == [type, emptyNode(), emptyNode()]$Rep
    modemap(type, origin) == [type, origin, emptyNode()]$Rep
    modemap(type, origin, guard) == [type, origin, guard]$Rep

    elt(x, "type") == x.mm_type
    elt(x, "origin") == x.mm_origin
    elt(x, "guard") == x.mm_guard
      
    coerce x ==
      type := pile [x.type :: PF, spaces [bold magenta("from" :: PF), x.origin :: PF]]
      emptyNode? x.guard => type
      pile [type, spaces [bold magenta("when" :: PF), x.guard :: PF]]

    qualifiedType x ==
      mt := x.type :: MT
      if #mt.args = 1 and mt.args.1 = ['constant] then
        nodeTypeExpr('_$, mt.result, x.origin)
      else
        nodeTypeExpr('_$, [mt], x.origin)

)abbrev domain SPENV SpadEnvironment
SpadEnvironment() : Exports == Implementation where
  N ==> SpadNode
  APP ==> SpadApply(N)
  PF ==> PrintableForm
  SMM ==> SpadModemap
  TE ==> SpadTypeExpr(N)
  NT ==> SpadNamedType(N)

  Exports ==> CoercibleTo(PrintableForm) with
    new : () -> %

    addDomain : (%, APP) -> %
    addModemapsFromCategory : (%, N, APP) -> %

    addMode : (%, Symbol, N) -> %
    getMode : (%, Symbol) -> N

    getModemap : (%, Symbol) -> List(SMM)
    addModemap : (%, Symbol, SMM) -> %

    createScope : % -> %
    discardScope : % -> %

    flatten : % -> %
    definedSymbols : % -> List(Symbol)

  Implementation ==> add
    Rep := List AssociationList(Symbol, List(SMM))

    import SExpression
    import SpadNode
    import Logger('Env)
    import TypeInfo
    import Printer
    import SpadModemap

    -- create empty environment
    new() ==
      [[[]]$AssociationList(Symbol, List(SMM))]

    addDomain(env, dom) ==
      debug ["EnvAddDomain" :: PF, paren [dom :: PF]]
      ti := getTypeInfo(dom)
      for n in ti.body.list repeat
        guard := emptyNode()
        if typeGuard? n then
          te := n :: TE
          n := te.expr
          guard := te.type
        nt := n :: NT
        addModemap(env, nt.name, modemap(nt.type, [dom], guard))
      env

    addModemapsFromCategory(env, name, cat) ==
      debug ["EnvAddCategory" :: PF, paren [name :: PF, cat :: PF]]
      ti := getTypeInfo(cat)
      for n in ti.body.list repeat
        guard := emptyNode()
        if typeGuard? n then
          te := n :: TE
          n := te.expr
          guard := te.type
        nt := n :: NT
        addModemap(env, nt.name, modemap(nt.type, name, guard))
      env

    createScope env ==
      cons([[]], env)

    discardScope env ==
      rest env

    addMode(env, name, type) ==
      addModemap(env, name, modemap type)

    getMode(env, name) ==
      for mm in getModemap(env, name) repeat
        if emptyNode? mm.origin then
          return mm.type
      emptyNode()

    getModemap(env, name) ==
      top := first env
      -- 1) if the symbol is found at first level the return it
      maybeEntries := assoc(name, top)
      not maybeEntries case "failed" =>
        maybeEntries.entry
      -- 2) if it is found deeper then (deep-)copy it to top level and return it
      res : List(SMM) := []
      for level in rest env repeat
        maybeEntries := assoc(name, level)
        if not maybeEntries case "failed" then
          res := copy(maybeEntries.entry)
          break
      top(name) := res

    addModemap(env, name, value) ==
      lst := getModemap(env, name)
      top := first env
      top(name) := [value, :lst]
      env

    flatten env ==
      empty? env => new()
      newenv := [[]]$AssociationList(Symbol, List(SMM))
      for level in env repeat
        for e in entries level repeat
          if not key?(e.key, newenv) then
            newenv(e.key) := e.entry
      [newenv]

    definedSymbols(env) ==
      keys first flatten env

    coerce env ==
      entries : List(PF) := []
      empty? env => "()" :: PF
      for e in entries first flatten env repeat
        mms := [mm :: PF for mm in e.entry]
        of := pile [hconcat [bold cyan(e.key :: PF), ":" :: PF], :mms]
        entries := [of, :entries]
      vconcat reverse entries

)abbrev domain SPENVT SpadEnvironmentTest
SpadEnvironmentTest() : Exports == Implementation where
  N ==> SpadNode
  APP ==> SpadApply(N)
  PF ==> PrintableForm

  Exports ==> with
    test1 : () -> Void
    test2 : () -> Void
    test3 : () -> Void

  Implementation ==> add
    import SpadEnvironment
    import SExpression
    import SpadNode
    import SpadNodeFactory
    import Printer

    test1 () ==
      env := new()
      dom1 := [['List], [['Integer]]] $ APP
      dom2 := [['Integer], []] $ APP
      env := addDomain(env, dom1)
      env := addDomain(env, dom2)
      println (env :: PF)

    test2 () ==
      env := new()
      dom0 := [['Polynomial], [emptyNode()]] $ APP
      dom1 := [['Polynomial], [['Integer]]] $ APP
      dom2 := [['Integer], []] $ APP
      env := addDomain(env, dom0)
      env := addDomain(env, dom1)
      env := addDomain(env, dom2)
      modemaps := getModemap(env, '*)
      println pile([hconcat [bold cyan ("*" :: PF), ":" :: PF],
                    :[(modemap :: PF) for modemap in modemaps]])

    test3 () ==
      env := new()
      cat := [['SetCategory], []] $ APP
      env := addModemapsFromCategory(env, ['A], cat)
      println (env :: PF)
