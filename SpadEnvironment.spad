)abbrev domain SPENV SpadEnvironment
SpadEnvironment() : Exports == Implementation where
)include SpadTypeDefs.inc

  MEMBER ==> Record(key : EKEY, entry : EVAL)
  SCOPE ==> HashTable(EKEY, EVAL, "UEQUAL")

  Exports ==> Join(CoercibleTo(PF), KeyedDictionary(EKEY, EVAL)) with
    new : () -> %

    typesOf : (EKEY, %) -> List(N)
    factsAbout : (EKEY, %) -> List(N)

    addTypeOf : (EKEY, N, %) -> Void
    addFactAbout : (EKEY, N, %) -> Void
    addDomain : (APP, %) -> Void
    addDomainAs : (APP, EKEY, %) -> Void

    elt : (%, EKEY) -> EVAL
    setelt! : (%, EKEY, EVAL) -> %

    reset! : (%, EKEY) -> %

    createScope : % -> %
    discardScope : % -> %

    mergeEnv: (%, %, %) -> %

    coerce : EKEY -> PF
    coerce : EVAL -> PF
    coerce : SCOPE -> PF

  Implementation ==> add
    Rep := List SCOPE

    import Printer
    import Logger('Env)
    import SpadNodeFactory
    import SpadNodeTools
    import SpadTypeEvaluator

    -- create empty environment
    new() == [empty()$SCOPE]

    typesOf (key : EKEY, env : %) : List(N) ==
      val := search(key, env)
      (val case EVAL => val.types; [])

    factsAbout (key : EKEY, env : %) : List(N) ==
      val := search(key, env)
      (val case EVAL => val.facts; [])

    addTypeOf (key : EKEY, type : N, env : %) : Void ==
      val := search(key, env)
      val case "failed" =>
        env(key) := [[type], null, []]
      val case EVAL =>
        member?(type, val.types) => env
        val.types := [type, :val.types]

    addFactAbout (key : EKEY, fact : N, env : %) : Void ==
      val := search(key, env)
      val case "failed" =>
        env(key) := [[], null, [fact]]
      val case EVAL =>
        member?(fact, val.facts) => env
        val.facts := [fact, :val.facts]

    importDomain (ti : TI, dom : N, env : %) : Void ==
      for n in ti.body.list repeat
        n' := substitute(n, typeVar() :: TV, dom)
        guard := null
        if typeGuard? n' then
          tg := n' :: TG
          n' := tg.expr
          guard := tg.type
        if typeOrigin? n' then
          to := n' :: TO
          n' := to.expr
        td := n' :: TD
        n' := nodeTypeOrigin(td.type, dom)
        if not null? guard then
          n' := nodeTypeGuard(n', guard)
        addTypeOf(td.expr :: Symbol, n', env)

    addDomain (dom : APP, env : %) : Void ==
      key? (dom, env) => env
      notice ["Adding type" :: PF, bold (dom :: PF), "to the environment!" :: PF]
      ti := getTypeInfo(dom)
      addTypeOf(dom, [ti], env)
      importDomain(ti, [dom], env)

    addDomainAs (dom : APP, key : EKEY, env : %) : Void ==
      key? (dom, env) => env
      notice(["Adding" :: PF, bold (dom :: PF), "as" :: PF, bold (key :: PF), 
              "to the environment!" :: PF])
      ti := getTypeInfo(dom)
      addTypeOf(dom, [ti], env)
      n : N :=
        key case APP => [key :: APP]
        [key :: Symbol]
      importDomain(ti, n, env)

    empty? (env : %) : Boolean ==
      empty?(env)$Rep

    search (key : EKEY, env : %) : Union(EVAL, "failed") ==
      empty? env => "failed"
      top := first env
      -- 1) if the symbol is found at first level the return it
      result := search(key, top)
      result case EVAL => result
      -- 2) if it is found deeper then (deep-)copy it to top level and return it
      for level in rest env repeat
        result := search(key, level)
        result case EVAL =>
          value := result :: EVAL
          types' := [copy n for n in value.types]
          info'  := copy value.info
          facts' := [copy n for n in value.facts]
          value' := [types', info', facts']
          top(key) := value'
          return value'
      -- 3) not found :(
      "failed"

    elt (env : %, key : EKEY) : EVAL ==
      val := search(key, env)
      val case EVAL => val
      fail [string bold(key :: PF), "not found in the environment!" :: PF]
      error ""

    setelt! (env : %, key : EKEY, val : EVAL) : % ==
      top := first env
      top(key) := val
      env

    reset! (env : %, key : EKEY) : % ==
      env(key) := [[], null, []]

    flatten (env : %) : % ==
      empty? env => new()
      newenv : SCOPE := empty()
      for level in env repeat
        for e in members(level)@List(MEMBER) repeat
          if not key?(e.key, newenv) then
            newenv(e.key) := e.entry
      [newenv]

    createScope env ==
      cons(empty(), env)

    discardScope env ==
      rest env

    mergeEnv (env : %, left : %, right : %) : % ==
      top := [k :: Symbol for k in keys first env | k case Symbol]
      lks := [k :: Symbol for k in keys first left | k case Symbol]
      rks := [k :: Symbol for k in keys first right | k case Symbol]
      for k in setIntersection(lks, rks) repeat
        if not member?(k, top) then
          lv := left(k) :: EVAL
          rv := right(k) :: EVAL
          ts := removeDuplicates concat(lv.types, rv.types)
          fs := removeDuplicates concat(lv.facts, rv.facts)
          env(k) := [ts, null, fs]
      env

    coerce (key : EKEY) : PF ==
      key case APP => key :: APP :: PF
      key :: Symbol :: PF

    coerce (val : EVAL) : PF ==
      ts := [t :: PF for t in val.types]
      fs := [f :: PF for f in val.facts]
      empty? fs =>
        pile [cyan("types:" :: PF), :ts]
      vconcat [pile [cyan("types:" :: PF), :ts],
               pile [cyan("facts:" :: PF), :fs]]
      
    coerce (scope : SCOPE) : PF ==
      entries : List(PF) := []
      empty? scope => "()" :: PF
      for e in members(scope)@List(MEMBER) repeat
        sym := hconcat [bold cyan(e.key :: PF), ":" :: PF]
        entries := [pile [sym, e.entry :: PF], :entries]
      vconcat reverse entries

    coerce (env : %) : PF ==
      empty? env => "()" :: PF
      (first flatten env) :: PF

)abbrev domain SPENVT SpadEnvironmentTest
SpadEnvironmentTest() : Exports == Implementation where
)include SpadTypeDefs.inc

  Exports ==> with
    test1 : () -> Void
    test2 : () -> Void
    test3 : () -> Void

  Implementation ==> add
    import SpadEnvironment
    import SExpression
    import SpadNode
    import SpadNodeFactory
    import Printer
    import MainLogger

    test1 () ==
      loggerDefaultLevel "info"
      resetTime()

      env := new()
      dom1 := [['Integer], []] $ APP
      dom2 := [['List], [['Integer]]] $ APP
      addDomain(dom1, env)
      addDomain(dom2, env)
      println (env :: PF)

    test2 () ==
      loggerDefaultLevel "info"
      resetTime()

      env := new()
      dom0 := [['Polynomial], [null]] $ APP
      dom1 := [['Polynomial], [nodeApp(['Integer], [])]] $ APP
      dom2 := [['Integer], []] $ APP
      addDomain(dom0, env)
      addDomain(dom1, env)
      addDomain(dom2, env)
      modemaps := typesOf('*, env)
      println pile([hconcat [bold cyan ("*" :: PF), ":" :: PF],
                    :[(modemap :: PF) for modemap in modemaps]])
