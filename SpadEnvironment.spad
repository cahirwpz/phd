)abbrev domain SPMM SpadModemap
SpadModemap() : Exports == Implementation where
  N ==> SpadNode
  PF ==> PrintableForm
  MT ==> SpadMappingType(N)
  SEX ==> SExpression

  Exports ==> CoercibleTo(PrintableForm) with
    elt : (%, "origin") -> N
    elt : (%, "type") -> MT
    elt : (%, "constraint") -> N
    elt : (%, "template") -> Record(type : MT, arg : N)

  Implementation ==> add
    Rep := List(List(SEX))

    import SpadNode
    import SExpression

    elt(x, "origin") ==
      parse x.1.1

    elt(x, "type") ==
      tl := [parse t for t in rest x.1]
      [rest tl, first tl]

    elt(x, "constraint") ==
      ex := x.2.1
      (symbol? ex) and (symbol ex = 'T) => emptyNode()
      parse ex
      
    elt(x, "template") ==
      tmplpart := destruct x.2.2
      tl := [parse t for t in destruct tmplpart.3]
      tmpl := [rest tl, first tl]
      targ := parse tmplpart.2
      [tmpl, targ]

    coerce x ==
      lst := [spaces [x.origin :: PF, "implements :" :: PF],
              indent(4, x.type :: PF)]
      cond := x.constraint
      if not emptyNode? cond then
        concat!(lst,
                [indent(2, "when :" :: PF), indent(4, x.constraint :: PF)])
      concat!(lst,
              ["Original signature:" :: PF,
               indent(4, x.template.type :: PF),
               indent(2, hconcat ["with % = " :: PF, x.template.arg :: PF])])
      pile lst

)abbrev domain SPENV SpadEnvironment
SpadEnvironment() : Exports == Implementation where
  N ==> SpadNode
  APP ==> SpadApply(N)
  PF ==> PrintableForm
  SEX ==> SExpression
  PROP ==> Record(kind : Symbol, value : SEX)

  Exports ==> CoercibleTo(PrintableForm) with
    new : () -> %

    addDomain : (APP, %) -> %
    addModemapsFromCategory : (N, N, %) -> %

    addModemap : (Symbol, APP, List(N), %) -> %
    getModemap : (Symbol, %) -> List(SpadModemap)

    addMode : (Symbol, N, %) -> %
    getMode : (Symbol, %) -> N

    putValue : (Symbol, N, %) -> %
    getValue : (Symbol, %) -> N

    definedSymbols : % -> List(Symbol)

    test : () -> Void

  Implementation ==> add
    Rep := Stack List Record(name : Symbol, properties : List PROP)

    import SExpression
    import Printer
    import PrinterCode
    import SpadNode
    import Logger('Env)

    saveMode : () -> Boolean
    saveMode() ==
      m : Boolean := _$InteractiveMode $ Lisp
      SETF(_$InteractiveMode $ Lisp, false) $ Lisp
      m

    restoreMode : Boolean -> Void
    restoreMode m ==
      SETF(_$InteractiveMode $ Lisp, m) $ Lisp

    -- create empty environment
    new() ==
      _$compiler_InteractiveFrame $ Lisp

    addModemapsFromCategory(dom, cat, env) ==
      debug ["EnvAddModemapsFromCategory" :: PF, paren [dom :: PF, cat :: PF]]
      sdom := convert dom
      scat := convert cat
      m := saveMode()
      -- augModemapsFromCategory(domainName, domainView, functorForm, categoryForm, e)
      res : % := augModemapsFromCategory(sdom, sdom, sdom, scat, env)$Lisp
      restoreMode(m)
      res

    addDomain(dom, env) ==
      debug ["EnvAddDomain" :: PF, paren [dom :: PF]]
      sdom := convert dom
      m := saveMode()
      res : % := addDomain(sdom, env)$Lisp
      restoreMode(m)
      res

    addModemap(op, dom, args, env) ==
      debug ["EnvAddModeMap" :: PF, paren [op :: PF, dom :: PF, :[arg :: PF for arg in args]]]
      sdom := convert dom
      sargs := [convert arg for arg in args]
      m := saveMode()
      res : % := addModemap(op, sdom, sargs, 'T, op, env)$Lisp
      restoreMode(m)
      res

    getModemap(op, env) ==
      m := saveMode()
      res : List(SpadModemap) := get(op, 'modemap, env)$Lisp
      restoreMode(m)
      res

    addMode(name, type, env) ==
      debug ["EnvAddMode" :: PF, paren [name :: PF, type :: PF]]
      m := saveMode()
      res : % := put(name, 'mode, convert type, env)$Lisp
      restoreMode(m)
      res

    getMode(name, env) ==
      m := saveMode()
      res : SExpression := get(name, 'mode, env)$Lisp
      restoreMode(m)
      parse res

    putValue(name, value, env) ==
      debug ["EnvPutValue" :: PF, paren [name :: PF, value :: PF]]
      m := saveMode()
      res : % := put(name, 'value, convert value, env)$Lisp
      restoreMode(m)
      res

    getValue(name, env) ==
      m := saveMode()
      res : SExpression := get(name, 'value, env)$Lisp
      restoreMode(m)
      parse res

    definedSymbols(env) ==
      empty? env => []
      removeDuplicates [entry.name for entry in top env]

    coerce env ==
      entries : List(PF) := []
      empty? env => "()" :: PF
      for entry in top env repeat
        props : List(PF) := []
        for prop in entry.properties repeat
          val :=
            prop.kind = 'modemap =>
              mml := prop.value pretend List(SpadModemap)
              pile [mm :: PF for mm in mml]
            prop.kind = 'value =>
              v := parse prop.value
              v :: PF
            prop.kind = 'mode =>
              t := parse prop.value
              t :: PF
            convert(prop.value)
          of := spaces [hspace 1, prop.kind :: PF, "=>" :: PF, val]
          props := [of, :props]
        of := pile [hconcat [entry.name :: PF, ":" :: PF], pile reverse props]
        entries := [of, :entries]
      pile reverse entries

    test () ==
      _$forceAdd := true
      _$compErrorMessageStack := convert []

      env := new()
      dom1 := [['Polynomial], [['Integer]]] $ APP
      dom2 := [['Integer], []] $ APP
      env := addDomain(dom1, env)
      env := addDomain(dom2, env)
      modemaps := getModemap('*, env)
      for modemap in modemaps repeat
        println (modemap :: PF)
        println ""
      println (env :: PF)
