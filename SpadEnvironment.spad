)abbrev domain SPENV SpadEnvironment
SpadEnvironment() : Exports == Implementation where
  N ==> SpadNode
  APP ==> SpadApply(N)
  PF ==> PrintableForm
  TV ==> SpadTypeVar(N)
  TE ==> SpadTypeExpr(N)
  NT ==> SpadNamedType(N)
  SCOPE ==> AssociationList(Symbol, List(N))

  Exports ==> CoercibleTo(PrintableForm) with
    new : () -> %

    addDomain : (%, APP) -> %

    elt : (%, Symbol) -> List(N)
    setelt! : (%, Symbol, N) -> %

    createScope : % -> %
    discardScope : % -> %

    flatten : % -> %
    definedSymbols : % -> List(Symbol)
    domainInScope? : (%, APP) -> Boolean

  Implementation ==> add
    Rep := List SCOPE

    import SExpression
    import SpadNode
    import SpadNodeFactory
    import SpadTypeInfo
    import TypeUnifier
    import Logger('Env)
    import Printer

    -- create empty environment
    new() ==
      top : SCOPE := empty()
      top("$DomainsInScope" :: Symbol) := []
      [top]

    domainInScope?(env, dom) ==
      for level in env repeat
        for d in level("$DomainsInScope" :: Symbol) repeat
          if (d :: APP) = dom then
            return true
      return false

    addDomain(env, dom) ==
      domainInScope?(env, dom) => env

      debug ["EnvAddDomain" :: PF, paren [dom :: PF]]
      ti := getTypeInfo(dom)
      for n in ti.body.list repeat
        n' := substitute(n, typeVar() :: TV, [dom])
        guard := emptyNode()
        if typeGuard? n' then
          te := n' :: TE
          n' := te.expr
          guard := te.type
        if typeOrigin? n' then
          te := n' :: TE
          n' := te.expr
        nt := n' :: NT
        n' := nodeTypeExpr('_$, nt.type, [dom])
        if not emptyNode? guard then
          n' := nodeTypeExpr('_|, n', guard)
        env(nt.name) := n'
      env("$DomainsInScope" :: Symbol) := [dom]

    setelt!(env, name, value) ==
      lst := env(name)
      top := first env
      member?(value, lst) => env
      top(name) := [value, :lst]
      env

    elt(env, name) ==
      top := first env
      -- 1) if the symbol is found at first level the return it
      maybeEntries := assoc(name, top)
      not maybeEntries case "failed" =>
        maybeEntries.entry
      -- 2) if it is found deeper then (deep-)copy it to top level and return it
      res : List(N) := []
      for level in rest env repeat
        maybeEntries := assoc(name, level)
        if not maybeEntries case "failed" then
          res := copy(maybeEntries.entry)
          break
      top(name) := res

    flatten env ==
      empty? env => new()
      newenv := [[]]$AssociationList(Symbol, List(N))
      for level in env repeat
        for e in entries level repeat
          if not key?(e.key, newenv) then
            newenv(e.key) := e.entry
      [newenv]

    createScope env ==
      cons([[]], env)

    discardScope env ==
      rest env

    definedSymbols(env) ==
      keys first flatten env

    coerce env ==
      entries : List(PF) := []
      empty? env => "()" :: PF
      for e in entries first flatten env repeat
        sym := hconcat [bold cyan(e.key :: PF), ":" :: PF]
        mms := [mm :: PF for mm in e.entry]
        of :=
          empty? mms =>
            of := spaces [sym, "[]" :: PF]
          pile [sym, :mms]
        entries := [of, :entries]
      vconcat reverse entries

)abbrev domain SPENVT SpadEnvironmentTest
SpadEnvironmentTest() : Exports == Implementation where
  N ==> SpadNode
  APP ==> SpadApply(N)
  PF ==> PrintableForm

  Exports ==> with
    test1 : () -> Void
    test2 : () -> Void
    test3 : () -> Void

  Implementation ==> add
    import SpadEnvironment
    import SExpression
    import SpadNode
    import SpadNodeFactory
    import Printer
    import MainLogger

    test1 () ==
      loggerDefaultLevel "info"

      env := new()
      dom1 := [['Integer], []] $ APP
      dom2 := [['List], [['Integer]]] $ APP
      env := addDomain(env, dom1)
      env := addDomain(env, dom2)
      println (env :: PF)

    test2 () ==
      loggerDefaultLevel "info"

      env := new()
      dom0 := [['Polynomial], [emptyNode()]] $ APP
      dom1 := [['Polynomial], [nodeApp(['Integer], [])]] $ APP
      dom2 := [['Integer], []] $ APP
      env := addDomain(env, dom0)
      env := addDomain(env, dom1)
      env := addDomain(env, dom2)
      modemaps := env('*)
      println pile([hconcat [bold cyan ("*" :: PF), ":" :: PF],
                    :[(modemap :: PF) for modemap in modemaps]])
