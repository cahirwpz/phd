)abbrev domain SPENV SpadEnvironment
SpadEnvironment() : Exports == Implementation where
  N ==> SpadNode
  APP ==> SpadApply(N)
  TD ==> SpadTypeDecl(N)
  TG ==> SpadTypeGuard(N)
  TO ==> SpadTypeOrigin(N)
  TV ==> SpadTypeVar(N)
  PF ==> PrintableForm
  KEY ==> Union(Symbol, APP)
  MEMBER ==> Record(key : KEY, entry : List(N))
  SCOPE ==> HashTable(KEY, List(N), "UEQUAL")

  Exports ==> CoercibleTo(PrintableForm) with
    new : () -> %

    addDomain : (APP, %) -> %

    key? : (KEY, %) -> Boolean

    ++ returns empty list if nothing was found
    search : (KEY, %) -> List(N)
    ++ crashes if nothing was found
    elt : (%, KEY) -> List(N)
    setelt! : (%, KEY, N) -> %

    createScope : % -> %
    discardScope : % -> %

  Implementation ==> add
    Rep := List SCOPE

    import SpadNodeFactory
    import SpadTypeEvaluator
    import TypeUnifier
    import Logger('Env)
    import Printer

    -- create empty environment
    new() == [empty()$SCOPE]

    coerceKey (key : KEY) : PF ==
      key case APP => key :: APP :: PF
      key :: Symbol :: PF

    addDomain (dom : APP, env : %) : % ==
      key? (dom, env) => env
      notice ["Adding type" :: PF, bold (dom :: PF), "to the environment!" :: PF]
      ti := getTypeInfo(dom)
      env(dom) := [ti]
      for n in ti.body.list repeat
        n' := substitute(n, typeVar() :: TV, [dom])
        guard := emptyNode()
        if typeGuard? n' then
          tg := n' :: TG
          n' := tg.expr
          guard := tg.type
        if typeOrigin? n' then
          to := n' :: TO
          n' := to.expr
        td := n' :: TD
        n' := nodeTypeOrigin(td.type, [dom])
        if not emptyNode? guard then
          n' := nodeTypeGuard(n', guard)
        env(td.expr :: Symbol) := n'
      env

    key? (key : KEY, env : %) : Boolean ==
      for level in env repeat
        if key? (key, level) then
          return true
      false

    search (key : KEY, env : %) : List(N) ==
      empty? env => []
      top := first env
      -- 1) if the symbol is found at first level the return it
      result := search(key, top)
      result case List(N) => result
      -- 2) if it is found deeper then (deep-)copy it to top level and return it
      value : List(N) := []
      for level in rest env repeat
        result := search(key, level)
        result case List(N) =>
          value := copy(result :: List(N))
          top(key) := value
          break
      value

    setelt! (env : %, key : KEY, value : N) : % ==
      values := search(key, env)
      top := first env
      member?(value, values) => env
      top(key) := [value, :values]
      env

    elt (env : %, key : KEY) : List(N) ==
      result := search(key, env)
      empty? result =>
        fail [string bold coerceKey key, "missing from environment!" :: PF]
        error ""
      result

    flatten (env : %) : % ==
      empty? env => new()
      newenv : SCOPE := empty()
      for level in env repeat
        for e in members(level)@List(MEMBER) repeat
          if not key?(e.key, newenv) then
            newenv(e.key) := e.entry
      [newenv]

    createScope env ==
      cons(empty(), env)

    discardScope env ==
      rest env

    coerce env ==
      entries : List(PF) := []
      empty? env => "()" :: PF
      for e in members(first flatten env)@List(MEMBER) repeat
        sym := hconcat [bold cyan coerceKey e.key, ":" :: PF]
        mms := [mm :: PF for mm in e.entry]
        of :=
          empty? mms =>
            of := spaces [sym, "[]" :: PF]
          pile [sym, :mms]
        entries := [of, :entries]
      vconcat reverse entries

)abbrev domain SPENVT SpadEnvironmentTest
SpadEnvironmentTest() : Exports == Implementation where
  N ==> SpadNode
  APP ==> SpadApply(N)
  PF ==> PrintableForm

  Exports ==> with
    test1 : () -> Void
    test2 : () -> Void
    test3 : () -> Void

  Implementation ==> add
    import SpadEnvironment
    import SExpression
    import SpadNode
    import SpadNodeFactory
    import Printer
    import MainLogger

    test1 () ==
      loggerDefaultLevel "info"
      resetTime()

      env := new()
      dom1 := [['Integer], []] $ APP
      dom2 := [['List], [['Integer]]] $ APP
      env := addDomain(dom1, env)
      env := addDomain(dom2, env)
      println (env :: PF)

    test2 () ==
      loggerDefaultLevel "info"
      resetTime()

      env := new()
      dom0 := [['Polynomial], [emptyNode()]] $ APP
      dom1 := [['Polynomial], [nodeApp(['Integer], [])]] $ APP
      dom2 := [['Integer], []] $ APP
      env := addDomain(dom0, env)
      env := addDomain(dom1, env)
      env := addDomain(dom2, env)
      modemaps := env('*)
      println pile([hconcat [bold cyan ("*" :: PF), ":" :: PF],
                    :[(modemap :: PF) for modemap in modemaps]])
