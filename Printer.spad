)abbrev domain PRTCODE PrinterCode
PrinterCode() : Exports == Implementation where
  CMD ==> Record(fn : Union("indent", "unindent"), value : Integer)
  CODE ==> Union("eol", "reset", "bold", "underline", "italic", "inverse",
                 "black", "red", "green", "yellow", "blue", "magenta",
                 "cyan", "white", CMD)

  Exports ==> with
    eol : constant -> %
    reset : constant -> %
    bold : constant -> %
    underline : constant -> %
    italic : constant -> %
    inverse : constant -> %
    black : constant -> %
    red : constant -> %
    green : constant -> %
    yellow : constant -> %
    blue : constant -> %
    magenta : constant -> %
    cyan : constant -> %
    white : constant -> %

    eol? : % -> Boolean
    reset? : % -> Boolean
    bold? : % -> Boolean
    underline? : % -> Boolean
    italic? : % -> Boolean
    inverse? : % -> Boolean
    black? : % -> Boolean
    red? : % -> Boolean
    green? : % -> Boolean
    yellow? : % -> Boolean
    blue? : % -> Boolean
    magenta? : % -> Boolean
    cyan? : % -> Boolean
    white? : % -> Boolean

    indent : Integer -> %
    unindent : Integer -> %

    indent? : % -> Boolean
    unindent? : % -> Boolean

    value : % -> Integer

  Implementation ==> add
    Rep := CODE

    eol == "eol"@CODE
    reset == "reset"@CODE
    bold == "bold"@CODE
    underline == "underline"@CODE
    italic == "italic"@CODE
    inverse == "inverse"@CODE
    black == "black"@CODE
    red == "red"@CODE
    green == "green"@CODE
    yellow == "yellow"@CODE
    blue == "blue"@CODE
    magenta == "magenta"@CODE
    cyan == "cyan"@CODE
    white == "white"@CODE

    eol? c == c case "eol"
    reset? c == c case "reset"
    bold? c == c case "bold"
    underline? c == c case "underline"
    italic? c == c case "italic"
    inverse? c == c case "inverse"
    black? c == c case "black"
    red? c == c case "red"
    green? c == c case "green"
    yellow? c == c case "yellow"
    blue? c == c case "blue"
    magenta? c == c case "magenta"
    cyan? c == c case "cyan"
    white? c == c case "white"

    indent x == ["indent", x]$CMD
    unindent x == ["unindent", x]$CMD

    indent? c ==
      c case CMD => c.fn case "indent"
      false

    unindent? c ==
      c case CMD => c.fn case "unindent"
      false

    value c ==
      c case CMD =>
        c.value
      error "PrinterCode has no value!"

)abbrev domain PRTFORM PrintableForm
PrintableForm() : Exports == Implementation where
  NNI ==> NonNegativeInteger

  Exports ==> with
    ++ PrinterCode must be at the beginning for performance's sake
    construct : PrinterCode -> %
    construct : Integer -> %
    construct : Float -> %
    construct : String -> %
    construct : Symbol -> %
    construct : List(%) -> %

    float? : % -> Boolean
    integer? : % -> Boolean
    code? : % -> Boolean
    string? : % -> Boolean
    symbol? : % -> Boolean
    list? : % -> Boolean

    coerce : % -> PrinterCode
    coerce : % -> Float
    coerce : % -> Integer
    coerce : % -> String
    coerce : % -> Symbol
    coerce : % -> List(%)

    string : % -> %
    symbol : % -> %
    sepBy : (%, List(%)) -> %
    spaces : List(%) -> %
    hconcat : List(%) -> %
    hspace : NNI -> %
    paren : % -> %
    paren : List(%) -> %
    pile : List(%) -> %

    indent : Integer -> %
    unindent : Integer -> %

    red : % -> %
    bold : % -> %
    underline : % -> %
    italic : % -> %
    inverse : % -> %
    black : % -> %
    red : % -> %
    green : % -> %
    yellow : % -> %
    blue : % -> %
    magenta : % -> %
    cyan : % -> %
    white : % -> %

  Implementation ==> add
    Rep := Union(fnum : Float, inum : Integer, code : PrinterCode,
                 str : String, sym : Symbol, list : List(%))

    import Character

    construct (p : PrinterCode) : % == [p]$Rep
    construct (f : Float) : % == [f]$Rep
    construct (i : Integer) : % == [i]$Rep
    construct (s : String) : % == [s]$Rep
    construct (s : Symbol) : % == [s]$Rep
    construct (l : List(%)) : % == [l]$Rep

    code? f == f case code
    float? f == f case fnum
    integer? f == f case inum
    string? f == f case str
    symbol? f == f case sym
    list? f == f case list

    coerce (f : %) : PrinterCode ==
      code? f => f.code
      error "Cannot coerce to PrinterCode!"

    coerce (f : %) : Float ==
      float? f => f.fnum
      error "Cannot coerce to Float!"

    coerce (f : %) : Integer ==
      integer? f => f.inum
      error "Cannot coerce to Integer!"

    coerce (f : %) : String ==
      string? f => f.str
      error "Cannot coerce to String!"

    coerce (f : %) : Symbol ==
      symbol? f => f.sym
      error "Cannot coerce to Symbol!"

    coerce (f : %) : List(%) ==
      list? f => f.list
      error "Cannot coerce to List(PrintableForm)!"

    string f == [[["_""], f, ["_""]]]
    hconcat l == [l]
    symbol f == [[["'"], f]]
    paren (f : %) == paren [f]
    paren (l : List(%)) == [[["("], sepBy([", "], l), [")"]]]
    spaces l == sepBy([" "], l)
    hspace n == [new(n, char " ")]
    pile l == sepBy([eol], l)

    sepBy(s, l) ==
      empty? l => [""]
      r : List(%) := [first l, :r]
      for i in rest l repeat
        if not (first(r) case code) then
          r := [s, :r]
        r := [i, :r]
      [reverse r]

    indent n == [indent(n)$PrinterCode]
    unindent n == [unindent(n)$PrinterCode]

    red f == [[[red], f, [reset]]]
    green f == [[[green], f, [reset]]]

)abbrev package PRT Printer
Printer() : Exports == Implementation where
  PF ==> PrintableForm
  NNI ==> NonNegativeInteger
  STATE == Record(stream : SExpression,
                  column : Integer,
                  tabwidth : Integer,
                  preindent : Integer)

  Exports ==> with
    print : PrinterCode -> Void
    print : Float -> Void
    print : Integer -> Void
    print : String -> Void
    print : Symbol -> Void
    print : List(PF) -> Void
    print : PF -> Void

    println : PF -> Void
    println : List(PF) -> Void

  Implementation ==> add
    import Character
    import String

    p := [_$fricasOutput$Lisp,0,2,0]$STATE

    putraw : String -> Void
    putraw s ==
      PRINTEXP(s, p.stream)$Lisp

    newline : () -> Void
    newline() ==
      putraw(char 10 :: String)
      p.column := p.preindent
      p.preindent > 0 =>
        s := new(p.preindent :: NNI, char " ")
        putraw s

    csi : String -> Void
    csi s == putraw concat [char 27 :: String, "[", s]

    print (c : PrinterCode) ==
      eol? c => newline()
      reset? c => csi "0m"
      bold? c => csi "1m"
      italic? c => csi "3m"
      underline? c => csi "4m"
      inverse? c => csi "7m"
      black? c => csi "30m"
      red? c => csi "31m"
      green? c => csi "32m"
      yellow? c => csi "33m"
      blue? c => csi "34m"
      magenta? c => csi "35m"
      cyan? c => csi "36m"
      white? c => csi "37m"
      indent? c =>
        n := value c
        p.preindent := p.preindent + n
      unindent? c =>
        n := value c
        p.preindent :=
          p.preindent < n => 0
          p.preindent - n

    print (f : Float) ==
      s : String := WRITE_-TO_-STRING(f :: DoubleFloat)$Lisp
      print s

    print (i : Integer) ==
      print (string i)

    print(s : String) ==
      p.column := p.column + #s
      putraw(s)

    print (s : Symbol) ==
      print (string s)

    print (l : List(PF)) ==
      for f in l repeat
        print f 

    print (f : PF) ==
      code? f => print(f :: PrinterCode)
      float? f => print(f :: Float)
      integer? f => print(f :: Integer)
      string? f => print(f :: String)
      symbol? f => print(f :: Symbol)
      list? f => print(f :: List(PF))

    println (l : List(PF)) ==
      print l
      newline()

    println (f : PF) ==
      print f
      newline()

)abbrev package PRTTEST PrinterTest
PrinterTest() : Exports == Implementation where

  Exports ==> with
    test : () -> Void

  Implementation ==> add
    import Printer

    test () ==
      println [indent(2), spaces [red ["ala"], ["ma"], green ["kota"]]]
      println ["i nastepna linia"]
      println [unindent(2), spaces [["a"], ["kot"], ["ma"], ["ale"]]]
      println [["sqrt"], paren [2], [" = "], [sqrt(2.0)]]
      println spaces [["czyli"], ["powstal"], ["cykl"]]
      println symbol ['boolean]
      println string ["ciag znakow"]
      println paren [["baz"], red [2], ['foobar]]
      println [indent(2), pile [[1], [2], [3]]]
