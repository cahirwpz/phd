)abbrev package SNTVO SpadNodeTypeVarOccurs
SpadNodeTypeVarOccurs(tv' : TV) : SNP == Implementation where
)include SpadTypeDefs.inc

  Implementation ==> add
    walk (tv : TV) == tv = tv'

)abbrev package SNUNB SpadNodeUnbound
SpadNodeUnbound() : SNP == Implementation where
)include SpadTypeDefs.inc

  Implementation ==> add
    walk (tv : TV) == true
    walk () == true

)abbrev package SNCWILD SpadNodeContainsWildcard
SpadNodeContainsWildcard() : SNP == Implementation where
)include SpadTypeDefs.inc

  Implementation ==> add
    walk (mr : MR) == true

)abbrev package SNSYMRPL SpadNodeSymbolReplace
SpadNodeSymbolReplace(ctx : CTX) : SNR == Implementation where
  CTX ==> Table(Symbol, N)

)include SpadTypeDefs.inc

  Implementation ==> add
    walk (s : Symbol) : N ==
      r := search(s, ctx)
      r case "failed" => [s]
      r

)abbrev package SNTVSM SpadNodeTypeVarSetMajor
SpadNodeTypeVarSetMajor(major : NNI) : SNR == Implementation where
)include SpadTypeDefs.inc

  Implementation ==> add
    walk (tv : TV) : N == nodeTypeVar(major, tv.minor)

)abbrev package SNCFV SpadNodeCollectFreeVars
SpadNodeCollectFreeVars() : SpadNodeCollect(TV) == Implementation where
)include SpadTypeDefs.inc

  Implementation ==> add
    walk (tv : TV) == [tv]

)abbrev package SNCNR SpadNodeCollectNodeRefs
SpadNodeCollectNodeRefs() : SpadNodeCollect(NR) == Implementation where
)include SpadTypeDefs.inc

  Implementation ==> add
    walk (nr : NR) == [nr]

)abbrev package SNTOOLS SpadNodeTools
SpadNodeTools() : Exports == Implementation where
)include SpadTypeDefs.inc

  Exports ==> with
    occurs? : (TV, N) -> Boolean
    unbound? : N -> Boolean
    containsWildcard? : N -> Boolean

    freeVars : N -> List(TV)
    refList : N -> List(NR)

    substitute : (N, TV, N) -> N
    substitute : (N, SUBS) -> N

  Implementation ==> add
    import Printer
    import Logger('Term)
    import SpadNode
    import SpadNodeFactory

    occurs? (tv, n) == walk(n) $ SpadNodeTypeVarOccurs(tv)
    unbound? n == walk(n) $ SpadNodeUnbound
    containsWildcard? n == walk(n) $ SpadNodeContainsWildcard
    freeVars n == collect(n) $ SpadNodeCollectFreeVars
    refList n == collect(n) $ SpadNodeCollectNodeRefs

    substitute(n : N, var : TV, term : N) : N ==
      emptyNode? n => n
      integer? n => n
      string? n => n
      symbol? n => n
      marker? n => n

      apply? n =>
        app := n :: APP
        lst := [stripType substitute(k, var, term) for k in [app.function, :app.args]]
        nodeApp(first lst, rest lst)
      assign? n =>
        ass := n :: ASS
        nodeAssign(substitute(ass.lval, var, term),
                   substitute(ass.rval, var, term))
      condExpr? n =>
        ce := n :: CE
        cond := substitute(ce.cond, var, term)
        truebr := substitute(ce.truebr, var, term)
        falsebr := substitute(ce.falsebr, var, term)
        nodeCondExpr(cond, truebr, falsebr)
      function? n =>
        fn := n :: FN
        args := [substitute(arg, var, term) for arg in fn.args]
        type := substitute(fn.type, var, term)
        body := substitute(fn.body, var, term)
        nodeFun(fn.name, args, type, body)
      import? n =>
        im := n :: IM
        nodeImport(substitute(im.type, var, term))
      mappingType? n =>
        mt := n :: MT
        lst := [substitute(k, var, term) for k in [mt.result, :mt.args]]
        nodeMappingType(rest lst, first lst)
      recordType? n =>
        rt := n :: RT
        lst := [[substitute(f.expr, var, term), 
                 substitute(f.type, var, term)]$TD for f in fields rt]
        nodeRecordType(lst)
      unionType? n =>
        ut := n :: UT
        nodeUnionType [substitute(v, var, term) for v in variants ut]
      sequence? n =>
        seq := n :: SEQ
        nodeSeq(seq.kind, [substitute(t, var, term) for t in seq.list])
      typeInfo? n =>
        ti := n :: TI
        nodeTypeInfo(ti.name,
                     [substitute([arg], var, term) :: TD for arg in ti.args],
                     [substitute(hasItem, var, term) for hasItem in ti.hasList],
                     [substitute(c, var, term) for c in ti.constraints],
                     substitute(ti.superType, var, term),
                     substitute([ti.body], var, term) :: SEQ)
      typeDecl? n =>
        td := n :: TD
        nodeTypeDecl(substitute(td.expr, var, term),
                     substitute(td.type, var, term))
      typeGuard? n =>
        tg := n :: TG
        nodeTypeGuard(substitute(tg.expr, var, term),
                      substitute(tg.type, var, term))
      typeHas? n =>
        te := n :: TEH
        nodeTypeHas(substitute(te.expr, var, term),
                    substitute(te.type, var, term))
      typeIs? n =>
        te := n :: TEI
        nodeTypeIs(substitute(te.expr, var, term),
                   substitute(te.type, var, term))
      typeOrigin? n =>
        to := n :: TO
        nodeTypeOrigin(substitute(to.expr, var, term),
                       substitute(to.type, var, term))
      typeValue? n =>
        tv := n :: TVL
        nodeTypeValue(substitute(tv.type, var, term),
                      substitute(tv.value, var, term))
      typeVar? n =>
        if (n :: TV) = var then term else n

      fail ["substitute: case not handled for" :: PF, n :: PF]
      error ""

    substitute(n : N, subs : SUBS) : N ==
      for s in entries subs repeat
        var := s.key
        for term in s.entry repeat
          n := substitute(n, var, term)
      n
