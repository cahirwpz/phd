)abbrev package SNFAC SpadNodeFactory
SpadNodeFactory() : Exports == Implementation where
  PI ==> PositiveInteger
  MP ==> SpadMarkerPath
  N ==> SpadNode
  MR ==> SpadMarker(N)
  MT ==> SpadMappingType(N)
  NR ==> SpadNodeRef(N)
  NT ==> SpadNamedType(N)
  RT ==> SpadRecordType(N)
  UT ==> SpadUnionType(N)
  TE ==> SpadTypeExpr(N)
  TV ==> SpadTypeVar(N)
  mt ==> nodeMappingType

  Exports ==> with
    booleanType : () -> N
    floatType : () -> N
    integerType : () -> N
    outputFormType : () -> N
    stringType : () -> N
    symbolType : () -> N
    voidType : () -> N
    categoryType : () -> N

    typeAny : () -> N
    typeUndef : () -> N
    typeVar : () -> N
    typeVar : PI -> N
    typeVar : (PI, PI) -> N

    nodeRef : (PI, PI) -> N

    stripOriginIfCan : N -> N

    makeRecordFunList : N -> List(NT)
    makeUnionFunList : N -> List(NT)

  Implementation ==> add
    booleanType () == nodeApp(['Boolean], [])
    floatType () == nodeApp(['DoubleFloat], [])
    integerType () == nodeApp(['Integer], [])
    outputFormType () == nodeApp(['OutputForm], [])
    stringType () == nodeApp(['String], [])
    symbolType () == nodeApp(['Symbol], [])
    voidType () == nodeApp(['Void], [])
    categoryType () == nodeApp(['Category], [])

    typeAny() == [["%any"]$MR]
    typeUndef() == [["%undef"]$MR]
    typeVar() == [[0, 0]$TV]
    typeVar(j) == [[0, j]$TV]
    typeVar(i, j) == [[i, j]$TV]

    nodeRef(i, j) == [[i, j]$NR]

    stripOriginIfCan t ==
      (typeOrigin? t => (t :: TE).expr; t)

    makeRecordFunList n ==
      r := n :: RT
      funs : List(NT) :=
       ([['=, mt([n, n], booleanType())],
         ['~=, mt([n, n], booleanType())],
         ['copy, mt([n], n)],
         ['coerce, mt([n], outputFormType())],
         ['construct, mt([f.type for f in r.fields], n)]
        ])
      for f in r.fields repeat
        s : N := [f.name]
        r : N := f.type
        funs := ([[f.name, mt([['constant]$N], [f.name])],
                  ['elt, mt([n, s], r)],
                  ['setelt!, mt([n, s, r], r)], :funs])
      funs

    makeUnionFunList n ==
      u := n :: UT
      funs : List(NT) :=
       ([['=, mt([n, n], booleanType())],
         ['~=, mt([n, n], booleanType())],
         ['coerce, mt([n], outputFormType())]
        ])
      vs := u.variants
      if not namedType? vs.1 then
        for v in vs repeat
          funs := [['construct, mt([v], n)], 
                   ['coerce, mt([n], v)], :funs]
      funs
