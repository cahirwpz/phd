)abbrev package TUNIFY TypeUnifier
TypeUnifier() : Exports == Implementation where
  PF ==> PrintableForm
  N ==> SpadNode
  APP ==> SpadApply(N)
  ASS ==> SpadAssign(N)
  CE ==> SpadCondExpr(N)
  MT ==> SpadMappingType(N)
  NR ==> SpadNodeRef(N)
  SEQ ==> SpadSequence(N)
  RT ==> SpadRecordType(N)
  TD ==> SpadTypeDecl(N)
  TG ==> SpadTypeGuard(N)
  TEH ==> SpadTypeHas(N)
  TEI ==> SpadTypeIs(N)
  TO ==> SpadTypeOrigin(N)
  TV ==> SpadTypeVar(N)
  UT ==> SpadUnionType(N)
  SEQ ==> SpadSequence(N)
  FT ==> SpadFunctor(N)
  FN ==> SpadFunction(N)
  SUBST ==> AssociationList(TV, List(N))
  P ==> Record(t1 : N, t2 : N)
  URES ==> Union(SUBST, "failed")

  Exports ==> with
    failed? : URES -> Boolean 

    occurs? : (TV, N) -> Boolean
    unbound? : N -> Boolean
    containsWildcard? : N -> Boolean

    freeVars : N -> List(TV)
    refList : N -> List(NR)

    substitute : (N, TV, N) -> N
    substitute : (N, SUBST) -> N

    coerce : SUBST -> PF

    mergeSubstitutions : List(SUBST) -> SUBST

    unify? : (N, N) -> Boolean
    unifyType : (N, N) -> URES
    unifyType : (N, List(N)) -> URES

    findMatches : (List(N), List(N)) -> Record(terms : List(N), subst : SUBST)

    isSubType : (N, N) -> Boolean

  Implementation ==> add
    import SpadNode
    import Printer
    import SpadNodeFactory
    import Logger('Unify)

    failed? t == t case "failed"

    occurs? (tvar, n) ==
      import List(N)

      emptyNode? n => false
      integer? n => false
      string? n => false
      symbol? n => false
      marker? n => false

      occurs'? (m : N) : Boolean ==
        occurs?(tvar, m)

      apply? n =>
        app := n :: APP
        any?(occurs'?, [app.function, :app.args])
      mappingType? n =>
        mt := n :: MT
        any?(occurs'?, [mt.result, :mt.args])
      recordType? n =>
        rt := n :: RT
        any?(occurs'?, [[f] for f in fields(rt)])
      unionType? n =>
        ut := n :: UT
        any?(occurs'?, variants ut)
      sequence? n =>
        seq := n :: SEQ
        any?(occurs'?, seq.list)
      typeDecl? n =>
        td := n :: TD
        occurs'? td.expr or occurs'? td.type
      typeOrigin? n =>
        to := n :: TO
        occurs'? to.expr or occurs'? to.type
      typeVar? n =>
        (n :: TV) = tvar

      fail ["occurs?: case not handled for" :: PF, n :: PF]
      error ""

    unbound? n ==
      import List(N)

      emptyNode? n => true
      integer? n => false
      string? n => false
      symbol? n => false
      typeVar? n => true
      marker? n => false

      apply? n =>
        app := n :: APP
        unbound? app.function or any?(unbound?, app.args)
      recordType? n =>
        rt := n :: RT
        any?(unbound?, [[f] for f in fields rt])
      unionType? n =>
        ut := n :: UT
        any?(unbound?, variants ut)
      mappingType? n =>
        mt := n :: MT
        any?(unbound?, [mt.result, :mt.args])
      sequence? n =>
        seq := n :: SEQ
        any?(unbound?, seq.list)
      typeDecl? n =>
        td := n :: TD
        unbound? td.expr or unbound? td.type
      typeOrigin? n =>
        to := n :: TO
        unbound? to.expr or unbound? to.type

      fail ["unbound?: case not handled for" :: PF, n :: PF]
      error ""

    containsWildcard? n ==
      import List(N)

      emptyNode? n => false
      integer? n => false
      string? n => false
      symbol? n => false
      marker? n => true
      typeVar? n => false

      apply? n =>
        app := n :: APP
        any?(containsWildcard?, [app.function, :app.args])
      recordType? n =>
        rt := n :: RT
        any?(containsWildcard?, [[f] for f in fields rt])
      unionType? n =>
        ut := n :: UT
        any?(containsWildcard?, variants ut)
      mappingType? n =>
        mt := n :: MT
        any?(containsWildcard?, [mt.result, :mt.args])
      sequence? n =>
        seq := n :: SEQ
        any?(containsWildcard?, seq.list)
      typeDecl? n =>
        td := n :: TD
        containsWildcard? td.expr or containsWildcard? td.type
      typeOrigin? n =>
        to := n :: TO
        containsWildcard? to.expr or containsWildcard? to.type

      fail ["containsWildcard?: case not handled for" :: PF, n :: PF]
      error ""

    freeVars n ==
      import List(N)

      emptyNode? n => []
      integer? n => []
      symbol? n => []
      string? n => []

      apply? n =>
        app := n :: APP
        removeDuplicates("concat"/[freeVars i for i in [app.function, :app.args]])
      mappingType? n =>
        mt := n :: MT
        removeDuplicates("concat"/[freeVars i for i in [mt.result, :mt.args]])
      recordType? n =>
        rt := n :: RT
        removeDuplicates("concat"/[freeVars [i] for i in fields rt])
      unionType? n =>
        ut := n :: UT
        removeDuplicates("concat"/[freeVars i for i in variants ut])
      typeVar? n => [n :: TV]
      typeDecl? n =>
        td := n :: TD
        removeDuplicates(concat(freeVars td.type, freeVars td.expr))
      typeOrigin? n =>
        to := n :: TO
        removeDuplicates(concat(freeVars to.type, freeVars to.expr))

      fail ["freeVars: case not handled for" :: PF, n :: PF]
      error ""

    refListRec(n : N) : List(NR) ==
      import List(N)

      emptyNode? n => []
      symbol? n => []
      nodeRef? n => [n :: NR]
      
      apply? n =>
        app := n :: APP
        "concat"/[refListRec n for n in [app.function, :app.args]]
      assign? n =>
        a := n :: ASS
        concat(refListRec a.lval, refListRec a.rval)
      condExpr? n =>
        c := n :: CE
        concat [refListRec c.cond, refListRec c.truebr, refListRec c.falsebr]
      sequence? n =>
        s := n :: SEQ
        "concat"/[refListRec n for n in s.list]
      typeDecl? n =>
        td := n :: TD
        concat(refListRec td.type, refListRec td.expr)
      typeOrigin? n =>
        to := n :: TO
        concat(refListRec to.type, refListRec to.expr)

      fail ["refListRec: case not handled for" :: PF, n :: PF]
      error ""

    refList n ==
      removeDuplicates(refListRec n)

    substitute(n : N, var : TV, term : N) : N ==
      emptyNode? n => n
      integer? n => n
      string? n => n
      symbol? n => n
      marker? n => n

      apply? n =>
        app := n :: APP
        lst := [substitute(k, var, term) for k in [app.function, :app.args]]
        nodeApp(first lst, rest lst)
      condExpr? n =>
        ce := n :: CE
        cond := substitute(ce.cond, var, term)
        truebr := substitute(ce.truebr, var, term)
        falsebr := substitute(ce.falsebr, var, term)
        nodeCondExpr(cond, truebr, falsebr)
      function? n =>
        fn := n :: FN
        args := [substitute(arg, var, term) for arg in fn.args]
        type := substitute(fn.type, var, term)
        body := substitute(fn.body, var, term)
        nodeFun(fn.name, args, type, body)
      mappingType? n =>
        mt := n :: MT
        lst := [substitute(k, var, term) for k in [mt.result, :mt.args]]
        nodeMappingType(rest lst, first lst)
      recordType? n =>
        rt := n :: RT
        lst := [[substitute(f.expr, var, term), 
                 substitute(f.type, var, term)]$TD for f in fields rt]
        nodeRecordType(lst)
      unionType? n =>
        ut := n :: UT
        nodeUnionType [substitute(v, var, term) for v in variants ut]
      sequence? n =>
        seq := n :: SEQ
        nodeSeq(seq.kind, [substitute(t, var, term) for t in seq.list])
      typeDecl? n =>
        td := n :: TD
        nodeTypeDecl(substitute(td.expr, var, term),
                     substitute(td.type, var, term))
      typeGuard? n =>
        tg := n :: TG
        nodeTypeGuard(substitute(tg.expr, var, term),
                      substitute(tg.type, var, term))
      typeHas? n =>
        te := n :: TEH
        nodeTypeHas(substitute(te.expr, var, term),
                    substitute(te.type, var, term))
      typeIs? n =>
        te := n :: TEI
        nodeTypeIs(substitute(te.expr, var, term),
                   substitute(te.type, var, term))
      typeOrigin? n =>
        to := n :: TO
        nodeTypeOrigin(substitute(to.expr, var, term),
                       substitute(to.type, var, term))
      typeVar? n =>
        if (n :: TV) = var then term else n

      fail ["substitute: case not handled for" :: PF, n :: PF]
      error ""

    substitute(n : N, subst : SUBST) : N ==
      for s in entries subst repeat
        var := s.key
        for term in s.entry repeat
          n := substitute(n, var, term)
      n

    coerce (subst : SUBST) : PF ==
      bracket [spaces [s.key :: PF, "=>" :: PF, bracket [t :: PF for t in s.entry]] for s in entries subst]

    mergeSubstitutions substitutionsList ==
      merged : SUBST := empty()
      -- merge list for each valid substitution
      for substitutions in substitutionsList repeat
        for s in entries substitutions repeat
          merged(s.key) := 
            key?(s.key, merged) =>
              concat(s.entry, merged(s.key))
            s.entry
      -- remove duplicates from term lists
      for s in entries merged repeat
        merged(s.key) := removeDuplicates s.entry
      merged

    unifyType' : (N, N) -> URES

    unifyTypeList(pairs : List(P)) : URES ==
      subst : SUBST := empty()
      while not empty? pairs repeat
        pair := first pairs
        ures := unifyType'(pair.t1, pair.t2)
        failed? ures => return "failed"
        subst := concat (subst, ures :: SUBST)
        pairs := [[substitute(pair.t1, subst), substitute(pair.t2, subst)]$P for pair in rest pairs]
      subst

    unifyType'(n1 : N, n2 : N) : URES ==
      -- left or right node is a type variable => just generate a substitution
      typeVar? n1 and typeVar? n2 =>
        tv1 := n1 :: TV
        tv2 := n2 :: TV
        tv1 = tv2 => [[]]
        -- always substitute newer variable with older one to avoid (?) cycles
        if tv1 < tv2
          then [[[tv1, [n2]]]]
          else [[[tv2, [n1]]]]
      typeVar? n1 =>
        occurs? (n1 :: TV, n2) => "failed"
        [[[n1 :: TV, [n2]]]]
      typeVar? n2 =>
        occurs? (n2 :: TV, n1) => "failed"
        [[[n2 :: TV, [n1]]]]

      -- type wildcard found? => leave without generating a substitution
      typeAny? n1 or typeAny? n2 => [[]]

      -- both nodes can be represented as lists of terms and variables
      -- so convert them to a pair of lists and perform unification
      mappingType? n1 and mappingType? n2 =>
        mt1 := n1 :: MT
        mt2 := n2 :: MT
        #mt1.args ~= #mt2.args => "failed"
        unifyTypeList ([[t1, t2]$P for t1 in [mt1.result, :mt1.args]
                                   for t2 in [mt2.result, :mt2.args]])
      apply? n1 and apply? n2 =>
        app1 := n1 :: APP
        app2 := n2 :: APP
        #app1.args ~= #app2.args => "failed"
        unifyTypeList ([[t1, t2]$P for t1 in [app1.function, :app1.args]
                                   for t2 in [app2.function, :app2.args]])
      recordType? n1 and recordType? n2 =>
        rt1 := n1 :: RT
        rt2 := n2 :: RT
        #(fields rt1) ~= #(fields rt2) => "failed"
        for f1 in fields rt1 for f2 in fields rt2 repeat
          if f1.expr ~= f2.expr then
            return "failed"
        unifyTypeList ([[f1.type, f2.type]$P
                        for f1 in fields rt1 for f2 in fields rt2])
      unionType? n1 and unionType? n2 =>
        ut1 := n1 :: UT
        ut2 := n2 :: UT
        #(variants ut1) ~= #(variants ut2) => "failed"
        unifyTypeList ([[v1, v2]$P for v1 in variants ut1
                                   for v2 in variants ut2])
      typeDecl? n1 and typeDecl? n2 =>
        td1 := n1 :: TD
        td2 := n2 :: TD
        td1.expr ~= td2.expr => "failed"
        unifyType'(td1.type, td2.type)
      typeOrigin? n1 and typeOrigin? n2 =>
        to1 := n1 :: TO
        to2 := n2 :: TO
        unifyTypeList ([[to1.type, to2.type]$P, [to1.expr, to2.expr]$P])
      typeOrigin? n1 =>
        to1 := n1 :: TO
        unifyType'(to1.expr, n2)
      typeOrigin? n2 =>
        to2 := n2 :: TO
        unifyType'(n1, to2.expr)

      -- constants
      symbol? n1 and symbol? n2 and (n1 :: Symbol) = (n2 :: Symbol) => [[]]
      integer? n1 and integer? n2 and (n1 :: Integer) = (n2 :: Integer) => [[]]
      string? n1 and string? n2 and (n1 :: String) = (n2 :: String) => [[]]

      "failed"

    unifyType(n1 : N , n2 : N) : URES ==
      ures := unifyType'(n1, n2)
      summary : PF :=
        ures case "failed" =>
          paren bold red("no" :: PF)
        ures case SUBST =>
          spaces [paren bold green("yes" :: PF), (ures :: SUBST) :: PF]
      debug([brace bold(n1 :: PF), bold yellow("~" :: PF),
             brace bold(n2 :: PF), summary])
      ures

    unifyType(type : N, terms : List(N)) : URES ==
      ures : URES :=
        substList : List(SUBST) := []
        for term in terms repeat
          ures := unifyType'(term, type)
          ures case "failed" => "iterate"
          substList := [ures :: SUBST, :substList]
        empty? substList => "failed"
        mergeSubstitutions(substList)
      summary : PF :=
        ures case "failed" =>
          paren bold red("no" :: PF)
        ures case SUBST =>
          spaces [paren bold green("yes" :: PF), (ures :: SUBST) :: PF]
      debug([brace bold(type :: PF), bold yellow("~" :: PF),
             bracket [bold(t :: PF) for t in terms], summary])
      ures

    unify?(n1, n2) ==
      unifyType(n1, n2) case SUBST

    findMatches(terms1, terms2) ==
      terms : List(N) := []
      substList : List(SUBST) := []
      for t1 in terms1 repeat
        for t2 in terms2 repeat
          ures := unifyType'(t1, t2)
          failed? ures => "iterate"
          ++ prefer concrete type instead of wildcard
          t := if containsWildcard? t1 then t2 else t1
          ++ Avoid wildcard propagation by removing all substitutions with
          ++ wildcards in them.
          subst : SUBST := [[]]
          for s in entries(ures :: SUBST) repeat
            es := remove(containsWildcard?, s.entry)
            empty? es => "iterate"
            subst(s.key) := es
          t := substitute(t, subst)
          ++ Sometimes, by applying substitutions, unions will become
          ++ ill-formed (i.e. contain two fields of same type),
          ++ filter out such cases.
          emptyNode? t => "iterate"
          terms := [t, :terms]
          substList := [subst, :substList]
      ++ Remove wildcard if we have more than one match.
      if #terms > 1 then
        terms := [t for t in removeDuplicates terms | not containsWildcard? t]
      subst := mergeSubstitutions substList
      debug spaces(
        [bracket [bold(t1 :: PF) for t1 in terms1], bold yellow("~" :: PF),
         bracket [bold(t2 :: PF) for t2 in terms2],
         paren bold(empty? terms => red("no" :: PF); green("yes" :: PF))])
      [terms, subst]

    ++ INFO: Given a subtyping relation X <: Y, that reads as X is safe to use
    ++ in context where Y is used, we say that:
    ++ X <: Y => F(X) <: F(Y), then F is covariant
    ++ X <: Y => F(Y) <: F(X), then F is contravariant
    ++ otherwise F is invariant
    isSubType'(n1 : N, n2 : N) : Boolean ==
      typeUndef? n1 or typeUndef? n2 => false
      typeAny? n1 and typeAny? n2 => false

      n1 = n2 => true
      n2 = nodeApp(['Type], []) => true

      mappingType? n1 and mappingType? n2 =>
        ++ {(T1, T2, ..., Tn) -> T0} <: (S1, S2, ..., Sn) -> S0
        ++ Mapping type is contravariant in the input types, and covariant in
        ++ the output type, i.e. S1 <: T1, S2 <: T2, ..., T0 <: S0
        mt1 := n1 :: MT
        mt2 := n2 :: MT
        #mt1.args ~= #mt2.args => false
        for s in [mt1.result, :mt2.args]
          for t in [mt2.result, :mt1.args] repeat
            if not isSubType'(s, t) then
              return false
        true
      apply? n1 and apply? n2 =>
        -- {T0(T1, T2, ..., Tk)} <: {S0(S1, S2, ..., Sk)}
        -- AFAIK functors in SPAD are invariant (!) for the time being.
        -- Handle built-in subtyping relations.
        n1 = nodeApp(['PositiveInteger], []) =>
          isSubType'(nodeApp(['NonNegativeInteger], []), n2)
        n1 = nodeApp(['NonNegativeInteger], []) =>
          isSubType'(nodeApp(['Integer], []), n2)
        false
      recordType? n1 and recordType? n2 =>
        -- {Record(F1 : T1, F2 : T2, ..., Fn : Tn)}
        --   <: {Record(F1 : S1, F2 : S2, ..., Fn : Sn)}
        rt1 := n1 :: RT
        rt2 := n2 :: RT
        #(fields rt1) ~= #(fields rt2) => false
        for f1 in fields rt1 for f2 in fields rt2 repeat
          if f1.expr ~= f2.expr or not isSubType'(f1.type, f2.type) then
            return false
        true
      unionType? n2 =>
        if unionType? n1 then
          -- {Union(T1, T2, ..., Tn)} <: {Union(S1, S2, ..., Sm)} and n <= m
          ut1 := n1 :: UT
          ut2 := n2 :: UT
          #(variants ut1) > #(variants ut2) => false
          for v1 in variants ut1 for v2 in variants ut2 repeat
            if not isSubType'(v1, v2) then
              return false
          true
        else
          -- {Ti} <: {Union(T1, T2, ..., Ti, ...)}
          for v in variants(n2 :: UT) repeat
            if isSubType'(n1, v) then
              return true
          false
      typeDecl? n1 and typeDecl? n2 =>
        td1 := n1 :: TD
        td2 := n2 :: TD
        td1.expr = td2.expr and isSubType'(td1.type, td2.type)
      typeOrigin? n1 and typeOrigin? n2 =>
        to1 := n1 :: TO
        to2 := n2 :: TO
        to1.type = to2.type and isSubType'(to1.expr, to2.expr)
      -- Everything is subtype of wildcard type!
      typeAny? n2 => true

      sequence? n1 and sequence? n2 =>
        s1 := n1 :: SEQ
        s2 := n2 :: SEQ
        s1.kind ~= s2.kind => false
        l1 := s1.list
        l2 := s2.list
        #l1 < #l2 => false
        for i2 in l2 repeat
          present := false
          for i1 in l1 repeat
            isSubType'(i1, i2) =>
              present := true
          not present =>
            return false
        true

      false

    isSubType(n1, n2) ==
      r := isSubType'(n1, n2)
      debug (
        [brace(bold(n1 :: PF)), bold yellow("<:" :: PF), brace(bold(n2 :: PF)),
         paren(bold(r => green("yes" :: PF); red("no" :: PF)))])
      r
