)abbrev package STSYMRPL SpadTreeSymbolReplace
SpadTreeSymbolReplace(ctx : CTX) : WALKER == Implementation where
  N ==> SpadNode
  CTX ==> AssociationList(Symbol, N)
  WALKER ==> SpadTreeWalkerCategory 

  Implementation ==> add
    rewrite (s : Symbol) : N ==
      r := assoc(s, ctx)
      r case "failed" => [s]
      r.entry

)abbrev package FLATDBT FlattenDatabaseType
FlattenDatabaseType() : SpadTreeWalkerCategory == Implementation where
  PF ==> PrintableForm
  N ==> SpadNode
  APP ==> SpadApply(N)
  CE ==> SpadCondExpr(N)
  TE ==> SpadTypeExpr(N)
  SEQ ==> SpadSequence(N)

  Implementation ==> add
    import SpadNode
    import SpadNodeFactory

    rewrite (app : APP) : N ==
      app.function = ['ATTRIBUTE] => rewrite(first app.args)
      nodeApp(rewrite app.function, [rewrite arg for arg in app.args])

    addTypeGuard(n : N, cond : N) : N ==
      typeExpr? n =>
        tg : TE := coerce(n)
        nodeTypeExpr('_|, tg.expr, nodeApp(['and], [cond, tg.type]))
      nodeTypeExpr('_|, n, cond)

    listOf(n : N) : List(N) ==
      emptyNode? n => []
      sequence? n =>
        s : SEQ := coerce(n)
        s.list
      [n]

    rewrite (cn : CE) : N ==
      c := rewrite cn.cond
      nc := nodeApp(['not], [c])

      tl := [addTypeGuard(n, c) for n in listOf(rewrite cn.truebr)]
      fl := [addTypeGuard(n, nc) for n in listOf(rewrite cn.falsebr)]

      nodeSeq("Body", concat(tl, fl))

    rewrite (seq : SEQ) : N ==
      l : List(N) := []
      for n in seq.list repeat
        n := rewrite n
        emptyNode? n => "iterate"
        sequence? n =>
          s : SEQ := coerce(n)
          l := concat(reverse s.list, l)
        l := [n, :l]
      #l = 1 and seq.kind = "Body" => first l
      nodeSeq(seq.kind, l)

)abbrev domain TYPINF TypeInfo
TypeInfo() : Exports == Implementation where
  PF ==> PrintableForm
  N ==> SpadNode
  APP ==> SpadApply(N)
  MR ==> SpadMarker(N)
  TE ==> SpadTypeExpr(N)
  MT ==> SpadMappingType(N)
  SEQ ==> SpadSequence(N)
  CACHE ==> AssociationList(APP, %)
  DAASE ==> AssociationList(Symbol, %)

  Exports ==> CoercibleTo(PF) with
    typeInfo : (Symbol, List TE, List APP, List TE, SEQ) -> %

    elt : (%, "name") -> Symbol
    elt : (%, "args") -> List TE
    elt : (%, "hasList") -> List APP
    elt : (%, "constraints") -> List TE
    elt : (%, "body") -> SEQ

    typeInfoCacheInit : () -> Void
    typeInfoCacheList : () -> List(APP)

    getTypeInfo : Symbol -> %
    getTypeInfo : APP -> %

  Implementation ==> add
    import SpadNode
    import SpadNodeFactory
    import SpadDatabase
    import SpadCtorModeMap
    import Logger('TypeInfo)
    import TypeUnifier

    Rep := Record(ti_name : Symbol,
                  ti_args : List TE,
                  ti_hasList : List APP,
                  ti_constraints : List TE,
                  ti_body : SEQ)

    fromDatabase : Symbol -> Union(%, "failed")
    apply : (%, List(N)) -> %
    flatten : % -> %

    builtinCategories : List(Symbol) :=
      (['Canonical, 'CommutativeStar, 'Type, 'canonicalUnitNormal,
        'canonicalsClosed, 'finiteAggregate, 'multiplicativeValuation,
        'noZeroDivisors, 'shallowlyMutable, 'unitsKnown])

    cache : CACHE := [[]]
    daase : DAASE := [[]]

    typeInfoCacheInit () ==
      cache := [[]]
      daase := [[]]
      for cat in builtinCategories repeat
        app := [[cat], []]$APP
        ti := typeInfo(cat, [], [], [], ["Join", []]$SEQ)
        daase(cat) := ti
        cache(app) := ti

    typeInfoCacheList() == keys(cache)

    getTypeInfo(sym : Symbol) : % ==
      debug ["getTypeInfo :" :: PF, bold(sym :: PF)]
      ti? := search(sym, daase)
      ti? case % => ti? :: %
      daase(sym) := fromDatabase(sym) :: %

    getTypeInfo(app : APP) : % ==
      debug ["getTypeInfo :" :: PF, bold(app :: PF)]
      ti? := search(app, cache)
      ti? case % => ti? :: %
      ti! := 
        if app.args = [emptyNode()] then
          ti := getTypeInfo(app.function :: Symbol)
          flatten(ti)
        else
          ti := getTypeInfo([app.function, [emptyNode()]])
          apply(ti, app.args)
      cache(app) := ti!

    typeInfo(n, al, hl, ct, st) == [n, al, hl, ct, st]$Rep

    elt(x, "name") == x.ti_name
    elt(x, "args") == x.ti_args
    elt(x, "hasList") == x.ti_hasList
    elt(x, "constraints") == x.ti_constraints
    elt(x, "body") == x.ti_body

    coerce x ==
      args := [(typeVar? arg.expr => arg :: PF; arg.expr :: PF) for arg in x.ti_args]
      app := hconcat [x.ti_name :: PF, paren args]
      k : String :=
        x.ti_body.kind case "Join" => "Category"
        x.ti_body.kind case "Domain" => "Domain"
        x.ti_body.kind case "Package" => "Package"
        error "???"
      pile([spaces [app, bold("is" :: PF), k :: PF, bold("defined as:" :: PF)],
            x.ti_body :: PF,
            spaces [bold("has relation:" :: PF), bracket [h :: PF for h in x.ti_hasList]],
            spaces [bold("constraints:" :: PF), bracket [c :: PF for c in x.ti_constraints]]])

    mkvar(s1 : String, s2 : String) : Symbol ==
      concat(s1, s2)$String :: Symbol

    fromDatabase (t : Symbol) : Union(%, "failed") ==
      cmm! := safeGetCtorModeMap(t)
      cmm! case "failed" => "failed"
      cmm := cmm! :: SpadCtorModeMap

      ++ Some symbols will be rewritten to type variables.
      ctx := [[]]$AssociationList(Symbol, N)
      ++ "%" => "%0"
      ctx("%" :: Symbol) := typeVar(0)
      ++ "#1" => "%1", "#2" => "%2", ...
      for i in 1..#cmm.args repeat
        ctx(mkvar("#", string i)) := typeVar(i)

      ++ Symbols in SpadNamedType cannot be rewritten to type variable, so just
      ++ change name.
      args := ([nodeTypeExpr(':, typeVar(i), arg.type) :: TE
                for arg in cmm.args for i in 1..])

      if cmm.type = nodeApp(['Category], []) then
        ++ "t#1" => "%1", "t#2" => "%2", ...
        for arg in cmm.args for i in 1.. repeat
          ctx(mkvar("t", string arg.name)) := typeVar(i)
        body := getCtorCategory(t)
        cat? := true
      else
        body := cmm.type
        cat? := false

      body := nodeSeq((cat? => "Join"; "Domain"),
                      (sequence? body => (body :: SEQ).list; [body]))
      body := rewrite(body)$SpadTreeSymbolReplace(ctx)
      body := rewrite(body)$FlattenDatabaseType

      debug(body :: PF)

      typeInfo(cmm.name, args, [], [], body :: SEQ)

    apply(ti : %, values : List(N)) : % ==
      before := bold hconcat [ti.name :: PF, paren [arg :: PF for arg in ti.args]]
      after := bold hconcat [ti.name :: PF, paren [val :: PF for val in values]]

      #values ~= #ti.args =>
        fail(["Wrong number of arguments" :: PF, before, "passed to" :: PF,
              after, "functor!" :: PF])
        error ""
      empty? values => ti

      -- TODO: For now we completely ignore actual types passed as arguments.
      debug [before, "=>" :: PF, after]

      args' : List(TE) := []
      body' := [ti.body]
      hasList' := ti.hasList
      constraints' : List(TE) := ti.constraints

      for arg in ti.args for val in values repeat
        not typeVar? arg.expr =>
          error "Argument has been already applied!"
        var := arg.expr :: MR
        if arg.type ~= nodeApp(['Type], []) then
          constraints' := [['has, val, arg.type]$TE, :constraints']
        args' := [[':, val, arg.type]$TE, :args']
        body' := substitute(body', var, val)
        hasList' := [substitute([n], var, val) :: APP for n in hasList']

      typeInfo(ti.name, args', hasList', removeDuplicates constraints', body' :: SEQ)

    flatten(ti : %) : % ==
      self := [[ti.name], [[arg] for arg in ti.args]]$APP

      debug ["Flatten" :: PF, self :: PF]

      recurse? := true
      lst := ti.body.list
      constraints := ti.constraints
      hasLst : List(APP) := []

      while recurse? repeat
        recurse? := false
        lst' : List(N) := []

        for n in lst repeat
          apply? n =>
            app := n :: APP
            member?(app, hasLst) => "iterate"
            sym := app.function :: Symbol
            debug ["Merge" :: PF, app :: PF, "with" :: PF, self :: PF]
            ti' := getTypeInfo(sym) :: %
            ti' := apply(ti', app.args)
            for n' in ti'.body.list | not member?(n', lst') repeat
              lst' := [n', :lst']
            hasLst := [app, :hasLst]
            for app' in ti'.hasList | not member?(app', hasLst) repeat
              hasLst := [app', :hasLst]
            constraints := removeDuplicates concat(ti'.constraints, constraints)
            recurse? := true
          lst' := [n, :lst']
 
        lst := lst'

      body := [ti.body.kind, removeDuplicates lst]

      typeInfo(ti.name, ti.args, removeDuplicates hasLst, constraints, body)

)abbrev package TYPEVALT TypeEvaluatorTest
TypeEvaluatorTest() : Exports == Implementation where
  PF ==> PrintableForm
  N ==> SpadNode
  APP ==> SpadApply(N)
  NT ==> SpadNamedType(N)
  MR ==> SpadMarker(N)
  FN ==> SpadFunction(N)
  TI ==> TypeInfo

  Exports ==> with
    test1 : () -> Void

  Implementation ==> add
    import Printer
    import SpadNode
    import SpadNodeFactory
    import MainLogger
    import TypeInfo

    test1 ==
      loggerDefaultLevel "debug"
      loggerLevel('Parser, "notice")
      resetTime()

      typeInfoCacheInit()

      println (getTypeInfo('DictionaryOperations) :: PF)
      println (getTypeInfo('List) :: PF)
      println (getTypeInfo([['List], [emptyNode()]]) :: PF)
      println (getTypeInfo([['List], [['Integer]]]) :: PF)

      println ([bold("Types in cache:" :: PF),
                bracket [app :: PF for app in typeInfoCacheList()]])
