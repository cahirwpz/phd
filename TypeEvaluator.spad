)abbrev package STSYMRPL SpadTreeSymbolReplace
SpadTreeSymbolReplace(ctx : CTX) : WALKER == Implementation where
  N ==> SpadNode
  CTX ==> AssociationList(Symbol, N)
  WALKER ==> SpadTreeWalkerCategory 

  Implementation ==> add
    rewrite (s : Symbol) : N ==
      r := assoc(s, ctx)
      r case "failed" => [s]
      r.entry

)abbrev package STMSETV SpadTreeMarkerSetVersion
SpadTreeMarkerSetVersion(newver : NNI) : WALKER == Implementation where
  N ==> SpadNode
  MR ==> SpadMarker(N)
  NNI ==> NonNegativeInteger
  WALKER ==> SpadTreeWalkerCategory 

  Implementation ==> add
    rewrite (mr : MR) : N ==
      if mr.kind = 'typevar then
        mr := [mr.id, newver, 'typevar]
      [mr]

)abbrev package FLATDBT FlattenDatabaseType
FlattenDatabaseType() : SpadTreeWalkerCategory == Implementation where
  PF ==> PrintableForm
  N ==> SpadNode
  APP ==> SpadApply(N)
  CE ==> SpadCondExpr(N)
  TE ==> SpadTypeExpr(N)
  SEQ ==> SpadSequence(N)

  Implementation ==> add
    import SpadNode
    import SpadNodeFactory

    rewrite (app : APP) : N ==
      app.function = ['ATTRIBUTE] => rewrite(first app.args)
      nodeApp(rewrite app.function, [rewrite arg for arg in app.args])

    addTypeGuard(n : N, cond : N) : N ==
      typeGuard? n =>
        tg : TE := coerce(n)
        nodeTypeExpr('_|, tg.expr, nodeApp(['and], [cond, tg.type]))
      nodeTypeExpr('_|, n, cond)

    listOf(n : N) : List(N) ==
      emptyNode? n => []
      sequence? n =>
        s : SEQ := coerce(n)
        s.list
      [n]

    rewrite (cn : CE) : N ==
      c := rewrite cn.cond
      nc := nodeApp(['not], [c])

      tl := [addTypeGuard(n, c) for n in listOf(rewrite cn.truebr)]
      fl := [addTypeGuard(n, nc) for n in listOf(rewrite cn.falsebr)]

      nodeSeq("Body", concat(tl, fl))

    rewrite (seq : SEQ) : N ==
      l : List(N) := []
      for n in seq.list repeat
        n := rewrite n
        emptyNode? n => "iterate"
        sequence? n =>
          s : SEQ := coerce(n)
          l := concat(reverse s.list, l)
        l := [n, :l]
      #l = 1 and seq.kind = "Body" => first l
      nodeSeq(seq.kind, l)

)abbrev domain TYPINF TypeInfo
TypeInfo() : Exports == Implementation where
  PF ==> PrintableForm
  N ==> SpadNode
  APP ==> SpadApply(N)
  MR ==> SpadMarker(N)
  TE ==> SpadTypeExpr(N)
  MT ==> SpadMappingType(N)
  NT ==> SpadNamedType(N)
  SEQ ==> SpadSequence(N)
  CACHE ==> AssociationList(APP, %)
  DAASE ==> AssociationList(Symbol, %)
  SUBST ==> AssociationList(MR, List(N))

  Exports ==> CoercibleTo(PF) with
    typeInfo : (Symbol, List TE, List N, List N, SEQ) -> %

    elt : (%, "name") -> Symbol
    elt : (%, "args") -> List TE
    elt : (%, "hasList") -> List N 
    elt : (%, "constraints") -> List N
    elt : (%, "body") -> SEQ
    elt : (%, "self") -> APP
    elt : (%, "type") -> N

    typeInfoCacheInit : () -> Void
    typeInfoCacheList : () -> List(APP)

    getTypeInfo : Symbol -> %
    getTypeInfo : APP -> %

  Implementation ==> add
    import SpadNode
    import SpadNodeFactory
    import SpadDatabase
    import SpadCtorModeMap
    import Logger('TypeInfo)
    import TypeUnifier
    import Printer

    Rep := Record(ti_name : Symbol,
                  ti_args : List TE,
                  ti_hasList : List N,
                  ti_constraints : List N,
                  ti_body : SEQ)

    fromDatabase : Symbol -> Union(%, "failed")
    apply : (%, List(N)) -> %
    flatten : % -> %
    evalTypeGuards : % -> %
    eraseConstraints : (%, Boolean) -> %

    cache : CACHE := [[]]
    daase : DAASE := [[]]

    typeInfoCacheInit () ==
      cache := [[]]
      daase := [[]]

    typeInfoCacheList() == keys(cache)

    getTypeInfo(sym : Symbol) : % ==
      notice ["getTypeInfoFromDatabase:" :: PF, bold(sym :: PF)]

      ti? := search(sym, daase)
      ti? case % => ti? :: %
      daase(sym) := fromDatabase(sym) :: %

    getTypeInfo(app : APP) : % ==
      ti? := search(app, cache)
      ti? case % => ti? :: %

      notice ["getTypeInfo :" :: PF, bold(app :: PF)]

      validate? := true
      ti! := 
        if app.args = [emptyNode()] then
          validate? := false
          ti := getTypeInfo(app.function :: Symbol)
          flatten(ti)
        else
          ti := getTypeInfo([app.function, [emptyNode()]])
          apply(ti, app.args)

      ti! := evalTypeGuards(ti!)

      empty? freeVars [app] =>
        cache(app) := ti!
        ti! := eraseConstraints(ti!, validate?)
        info ["addTypeInfo :" :: PF, bold(app :: PF)]
        cache(app) := ti!

      ti!

    typeInfo(n, al, hl, ct, st) == [n, al, hl, ct, st]$Rep

    elt(x, "name") == x.ti_name
    elt(x, "args") == x.ti_args
    elt(x, "hasList") == x.ti_hasList
    elt(x, "constraints") == x.ti_constraints
    elt(x, "body") == x.ti_body
    elt(x, "self") == [[x.ti_name], [[arg] for arg in x.ti_args]]$APP
    elt(x, "type") == nodeApp([x.ti_name], [arg.expr for arg in x.ti_args])

    coerce x ==
      args := [arg :: PF for arg in x.ti_args]
      app := hconcat [x.ti_name :: PF, paren args]
      k : String :=
        x.ti_body.kind case "Join" => "Category"
        x.ti_body.kind case "Domain" => "Domain"
        x.ti_body.kind case "Package" => "Package"
        error "???"
      pile([spaces [app, bold("is" :: PF), k :: PF],
            pile [bold("defined as:" :: PF), x.ti_body :: PF],
            pile [bold("has relation:" :: PF), :[h :: PF for h in x.ti_hasList]],
            pile [bold("constraints:" :: PF), :[c :: PF for c in x.ti_constraints]]])

    mkvar(s1 : String, s2 : String) : Symbol ==
      concat(s1, s2)$String :: Symbol

    true?(e : N) : Boolean ==
      e = ['true]

    false?(e : N) : Boolean ==
      e = ['false]

    fromDatabase (t : Symbol) : Union(%, "failed") ==
      debug ["fromDatabase :" :: PF, bold(t :: PF)]

      cmm! := safeGetCtorModeMap(t)
      cmm! case "failed" => "failed"
      cmm := cmm! :: SpadCtorModeMap

      ++ Some symbols will be rewritten to type variables.
      ctx := [[]]$AssociationList(Symbol, N)
      ++ "%" => "%0"
      ctx("%" :: Symbol) := typeVar(0)
      ++ "#1" => "%1", "#2" => "%2", ...
      for i in 1..#cmm.args repeat
        ctx(mkvar("#", string i)) := typeVar(i)

      ++ Symbols in SpadNamedType cannot be rewritten to type variable, so just
      ++ change name.
      types := [rewrite(arg.type)$SpadTreeSymbolReplace(ctx) for arg in cmm.args] 
      args := [[':, typeVar(i), typ]$TE for typ in types for i in 1..]

      if cmm.type = nodeApp(['Category], []) then
        ++ "t#1" => "%1", "t#2" => "%2", ...
        for arg in cmm.args for i in 1.. repeat
          ctx(mkvar("t", string arg.name)) := typeVar(i)
        body := getCtorCategory(t)
        cat? := true
      else
        body := cmm.type
        cat? := false

      body := nodeSeq((cat? => "Join"; "Domain"),
                      (sequence? body => (body :: SEQ).list; [body]))
      body := rewrite(body)$SpadTreeSymbolReplace(ctx)
      body := rewrite(body)$FlattenDatabaseType

      typeInfo(cmm.name, args, [], [], body :: SEQ)

    DelVer := SpadTreeMarkerSetVersion(0)
    AddVer := SpadTreeMarkerSetVersion(1)

    apply(ti : %, values : List(N)) : % ==
      before := bold hconcat [ti.name :: PF, paren [arg :: PF for arg in ti.args]]
      after := bold hconcat [ti.name :: PF, paren [val :: PF for val in values]]

      #values ~= #ti.args =>
        info(ti :: PF)
        fail(["Wrong number of arguments:" :: PF, bold paren [val :: PF for val in values],
              "passed to:" :: PF, before, "functor!" :: PF])
        error ""
      empty? values => ti

      -- debug ["Unifies:" :: PF, before, "~" :: PF, after, "?" :: PF]

      n1 := nodeApp([ti.name], [arg.expr for arg in ti.args])
      n2 := nodeApp([ti.name], values)

      res := unifyType(n1, rewrite(n2)$AddVer)
      failed? res =>
        fail ("unification failed" :: PF)
        error ""

      -- solution for functor argument application problem
      subst := res :: SUBST

      args' := [substitute([arg], subst) :: TE for arg in ti.args]
      body' := substitute([ti.body], subst)
      hasList' := [substitute(hasItem, subst) for hasItem in ti.hasList]
      constraints' :=
        concat(nodeApp([ti.name], [[arg] for arg in args']),
               [substitute(c, subst) for c in ti.constraints])

      args' := [rewrite(arg)$DelVer :: TE for arg in args']
      body' := rewrite(body')$DelVer
      hasList' := [rewrite(hasItem)$DelVer for hasItem in hasList']
      constraints' := [rewrite(con)$DelVer for con in constraints']

      -- BUG: Fix improper functor application. 
      -- i.e. when List(Integer) is passed instead of List(Integer())
      -- however... we don't want to fix "'sym : Symbol" parameter
      --if symbol? val and typ ~= symbolType() then
      --  val := nodeApp(val, [])

      typeInfo(ti.name, args', hasList', constraints', body' :: SEQ)

    flatten(ti : %) : % ==
      info ["Flatten" :: PF, bold(ti.self :: PF)]

      origBody := ti.body.list
      flatBody : List(N) := []
      hasLst : AssociationList(APP, N) := [[]]
      constraints := ti.constraints

      while not empty? origBody repeat
        (n, origBody) := (first origBody, rest origBody)

        cond := ['true]
        if typeGuard? n then 
          tg := n :: TE
          if apply? tg.expr then
            -- encountered a functor with constraints
            (n, cond) := (tg.expr, tg.type)

        -- merge functor
        apply? n =>
          app := n :: APP

          -- check if we have already merged a functor
          key?(app, hasLst) => 
            info ["Skipping:" :: PF, bold(app :: PF), "with" :: PF, bold(hasLst(app) :: PF)]
            true? cond =>
              hasLst(app) := cond
            true? hasLst(app) => "iterate"
            hasLstVal := hasLst(app)
            condLst : List(N) :=
              apply? hasLstVal =>
                (hasLstVal :: APP).args
              [hasLstVal]
            member?(cond, condLst) => "iterate"
            hasLst(app) := nodeApp(['or], concat(cond, condLst))

          info(["Merge" :: PF, bold(true? cond => n :: PF; nodeTypeExpr('_|, n, cond) :: PF),
                "with" :: PF, ti.self :: PF])

          hasLst(app) := cond
          ti' := getTypeInfo(app.function :: Symbol) :: %
          ti' := apply(ti', app.args)
          constraints := concat(ti'.constraints, constraints)

          -- extend original functor's body with included constructor type
          snippet : List(N) := []

          if true? cond then
            -- case 1: merged functor has no constraints
            for e in ti'.body.list repeat
              e' :=
                apply? e or typeGuard? e => e 
                namedType? e => nodeTypeExpr('_$, e, n)
                error "Not handled!"
              snippet := [e', :snippet]
          else
            -- case 2: merged functor has some constraints

            -- INFO: When we merge functor A with %, we know that all what is
            -- within A belongs to % only when "% has A". Hence for each
            -- component of A we remember simple constraint "% has A".
            -- More complex constraints are remembered in hasList.
            --
            -- This allows to add extra options to condition "% has A" in case
            -- we encounter some other (less restrictive) constraints later.
            cond := nodeTypeExpr('has, typeVar(0), [app])

            for e in ti'.body.list repeat
              e' :=
                apply? e => -- add constraint to merged functor
                  nodeTypeExpr('_|, e, cond)
                namedType? e => -- add origin to function signature
                  e := nodeTypeExpr('_$, e, n)
                  nodeTypeExpr('_|, e, cond)
                typeGuard? e => -- add extra constraint to merged functor
                  te := e :: TE
                  nodeTypeExpr('_|, te.expr, nodeApp(['and], [cond, te.type]))
                error "Not handled!"
              snippet := [e', :snippet]

          origBody := concat(reverse snippet, origBody)

        -- merge everything else
        namedType? n or typeGuard? n or typeOrigin? n =>
          info ["Copy" :: PF, bold(n :: PF), "to" :: PF, ti.self :: PF]
          flatBody := [n, :flatBody]

        info ["Flatten" :: PF, n :: PF]
        error "Not handled!"

      hasLst' : List(N) := []
      for he in entries hasLst repeat
        h := 
          true? he.entry => [he.key]
          nodeTypeExpr('_|, [he.key], he.entry)
        hasLst' := [h, :hasLst']

      typeInfo(ti.name, ti.args, hasLst',
               removeDuplicates constraints,
               [ti.body.kind, reverse flatBody])

    has?(te : TE, ti : %) : Boolean ==
      (t0, t1) := (te.expr, te.type)

      t1 = nodeApp(['Type], []) => true

      if symbol? t0 then t0 := symbolType()
      if integer? t0 then t0 := integerType()
      if t0 = ti.type then t0 := typeVar(0)

      t0 = t1 => true

      ti := 
        apply? t0 =>
          app := t0 :: APP
          app.function = [ti.name] => ti -- will have to investigate that
          getTypeInfo(app)
        t0 = typeVar(0) => ti
        typeVar?(t0) => return false
        fail [te :: PF]
        error "Not handled!"

      -- case "A has B"
      apply? t1 =>
        member?(t1, ti.hasList)

      -- case "A has Join(..)"
      sequence? t1 =>
        seq := t1 :: SEQ
        "and"/[has?(['has, t0, typ]$TE, ti) for typ in seq.list]

      -- case "A has { fn : (..) -> .. }"
      namedType? t1 and not unbound? [te] =>
        seq := ti.body :: SEQ
        for n in seq.list repeat
          if typeOrigin? n then
            n := (n :: TE).expr
          not namedType? n => "iterate"
          n := substitute(n, typeVar(0) :: MR, t0)
          if n = t1 then
            return true
        false

      fail [te :: PF]
      error "Not handled!"

    evalGuard(n : N, ti : %) : N ==
      -- debug ["evalGuard" :: PF, bold(n :: PF)]
      typeExpr? n =>
        te := n :: TE
        te.kind = 'has and has?(te, ti) => ['true]
        n
      apply? n =>
        app := n :: APP
        lst := [evalGuard(arg, ti) for arg in app.args]
        app.function = ['and] =>
          any?(false?, lst) => ['false]
          lst := remove(true?, lst)
          #lst = 0 => ['true]
          #lst = 1 => first lst
          nodeApp(['and], lst)
        app.function = ['or] =>
          any?(true?, lst) => ['true]
          lst := remove(false?, lst)
          #lst = 0 => ['false]
          #lst = 1 => first lst
          nodeApp(['or], lst)
        app.function = ['not] and #app.args = 1 =>
          n' := evalGuard(first app.args, ti)
          true? n' => ['false]
          n
        fail ["evalGuard" :: PF, bold(n :: PF)]
        error "Not handled!"
      n

    eraseConstraints(ti : %, validate : Boolean) : % ==
      info ["Check type constraints" :: PF, bold(ti.self :: PF)]

      appliesCleanly(n : N) : Boolean ==
        app := n :: APP
        "and"/[has?(m :: TE, ti) for m in app.args]

      constraints' := remove(appliesCleanly, ti.constraints)

      validate and not empty? constraints' =>
        fmtarg(n : N) : PF ==
          te := n :: TE
          has?(te, ti) => te.expr :: PF
          bold(red(te.expr :: PF))

        fmterr(n : N) : PF ==
          te := n :: TE
          spaces [bold(te.expr :: PF), "has no" :: PF, bold(te.type :: PF)]

        fail ["Could not construct type" :: PF, bold(ti.type :: PF), ":" :: PF]

        for c in constraints' for i in 1.. repeat
          app := c :: APP
          typ := hconcat [app.function :: PF, paren [fmtarg arg for arg in app.args]]
          err := [fmterr arg for arg in app.args | not has?(arg :: TE, ti)]
          fail [paren(i :: PF), typ, ":" :: PF, sepBy(", " :: PF, err)]
        error ""

      typeInfo(ti.name, ti.args, ti.hasList, constraints', ti.body)

    evalTypeGuards(ti : %) : % ==
      info ["Evaluate type guards for:" :: PF, bold(ti.self :: PF)]

      continue? := true

      while continue? repeat
        newHasList : List(N) := []
        continue? := false

        for n in ti.hasList repeat
          n' := 
            not typeGuard? n => n
            tg := n :: TE
            type' := evalGuard(tg.type, ti)
            type' = ['true] => (continue? := true; tg.expr)
            nodeTypeExpr('_|, tg.expr, type')
          newHasList := [n', :newHasList]

        ti := typeInfo(ti.name, ti.args, reverse newHasList, ti.constraints, ti.body)

      eval(n : N) : N ==
        not typeGuard? n => n
        tg := n :: TE
        type' := evalGuard(tg.type, ti)
        type' = ['true] => tg.expr
        nodeTypeExpr('_|, tg.expr, type')

      body := map(eval, ti.body.list)

      typeInfo(ti.name, ti.args, ti.hasList, ti.constraints, [ti.body.kind, body])

)abbrev package TYPEVALT TypeEvaluatorTest
TypeEvaluatorTest() : Exports == Implementation where
  PF ==> PrintableForm
  N ==> SpadNode
  APP ==> SpadApply(N)
  NT ==> SpadNamedType(N)
  MR ==> SpadMarker(N)
  FN ==> SpadFunction(N)
  TI ==> TypeInfo

  Exports ==> with
    test1 : () -> Void
    test2 : () -> Void
    test3 : () -> Void
    test4 : () -> Void

    fail1 : () -> Void
    fail2 : () -> Void

  Implementation ==> add
    import Printer
    import SpadNode
    import SpadNodeFactory
    import MainLogger
    import TypeInfo

    initTest : () -> Void
    initTest ==
      loggerDefaultLevel "info"
      loggerLevel('Parser, "notice")
      resetTime()
      typeInfoCacheInit()

    printTypeInfoCache : () -> Void
    printTypeInfoCache ==
      println([bold("Types in cache:" :: PF),
               bracket [app :: PF for app in typeInfoCacheList()]])

    test1 ==
      initTest()

      -- simple DAASE lookup
      println (getTypeInfo('unitsKnown) :: PF)
      println (getTypeInfo('SetCategory) :: PF)
      println (getTypeInfo('DictionaryOperations) :: PF)
      println (getTypeInfo('UnivariatePuiseuxSeries) :: PF)

      println (getTypeInfo('Integer) :: PF)
      println (getTypeInfo('List) :: PF)
      println (getTypeInfo('Fraction) :: PF)
      println (getTypeInfo('Expression) :: PF)

      printTypeInfoCache()

    test2 ==
      initTest()

      -- emptyNode() passed as a list of parameters to a functor prevents
      -- constrains evaluation

      -- type flattening, type constrains are left unevaluated
      println (getTypeInfo([['Integer], [emptyNode()]]) :: PF)
      println (getTypeInfo([['List], [emptyNode()]]) :: PF)
      println (getTypeInfo([['Fraction], [emptyNode()]]) :: PF)
      println (getTypeInfo([['Expression], [emptyNode()]]) :: PF)
      println (getTypeInfo([['UnivariateTaylorSeries], [emptyNode()]]) :: PF)
      println (getTypeInfo([['ExponentialExpansion], [emptyNode()]]) :: PF)

      printTypeInfoCache()

    test3 ==
      initTest()

      -- type flattening, type contrains evaluation
      println (getTypeInfo([['NonNegativeInteger], []]) :: PF)
      println (getTypeInfo([['Integer], []]) :: PF)
      println (getTypeInfo([['Symbol], []]) :: PF)
      println (getTypeInfo([['Float], []]) :: PF)
      println (getTypeInfo([['List], [nodeApp(['Integer], [])]]) :: PF)
      println (getTypeInfo([['Fraction], [nodeApp(['Integer], [])]]) :: PF)
      println (getTypeInfo([['Expression], [nodeApp(['Integer], [])]]) :: PF)

      printTypeInfoCache()

    test4 ==
      initTest()

      -- TODO
      println (getTypeInfo([['UnivariateTaylorSeries], [emptyNode()]]) :: PF)
      println (getTypeInfo([['UnivariateTaylorSeries], [integerType(), ['x]$N, [2]$N]]) :: PF)

      printTypeInfoCache()

    -- Should I consider following case:
    -- typeAny() "%any" passed as a parameter to a functor prevents contraint
    -- evaluation that involves the parameter

    fail1 ==
      initTest()

      -- wrong number of arguments => should fail!
      println (getTypeInfo([['List], []]) :: PF)

    fail2 ==
      initTest()

      -- wrong type parameter => should fail!
      println (getTypeInfo([['List], [nodeApp(['BasicType], [])]]) :: PF)
