)abbrev package STSYMRPL SpadTreeSymbolReplace
SpadTreeSymbolReplace(ctx : CTX) : WALKER == Implementation where
  N ==> SpadNode
  CTX ==> AssociationList(Symbol, N)
  WALKER ==> SpadTreeWalkerCategory 

  Implementation ==> add
    rewrite (s : Symbol) : N ==
      r := assoc(s, ctx)
      r case "failed" => [s]
      r.entry

)abbrev package STFTEVAL SpadFunctorEvaluate
SpadFunctorEvaluate(ctx : CTX) : WALKER == Implementation where
  N ==> SpadNode
  APP ==> SpadApply(N)
  CE ==> SpadCondExpr(N)
  TE ==> SpadTypeExpr(N)
  ST ==> SpadSumType(N)
  MR ==> SpadMarker(N)
  CTX ==> AssociationList(MR, List(N))
  WALKER ==> SpadTreeWalkerCategory 

  Implementation ==> add
    rewrite (app : APP) : N ==
      app := [rewrite app.function, [rewrite arg for arg in app.args]]$APP
      app.function = ['OR] and #app.args = 2 =>
        "or"/[arg = ['true] for arg in app.args] => ['true]
        "and"/[arg = ['false] for arg in app.args] => ['false]
        app.args.1 = ['false] => app.args.2
        app.args.2 = ['false] => app.args.1
        [app]
      app.function = ['AND] and #app.args = 2 =>
        "and"/[arg = ['true] for arg in app.args] => ['true]
        "or"/[arg = ['false] for arg in app.args] => ['false]
        app.args.1 = ['true] => app.args.2
        app.args.2 = ['true] => app.args.1
        [app]
      [app]

    rewrite (cn : CE) : N ==
      ce := [rewrite cn.cond, rewrite cn.truebr, rewrite cn.falsebr]$CE
      ce.cond = ['true] => ce.truebr
      ce.cond = ['false] => ce.falsebr
      [ce]

    rewrite (te : TE) : N ==
      if typeVar? te.expr and te.kind = 'has then
        res := assoc(te.expr :: MR, ctx)
        if not (res case "failed") then
          if member?(te.type, res.entry) then
            return ['true]
          else
            return ['false]
      nodeTypeExpr(te.kind, rewrite te.expr, rewrite te.type)

    rewrite (st : ST) : N ==
      ts := [rewrite t for t in st.types]
      nodeSumType(st.kind, [t for t in ts | not emptyNode? t])

)abbrev domain TYPEINFO TypeInfo
TypeInfo() : Exports == Implementation where
  PF ==> PrintableForm
  N ==> SpadNode
  APP ==> SpadApply(N)
  FN ==> SpadFunction(N)

  Exports ==> CoercibleTo(PF) with
    typeInfo : (FN, List(APP)) -> %

    elt : (%, "ftor") -> FN
    elt : (%, "hasList") -> List(APP)

  Implementation ==> add
    import SpadNode

    Rep := Record(ti_ftor : FN, ti_hasList : List(APP))

    typeInfo(f, hl) == [f, hl]$Rep

    elt(x, "ftor") == x.ti_ftor
    elt(x, "hasList") == x.ti_hasList

    coerce x ==
      app := nodeApp([x.ftor.name], x.ftor.args)
      pile([spaces [app :: PF, bold("is" :: PF), x.ftor.result :: PF, bold("defined as:" :: PF)],
            x.ftor.body :: PF,
            spaces [bold("has relation:" :: PF), bracket [h :: PF for h in x.hasList]]])

)abbrev package FTTOOLS FunctorTools
FunctorTools() : Exports == Implementation where
  PF ==> PrintableForm
  N ==> SpadNode
  APP ==> SpadApply(N)
  FN ==> SpadFunction(N)
  MR ==> SpadMarker(N)
  TE ==> SpadTypeExpr(N)

  Exports ==> with
    applyFunctor : (FN, List(N)) -> FN

  Implementation ==> add
    import Logger('FunctorTools)
    import TypeUnifier

    applyFunctor(ftor : FN, args : List(N)) : FN ==
      #args ~= #ftor.args =>
        fail(["Wrong number of arguments passed to" :: PF, ftor.name :: PF,
              "functor : " :: PF, paren [arg :: PF for arg in args]])
        error ""
      empty? args => ftor

      -- TODO: For now we completely ignore actual types passed as arguments.
      debug([ftor.name :: PF, paren [arg :: PF for arg in ftor.args], "=>" :: PF,
             ftor.name :: PF, paren [arg :: PF for arg in args]])
      body := ftor.body
      for arg in ftor.args for term in args | typeExpr? arg repeat
        var := ((arg :: TE).expr) :: MR
        body := substitute(body, var, term)
      [ftor.name, args, ftor.type, body]$FN

)abbrev domain TYPEVAL TypeInfoCache
TypeInfoCache() : Exports == Implementation where
  PF ==> PrintableForm
  N ==> SpadNode
  APP ==> SpadApply(N)
  FN ==> SpadFunction(N)
  NT ==> SpadNamedType(N)
  ST ==> SpadSumType(N)
  TE ==> SpadTypeExpr(N)
  MR ==> SpadMarker(N)

  Exports ==> with
    new : () -> %
    elt : (%, APP) -> TypeInfo
    setelt! : (%, APP, TypeInfo) -> TypeInfo
    keys : % -> List(APP)

  Implementation ==> add
    import SpadDatabase
    import SpadNode
    import SpadNodeFactory
    import Logger('TypeInfoCache)
    import Printer
    import String
    import TypeInfo
    import TypeUnifier
    import FunctorTools

    Rep := AssociationList(APP, TypeInfo)

    builtinTypes : List(Symbol) :=
      (['Canonical, 'CommutativeStar, 'Type, 'canonicalUnitNormal,
        'canonicalsClosed, 'finiteAggregate, 'multiplicativeValuation,
        'noZeroDivisors, 'shallowlyMutable, 'unitsKnown])

    new () : % ==
      cache := empty()$Rep
      for t in builtinTypes repeat
        app := [[t], []]$APP
        fn := [t, [], nodeApp(['Category], []), emptyNode()]$FN
        cache(app) := typeInfo(fn, [])
      cache

    symbol(s1 : String, s2 : String) : Symbol ==
      concat(s1, s2)$String :: Symbol

    queryDaase (t : Symbol) : FN ==
      cmm := getCtorModeMap(t)

      ++ Some symbols will be rewritten to type variables.
      ctx := [[]]$AssociationList(Symbol, N)
      ++ "%" => "%0"
      ctx("%" :: Symbol) := typeVar(0)
      ++ "#1" => "%1", "#2" => "%2", ...
      for i in 1..#cmm.args repeat
        ctx(symbol("#", string i)) := typeVar(i)

      ++ Symbols in SpadNamedType cannot be rewritten to type variable, so just
      ++ change name.
      args := ([nodeTypeExpr(':, typeVar(i), arg.type)
                for arg in cmm.args for i in 1..])

      if cmm.type = nodeApp(['Category], []) then
        ++ "t#1" => "%1", "t#2" => "%2", ...
        for arg in cmm.args for i in 1.. repeat
          ctx(symbol("t", string arg.name)) := typeVar(i)
        body := getCtorCategory(t)
        ftorType := cmm.type
      else
        body := cmm.type
        ftorType := nodeApp(['Type], [])

      if apply? body then
        body := nodeSumType("Join", [body])

      ftor := [cmm.name, args, ftorType, body]$FN
      rewrite(ftor)$SpadTreeSymbolReplace(ctx) :: FN

    getTypeInfo(cache : %, app : APP) : TypeInfo ==
      debug ["getTypeInfo" :: PF, app :: PF]

      -- even if a functor is has some arguments unbound
      -- we still need to rewrite type variables recursively
      ftor := queryDaase(app.function :: Symbol)
      ftor := applyFunctor(ftor, app.args)

      st := ftor.body
      hasLst : List(APP) :=
        sumType? st =>
          sum := st :: ST
          hasLst := []
          for subtype in sum.types | apply? subtype repeat
            subapp := subtype :: APP
            sym := subapp.function :: Symbol
            member?(subapp, hasLst) => "iterate"
            if not member?(sym, builtinTypes) then
              ti' := cache(subapp)
              -- SCOPE BUG! change "t" to "app" and observe horrible things to happen
              for t in ti'.hasList | not member?(t, hasLst) repeat
                hasLst := [t, :hasLst]
            hasLst := [subapp, :hasLst]
          hasLst
        []
      
      if ftor.type = nodeApp(['Type], []) then
        self := typeVar(0) :: MR
        body := substitute(ftor.body, self, [app])
        ftor := [ftor.name, ftor.args, ftor.type, body]$FN
        hasLst := [substitute([t], self, [app]) :: APP for t in hasLst]

      cache(app) := typeInfo(ftor, hasLst)

    elt(cache : %, app : APP) : TypeInfo ==
      res := assoc(app, cache)$Rep
      res case "failed" => getTypeInfo(cache, app)
      res.entry

    setelt!(cache : %, app : APP, ti : TypeInfo) : TypeInfo ==
      unbound? [app] => ti
      setelt!(cache, app, ti)$Rep

    keys(cache : %) : List(APP) ==
      keys(cache)$Rep

)abbrev package STFTFLAT SpadFunctorFlatten
SpadFunctorFlatten(cache : TypeInfoCache) : Exports == Implementation where
  N ==> SpadNode
  APP ==> SpadApply(N)
  CE ==> SpadCondExpr(N)
  TE ==> SpadTypeExpr(N)
  ST ==> SpadSumType(N)
  FN ==> SpadFunction(N)
  MR ==> SpadMarker(N)
  PF ==> PrintableForm

  Exports ==> SpadTreeWalkerCategory with
    run : TypeInfo -> TypeInfo

  Implementation ==> add
    import Logger('Flatten)
    import TypeInfoCache
    import FunctorTools
    import SpadNode
    import SpadNodeFactory
    import TypeUnifier
    import TypeInfo

    done : Set(APP) := empty()
    type : N := emptyNode()
    typeHasList : List(APP) := []
    self : MR := coerce(typeVar(0))@MR

    run (ti : TypeInfo) : TypeInfo ==
      done := empty()
      type :=
        ti.ftor.type = nodeApp(['Type], []) =>
          nodeApp([ti.ftor.name], ti.ftor.args)
        emptyNode()
      typeHasList := ti.hasList
      typeInfo(rewrite(ti.ftor) :: FN, ti.hasList)

    rewrite (cn : CE) : N ==
      ce := [rewrite cn.cond, rewrite cn.truebr, rewrite cn.falsebr]$CE
      ce.cond = ['true] => ce.truebr
      ce.cond = ['false] => ce.falsebr
      [ce]

    rewrite (te : TE) : N ==
      type' := rewrite te.type
      expr' := rewrite te.expr

      te.kind = 'has =>
        hasLst : List(APP) :=
          apply? expr' =>
            ti := cache(expr' :: APP)
            ti.hasList
          expr' = typeVar(0) =>
            typeHasList
          symbol? expr' =>
            ti := cache(nodeApp(expr', []) :: APP)
            ti.hasList
          fail pile ["Don't know how to rewrite:" :: PF, expr' :: PF]
          error ""
        if member?(type' :: APP, hasLst) or type' = expr' then
          return ['true]
        else
          return ['false]

      nodeTypeExpr(te.kind, expr', type')

    rewrite (st : ST) : N ==
      subtypes : List(N) := []

      for subtype in st.types repeat
        subtype := rewrite subtype
        if apply? subtype then
          subapp := coerce(subtype)@APP
          if subapp.function = ['ATTRIBUTE] then
            subtype := first subapp.args
            subapp := coerce(subtype)@APP
          member?(subapp, done) => 
            subtype := emptyNode()
          insert!(subapp, done)
          if not emptyNode? type then
            -- Only for types: substitute "%"
            subtype := substitute(subtype, self, type)
            subapp := coerce(subtype)@APP
          ti := cache(subapp)
          ftor :=
            not emptyNode? type =>
              substitute([ti.ftor], self, type) :: FN
            ti.ftor
          if any?(unbound?, ftor.args) then
            ftor := applyFunctor(ftor, subapp.args)
          subtype := rewrite ftor.body
        emptyNode? subtype => "iterate"
        sumType? subtype =>
          st' := coerce(subtype)@ST
          subtypes:= concat(st'.types, subtypes)
        subtypes := [subtype, :subtypes]

      -- Q: Are signature duplicates allowed?
      nodeSumType("Body", reverse subtypes)

)abbrev package TYPEVALT TypeEvaluatorTest
TypeEvaluatorTest() : Exports == Implementation where
  PF ==> PrintableForm
  N ==> SpadNode
  APP ==> SpadApply(N)
  NT ==> SpadNamedType(N)
  MR ==> SpadMarker(N)
  FN ==> SpadFunction(N)

  Exports ==> with
    test1 : () -> Void

  Implementation ==> add
    import Printer
    import SpadNode
    import SpadNodeFactory
    import TypeInfoCache
    import TypeUnifier
    import MainLogger
    import Logger('Test)
    import SpadTreeSymbolSubstitute

    test1 ==
      loggerDefaultLevel "debug"
      loggerLevel('Parser, "notice")
      resetTime()

      cache : TypeInfoCache := new()
      --type := nodeApp(['Integer], [])
      --type := nodeApp(['IntegerNumberSystem], [])
      type := nodeApp(['Set], [['Integer]])
      --type := nodeApp(['Boolean], [])
      --type := nodeApp(['OrderedRing], [])
      ti := cache(type :: APP)
      debug (ti :: PF)
      debug pile ["Types in cache:" :: PF, :[k :: PF for k in keys cache]]

      ti := run(ti)$SpadFunctorFlatten(cache)
      debug (ti :: PF)
      debug pile ["Types in cache:" :: PF, :[k :: PF for k in keys cache]]
