)abbrev package STSYMRPL SpadTreeSymbolReplace
SpadTreeSymbolReplace(ctx : CTX) : WALKER == Implementation where
  N ==> SpadNode
  CTX ==> AssociationList(Symbol, N)
  WALKER ==> SpadTreeWalkerCategory 

  Implementation ==> add
    rewrite (s : Symbol) : N ==
      r := assoc(s, ctx)
      r case "failed" => [s]
      r.entry

)abbrev package STTVRPL SpadTreeTypeVarReplace
SpadTreeTypeVarReplace(ctx : CTX) : WALKER == Implementation where
  N ==> SpadNode
  MR ==> SpadMarker(N)
  CTX ==> AssociationList(MR, N)
  WALKER ==> SpadTreeWalkerCategory 

  Implementation ==> add
    rewrite (mr : MR) : N ==
      r := assoc(mr, ctx)
      r case "failed" => [mr]
      r.entry

)abbrev package STFTEVAL SpadFunctorEvaluate
SpadFunctorEvaluate(ctx : CTX) : WALKER == Implementation where
  N ==> SpadNode
  APP ==> SpadApply(N)
  CE ==> SpadCondExpr(N)
  TE ==> SpadTypeExpr(N)
  ST ==> SpadSumType(N)
  MR ==> SpadMarker(N)
  CTX ==> AssociationList(MR, List(N))
  WALKER ==> SpadTreeWalkerCategory 

  Implementation ==> add
    rewrite (app : APP) : N ==
      app := [rewrite app.function, [rewrite arg for arg in app.args]]$APP
      app.function = ['OR] and #app.args = 2 =>
        "or"/[arg = ['true] for arg in app.args] => ['true]
        "and"/[arg = ['false] for arg in app.args] => ['false]
        app.args.1 = ['false] => app.args.2
        app.args.2 = ['false] => app.args.1
        [app]
      app.function = ['AND] and #app.args = 2 =>
        "and"/[arg = ['true] for arg in app.args] => ['true]
        "or"/[arg = ['false] for arg in app.args] => ['false]
        app.args.1 = ['true] => app.args.2
        app.args.2 = ['true] => app.args.1
        [app]
      [app]

    rewrite (cn : CE) : N ==
      ce := [rewrite cn.cond, rewrite cn.truebr, rewrite cn.falsebr]$CE
      ce.cond = ['true] => ce.truebr
      ce.cond = ['false] => ce.falsebr
      [ce]

    rewrite (te : TE) : N ==
      if typeVar? te.expr and te.kind = 'has then
        res := assoc(te.expr :: MR, ctx)
        if not (res case "failed") then
          if member?(te.type, res.entry) then
            return ['true]
          else
            return ['false]
      nodeTypeExpr(te.kind, rewrite te.expr, rewrite te.type)

    rewrite (st : ST) : N ==
      ts := [rewrite t for t in st.types]
      nodeSumType(st.kind, [t for t in ts | not emptyNode? t])

)abbrev domain TYPEINFO TypeInfo
TypeInfo() : Exports == Implementation where
  PF ==> PrintableForm
  N ==> SpadNode
  APP ==> SpadApply(N)
  FN ==> SpadFunction(N)

  Exports ==> CoercibleTo(PF) with
    typeInfo : (FN, List(APP)) -> %

    elt : (%, "ftor") -> FN
    elt : (%, "hasList") -> List(APP)

  Implementation ==> add
    import SpadNode

    Rep := Record(ti_ftor : FN, ti_hasList : List(APP))

    typeInfo(f, hl) == [f, hl]$Rep

    elt(x, "ftor") == x.ti_ftor
    elt(x, "hasList") == x.ti_hasList

    coerce x ==
      app := nodeApp([x.ftor.name], x.ftor.args)
      pile([spaces [app :: PF, bold("is" :: PF), x.ftor.result :: PF, bold("defined as:" :: PF)],
            x.ftor.body :: PF,
            spaces [bold("has relation:" :: PF), bracket [h :: PF for h in x.hasList]]])

)abbrev domain TYPEVAL TypeInfoCache
TypeInfoCache() : Exports == Implementation where
  PF ==> PrintableForm
  N ==> SpadNode
  APP ==> SpadApply(N)
  FN ==> SpadFunction(N)
  NT ==> SpadNamedType(N)
  ST ==> SpadSumType(N)
  TE ==> SpadTypeExpr(N)
  MR ==> SpadMarker(N)

  Exports ==> with
    new : () -> %
    elt : (%, APP) -> TypeInfo
    keys : % -> List(APP)

  Implementation ==> add
    import SpadDatabase
    import SpadNode
    import SpadNodeFactory
    import Logger('Type)
    import Printer
    import String
    import TypeInfo

    Rep := AssociationList(APP, TypeInfo)

    builtinTypes : List(Symbol) :=
      (['Canonical, 'CommutativeStar, 'Type, 'canonicalUnitNormal,
        'canonicalsClosed, 'finiteAggregate, 'multiplicativeValuation,
        'noZeroDivisors, 'shallowlyMutable, 'unitsKnown])

    new () : % ==
      cache := empty()$Rep
      for t in builtinTypes repeat
        app := [[t], []]$APP
        fn := [t, [], nodeApp(['Category], []), emptyNode()]$FN
        cache(app) := typeInfo(fn, [])
      cache

    symbol(s1 : String, s2 : String) : Symbol ==
      concat(s1, s2)$String :: Symbol

    getFunctor (t : Symbol) : FN ==
      cmm := getCtorModeMap(t)

      ++ Some symbols will be rewritten to type variables.
      ctx := [[]]$AssociationList(Symbol, N)
      ++ "%" => "%0"
      ctx("%" :: Symbol) := typeVar(0)
      ++ "#1" => "%1", "#2" => "%2", ...
      for i in 1..#cmm.args repeat
        ctx(symbol("#", string i)) := typeVar(i)

      ++ Symbols in SpadNamedType cannot be rewritten to type variable, so just
      ++ change name.
      args := ([nodeTypeExpr(':, typeVar(i), arg.type)
                for arg in cmm.args for i in 1..])

      if cmm.type = nodeApp(['Category], []) then
        ++ "t#1" => "%1", "t#2" => "%2", ...
        for arg in cmm.args for i in 1.. repeat
          ctx(symbol("t", string arg.name)) := typeVar(i)
        body := getCtorCategory(t)
        ftorType := cmm.type
      else
        body := cmm.type
        ftorType := nodeApp(['Type], [])

      ftor := [cmm.name, args, ftorType, body]$FN
      rewrite(ftor)$SpadTreeSymbolReplace(ctx) :: FN

    getAppliedFunctor(app : APP) : FN ==
      sym := app.function :: Symbol
      ftor := getFunctor(sym)
      -- Substitute functor arguments, types are ignored. 
      ctx := [[]]$AssociationList(MR, N)
      for arg in ftor.args for term in app.args repeat
        var := ((arg :: TE).expr) :: MR
        debug [sym :: PF, ":" :: PF, var :: PF, "=>" :: PF, term :: PF]
        ctx(var) := term
      ftor := [ftor.name, app.args, ftor.type, ftor.body]$FN
      rewrite(ftor)$SpadTreeTypeVarReplace(ctx) :: FN

    getTypeInfo(cache : %, ftorApp : APP) : TypeInfo ==
      ftor := getAppliedFunctor(ftorApp)
      type := ftor.body

      sumType? type =>
        sum := type :: ST
        hasLst : List(APP) := []
        for t in sum.types | apply? t repeat
          subFtorApp := t :: APP
          sym := subFtorApp.function :: Symbol
          member?(subFtorApp, hasLst) => "iterate"
          if not member?(sym, builtinTypes) then
            ti := cache(subFtorApp)
            for app in ti.hasList | not member?(app, hasLst) repeat
              hasLst := [app, :hasLst]
          hasLst := [subFtorApp, :hasLst]
        cache(ftorApp) := typeInfo(ftor, hasLst)

      cache(ftorApp) := typeInfo(ftor, [])

    elt(cache : %, ftorApp : APP) : TypeInfo ==
      res := assoc(ftorApp, cache)
      res case "failed" => getTypeInfo(cache, ftorApp)
      res.entry

    keys(cache : %) : List(APP) ==
      keys(cache)$Rep

)abbrev package TYPEVALT TypeEvaluatorTest
TypeEvaluatorTest() : Exports == Implementation where
  PF ==> PrintableForm
  N ==> SpadNode
  APP ==> SpadApply(N)
  NT ==> SpadNamedType(N)
  MR ==> SpadMarker(N)
  FN ==> SpadFunction(N)
  CTX ==> AssociationList(MR, List(N))

  Exports ==> with
    test1 : () -> Void

  Implementation ==> add
    import Printer
    import SpadNode
    import SpadNodeFactory
    import TypeInfoCache
    import TypeUnifier
    import MainLogger
    import Logger('Test)
    import SpadTreeSymbolSubstitute

    test1 ==
      loggerDefaultLevel "debug"
      loggerLevel('Parser, "notice")
      resetTime()

      cache : TypeInfoCache := new()
      tBoolean := cache([['Boolean], []]$APP)
      debug (tBoolean :: PF)

      debug pile ["Types in cache:" :: PF, :[k :: PF for k in keys cache]]
