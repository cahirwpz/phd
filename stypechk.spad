)boot $LINELENGTH := 360
)compile ParserTools.spad
)compile SpadNodeCategory.spad
)compile SpadNode.spad

)abbrev domain SPCMM SpadCtorModeMap
SpadCtorModeMap() : SetCategory with
    elt : (%, "name") -> Symbol
    elt : (%, "sig") -> List Symbol
    elt : (%, "type") -> SExpression
    elt : (%, "args") -> List SExpression
    construct : SExpression -> %
  == add
    import OutputForm
    import SExpression
    import SpadNode

    rep(x) ==> (x pretend SExpression)

    elt (x, "name") == (car car car rep(x)) pretend Symbol
    elt (x, "sig") == (cdr car car rep(x)) pretend List Symbol
    elt (x, "type") == (car cdr car rep(x)) 
    elt (x, "args") == (cdr cdr car rep(x)) pretend List SExpression

    construct x == x pretend %

    coerce x ==
      fsig := [hconcat [s :: OutputForm, " : ", (parse a) :: OutputForm] for s in x.sig for a in x.args]
      hconcat([x.name :: OutputForm, paren fsig, " : ",
               (parse x.type) :: OutputForm])

)abbrev domain SPCC SpadCtorCategory
SpadCtorCategory() : SetCategory with
    asNode : % -> SpadNode
  == add
    rep(x) ==> (x pretend SExpression)

    asNode x ==
      parse rep(x)

    coerce x ==
      (asNode x) :: OutputForm

)abbrev domain SPOP SpadOperation
SpadOperation() : SetCategory == add
    rep(x) ==> (x pretend SExpression)
    N ==> SpadNode

    import SpadNode
    import OutputForm
    import SExpression

    coerce x ==
      sex : SExpression := rep(x)
      --print (sex :: OutputForm)
      opname := symbol sex.1
      sig := destruct sex.2
      tl := [parse t for t in destruct sig.1]
      if #sig >= 4 then
        tl := concat(tl, [parse (convert 'constant)])
      mt : SpadMappingType(N) :=
        if #tl = 1 then
          [[], tl.1]
        else
          [rest tl, first tl]
      type := [opname, [mt]]$SpadNamedType(N)
      op :=
        if #sig >= 3 and not (symbol? sig.3 and symbol sig.3 = 'T)
          then
            pile([type :: OutputForm,
                  hconcat [hspace 2, "when"],
                  hconcat [hspace 4, (parse sig.3)$SpadNode :: OutputForm]])
          else
            type :: OutputForm
      op

)abbrev domain SPDB SpadDatabase
SpadDatabase() : with
    getOperationList : Symbol -> List SpadOperation
    getCtorArgs : Symbol -> List Symbol
      ++ returns constructor argument names
    getCtorArgsKind : Symbol -> List Boolean
      ++ returns constructor argument kind: true when a type, false when a value
    getCtorCategory : Symbol -> SpadCtorCategory
    getCtorKind : Symbol -> Union("domain", "category", "package")
      ++ returns constructor kind
    getCtorModeMap : Symbol -> SpadCtorModeMap
    getAbbrev : Symbol -> Symbol
    getSourceFile : Symbol -> String
  == add
    import SExpression

    getOperationList t ==
      -- Integer
      sex : SExpression := GETDATABASE(t, 'OPERATIONALIST)$Lisp
      null? sex => error "Unknown constructor!"
      sex pretend List SpadOperation

    getCtorArgsKind t ==
      sex : SExpression := GETDATABASE(t,'COSIG)$Lisp
      null? sex => error "Unknown constructor!"
      (cdr sex) pretend List Boolean

    getCtorCategory t ==
      sex : SExpression := GETDATABASE(t, 'CONSTRUCTORCATEGORY)$Lisp
      null? sex => error "Unknown constructor!"
      sex pretend SpadCtorCategory

    getCtorModeMap t ==
      sex : SExpression := GETDATABASE(t, 'CONSTRUCTORMODEMAP)$Lisp
      null? sex => error "Unknown constructor!"
      sex pretend SpadCtorModeMap

    getCtorArgs t ==
      sex : SExpression := GETDATABASE(t, 'CONSTRUCTORARGS)$Lisp
      sex pretend List Symbol

    getCtorKind t ==
      sex : SExpression := GETDATABASE(t, 'CONSTRUCTORKIND)$Lisp
      null? sex => error "Unknown constructor!"
      kind := symbol sex
      kind = 'domain => "domain"
      kind = 'category => "category"
      kind = 'package => "package"
      error "Unknown constructor kind!"

    getAbbrev t ==
      sex : SExpression := GETDATABASE(t, 'ABBREVIATION)$Lisp
      null? sex => error "Unknown constructor!"
      sex pretend Symbol

    getSourceFile t ==
      sex : SExpression := GETDATABASE(t, 'SOURCEFILE)$Lisp
      null? sex => error "Unknown constructor!"
      sex pretend String

)abbrev category STWALKC SpadTreeWalkerCategory
SpadTreeWalkerCategory() : Category == Definition where
  N ==> SpadNode
  APP ==> SpadApply(N)
  ASS ==> SpadAssign(N)
  CN ==> SpadConditional(N)
  FN ==> SpadFunction(N)
  FT ==> SpadFunctor(N)
  IM ==> SpadImport(N)
  LAM ==> SpadLambda(N)
  LP ==> SpadLoop(N)
  M ==> SpadMacro(N)
  MT ==> SpadMappingType(N)
  NT ==> SpadNamedType(N)
  RT ==> SpadRecordType(N)
  SEG ==> SpadSegment(N)
  SEQ ==> SpadSequence(N)
  ST ==> SpadSumType(N)
  TE ==> SpadTypeExpr(N)
  UT ==> SpadUnionType(N)

  Definition ==> with
      gensym : () -> Symbol

      rewrite : APP -> N
      rewrite : ASS -> N
      rewrite : CN -> N
      rewrite : FN -> N
      rewrite : FT -> N
      rewrite : IM -> N
      rewrite : LAM -> N
      rewrite : LP -> N
      rewrite : M -> N
      rewrite : MT -> N
      rewrite : NT -> N
      rewrite : RT -> N
      rewrite : SEG -> N
      rewrite : SEQ -> N
      rewrite : String -> N
      rewrite : ST -> N
      rewrite : Symbol -> N
      rewrite : TE -> N
      rewrite : UT -> N
      rewrite : N -> N 
    add
      gensym() ==
        GENSYM()$Lisp

      rewrite (a : APP) : N ==
        [[rewrite a.function, [rewrite arg for arg in a.args]] $ APP]

      rewrite (a : ASS) : N ==
        [[rewrite a.lvalue, rewrite a.rvalue] $ ASS]

      rewrite (cn : CN) : N ==
        f : Union(N, "empty")
        c := rewrite cn.cond
        t := rewrite cn.truebr
        f := (cn.falsebr case N => rewrite (cn.falsebr :: N); "empty")
        [[c, t, f] $ CN]

      rewrite (fn : FN) : N ==
        argl : List Union(String, NT) := []
        for arg in fn.args repeat
          argl := if arg case NT
            then [[arg.name, rewrite arg.type], :argl]
            else [arg, :argl]
        [[fn.name, reverse argl, rewrite fn.type, rewrite fn.body] $ FN]

      rewrite (ft : FT) : N ==
        [[ft.name, ft.args, rewrite ft.type, rewrite ft.extends, rewrite ft.capsule] $ FT]

      rewrite (im : IM) : N ==
        [[rewrite im.type] $ IM]

      rewrite (l : LAM) : N ==
        [[l.args, rewrite l.type, rewrite l.body] $ LAM]

      rewrite (lp : LP) : N ==
        -- BUG: parser cannot accept a multi-line list constructor
        nitors : List SpadIterator(N) :=
          [[itor.var, rewrite itor.seq] for itor in lp.itors]
        nguards := [rewrite guard for guard in lp.guards]
        [[lp.kind, nitors, nguards, rewrite lp.body] $ LP]

      rewrite (m : M) : N == [m]

      rewrite (mt : MT) : N ==
        [[[rewrite arg for arg in mt.args], rewrite mt.type] $ MT]

      rewrite (nt : NT) : N ==
        [[nt.name, rewrite nt.type] $ NT]

      rewrite (rt : RT) : N ==
        [[[[f.name, rewrite f.type] for f in rt.fields]] $ RT]

      rewrite (seg : SEG) : N ==
        b := rewrite seg.start
        s := rewrite seg.step
        nseg : SEG :=
          seg.end case "infinity" => [b, s]
          [b, rewrite (seg.end :: N), s]
        [nseg]

      rewrite (s : SEQ) : N ==
        [[s.kind, [rewrite e for e in s.list]] $ SEQ]

      rewrite (s : String) : N == [s]

      rewrite (st : ST) : N ==
        [[st.kind, [rewrite t for t in st.types]] $ ST]

      rewrite (s : Symbol) : N == [s]

      rewrite (te : TE) : N ==
        [[te.kind, rewrite te.expr, rewrite te.type] $ TE]

      rewrite (ut : UT) : N ==
        varl : List Union(N, NT) := []
        for var in ut.variants repeat
          var case N =>
            varl := [rewrite var, :varl]
          var case NT =>
            varl := [[var.name, rewrite var.type], :varl]
        [[reverse varl] $ UT]

      rewrite (n : N) : N ==
        apply? n => rewrite (n :: APP)
        assign? n => rewrite (n :: ASS)
        conditional? n => rewrite (n :: CN)
        function? n => rewrite (n :: FN)
        functor? n => rewrite (n :: FT)
        import? n => rewrite (n :: IM)
        lambda? n => rewrite (n :: LAM)
        loop? n => rewrite (n :: LP)
        macro? n => rewrite (n :: M)
        mappingType? n => rewrite (n :: MT)
        namedType? n => rewrite (n :: NT)
        recordType? n => rewrite (n :: RT)
        segment? n => rewrite (n :: SEG)
        sequence? n => rewrite (n :: SEQ)
        string? n => rewrite (n :: String)
        sumType? n => rewrite (n :: ST)
        symbol? n => rewrite (n :: Symbol)
        typeExpr? n => rewrite (n :: TE)
        unionType? n => rewrite (n :: UT)
        -- skip integer, float and empty node
        integer? n or float? n or emptyNode? n => n
        error "rewrite: variant not handled"

)abbrev package STMEXP SpadTreeMacroExpander
SpadTreeMacroExpander() : Exports == Implementation where
  N ==> SpadNode
  M ==> SpadMacro(N)
  AL ==> AssociationList(Symbol, M)

  Exports ==> SpadTreeWalkerCategory with 
    init : () -> Void

  Implementation ==> add
    env : Stack AL := stack [table()]

    newCtx : () -> Void
    newCtx () == push!(table(), env)

    discardCtx : () -> Void
    discardCtx () == pop! env

    addMacro : M -> Void
    addMacro m ==
      ctx := top env
      ctx(m.name) := m

    findMacro : Symbol -> Union(M, "failed")
    findMacro name ==
      for ctx in parts env repeat
        if key?(name, ctx) then
          return ctx(name)
      "failed"

    init () ==
      env := stack [table()]

    rewrite (seq : SpadSequence(N)) : N ==
      newCtx()
      seq' := [[seq.kind, [rewrite ex for ex in seq.list]] $ SpadSequence(N)]
      --print (env :: OutputForm)
      discardCtx()
      seq'

    rewrite (app : SpadApply(N)) : N ==
      if symbol? app.function then
        m := findMacro (app.function :: Symbol)
        if m case M then
          #app.args ~= #m.args =>
            error(["Wrong number of arguments (", #app.args, ") ",
                   "passed to macro", m.name, "/", #m.args])
          newCtx ()
          for m_arg in m.args for arg in app.args repeat
            addMacro ([m_arg, [], arg] $ SpadMacro(N))
          app' := rewrite m.body
          discardCtx()
          return app'
      [[rewrite app.function, [rewrite arg for arg in app.args]] $ SpadApply(N)]

    rewrite (m : SpadMacro(N)) : N ==
      addMacro m
      emptyNode()

    rewrite (sym : Symbol) : N ==
      m := findMacro sym
      m case "failed" => [sym]
      #m.args ~= 0 =>
        error ["Attempted to apply arguments to parameterless macro ", m.name]
      rewrite m.body

)abbrev domain STRP1 SpadTreeRewritePhase1
SpadTreeRewritePhase1() : SpadTreeWalkerCategory == Implementation where
  N ==> SpadNode
  APP ==> SpadApply(N)
  ASS ==> SpadAssign(N)
  SEQ ==> SpadSequence(N)

  Implementation ==> add
    -- compiler goes wild if we change the order of these functions...
    rewrite (app : APP) : N ==
      nexps : List(N) := []
      nargs : List(N) := []
      for arg in app.args repeat
        narg := arg
        if not value? arg then
          narg := [gensym()]
          nexps := [rewrite [[narg, arg] $ ASS], :nexps]
        nargs := [rewrite narg, :nargs]
      reverse! nexps
      reverse! nargs
      app' := [[rewrite app.function, nargs] $ APP]
      empty? nexps => app'
      [["prog", [:nexps, app']] $ SEQ]

    rewrite (seq : SEQ) : N == 
      nodes : List(N) := [rewrite e for e in seq.list] 
      if seq.kind = "prog" then
        nodes' : List(N) := []
        for node in nodes repeat
          if sequence? node then
            nseq := node :: SEQ
            nseq.kind = "prog" =>
              nodes' := concat(reverse nseq.list, nodes')
          nodes' := [node, :nodes']
        nodes := reverse nodes'
      [[seq.kind, nodes] $ SEQ]

)abbrev package SPTYPCHK SpadTypeChecker
++ Author: Krystian Baclawski
++ Date Created: December 2013
++ Date Last Updated: January 2014
++ Description:
++ Experimental type checker with bottom-up approach.
SpadTypeChecker() : with
    check : SExpression -> Void 
      ++ check(sex) runs type checker for parse tree
  == add
    import OutputForm
    import SpadNode
    import SpadTreeMacroExpander

    check e ==
      init()
      -- print (e :: OutputForm)
      n : SpadNode := parse e
      print (n :: OutputForm)
      n := (rewrite n) $ SpadTreeMacroExpander
      print (n :: OutputForm)
