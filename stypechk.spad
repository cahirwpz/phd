)boot $LINELENGTH := 180
)compile ParserTools.spad
)compile SpadNodeCategory.spad
)compile SpadNode.spad

)abbrev domain SPCMM SpadCtorModeMap
SpadCtorModeMap() : SetCategory with
    elt : (%, "name") -> Symbol
    elt : (%, "sig") -> List Symbol
    elt : (%, "type") -> SExpression
    elt : (%, "args") -> List SExpression
    construct : SExpression -> %
  == add
    import OutputForm
    import SExpression
    import SpadNode

    rep(x) ==> (x pretend SExpression)

    elt (x, "name") == (car car car rep(x)) pretend Symbol
    elt (x, "sig") == (cdr car car rep(x)) pretend List Symbol
    elt (x, "type") == (car cdr car rep(x)) 
    elt (x, "args") == (cdr cdr car rep(x)) pretend List SExpression

    construct x == x pretend %

    coerce x ==
      fsig := [hconcat [s :: OutputForm, " : ", (parse a) :: OutputForm] for s in x.sig for a in x.args]
      hconcat([x.name :: OutputForm, paren fsig, " : ",
               (parse x.type) :: OutputForm])

)abbrev domain SPCC SpadCtorCategory
SpadCtorCategory() : SetCategory with
    asNode : % -> SpadNode
  == add
    rep(x) ==> (x pretend SExpression)

    asNode x ==
      parse rep(x)

    coerce x ==
      (asNode x) :: OutputForm

)abbrev domain SPOP SpadOperation
SpadOperation() : SetCategory == add
    rep(x) ==> (x pretend SExpression)
    N ==> SpadNode

    import SpadNode
    import OutputForm
    import SExpression

    coerce x ==
      sex : SExpression := rep(x)
      --print (sex :: OutputForm)
      opname := symbol sex.1
      sig := destruct sex.2
      tl := [parse t for t in destruct sig.1]
      if #sig >= 4 then
        tl := concat(tl, [parse (convert 'constant)])
      mt : SpadMappingType(N) :=
        if #tl = 1 then
          [[], tl.1]
        else
          [rest tl, first tl]
      type := [opname, [mt]]$SpadNamedType(N)
      op :=
        if #sig >= 3 and not (symbol? sig.3 and symbol sig.3 = 'T)
          then
            pile([type :: OutputForm,
                  hconcat [hspace 2, "when"],
                  hconcat [hspace 4, (parse sig.3)$SpadNode :: OutputForm]])
          else
            type :: OutputForm
      op

)abbrev domain SPDB SpadDatabase
SpadDatabase() : with
    getOperationList : Symbol -> List SpadOperation
    getCtorArgs : Symbol -> List Symbol
      ++ returns constructor argument names
    getCtorArgsKind : Symbol -> List Boolean
      ++ returns constructor argument kind: true when a type, false when a value
    getCtorCategory : Symbol -> SpadCtorCategory
    getCtorKind : Symbol -> Union("domain", "category", "package")
      ++ returns constructor kind
    getCtorModeMap : Symbol -> SpadCtorModeMap
    getAbbrev : Symbol -> Symbol
    getSourceFile : Symbol -> String
  == add
    import SExpression

    getOperationList t ==
      -- Integer
      sex : SExpression := GETDATABASE(t, 'OPERATIONALIST)$Lisp
      null? sex => error "Unknown constructor!"
      sex pretend List SpadOperation

    getCtorArgsKind t ==
      sex : SExpression := GETDATABASE(t,'COSIG)$Lisp
      null? sex => error "Unknown constructor!"
      (cdr sex) pretend List Boolean

    getCtorCategory t ==
      sex : SExpression := GETDATABASE(t, 'CONSTRUCTORCATEGORY)$Lisp
      null? sex => error "Unknown constructor!"
      sex pretend SpadCtorCategory

    getCtorModeMap t ==
      sex : SExpression := GETDATABASE(t, 'CONSTRUCTORMODEMAP)$Lisp
      null? sex => error "Unknown constructor!"
      sex pretend SpadCtorModeMap

    getCtorArgs t ==
      sex : SExpression := GETDATABASE(t, 'CONSTRUCTORARGS)$Lisp
      sex pretend List Symbol

    getCtorKind t ==
      sex : SExpression := GETDATABASE(t, 'CONSTRUCTORKIND)$Lisp
      null? sex => error "Unknown constructor!"
      kind := symbol sex
      kind = 'domain => "domain"
      kind = 'category => "category"
      kind = 'package => "package"
      error "Unknown constructor kind!"

    getAbbrev t ==
      sex : SExpression := GETDATABASE(t, 'ABBREVIATION)$Lisp
      null? sex => error "Unknown constructor!"
      sex pretend Symbol

    getSourceFile t ==
      sex : SExpression := GETDATABASE(t, 'SOURCEFILE)$Lisp
      null? sex => error "Unknown constructor!"
      sex pretend String

)abbrev package STMEXP SpadTreeMacroExpander
SpadTreeMacroExpander() : Exports == Implementation where
  N ==> SpadNode
  F ==> SpadFunctor
  M ==> SpadMacro(N)
  AL ==> AssociationList(Symbol, M)

  Exports ==> Type with 
    init : () -> Void
    rewrite : N -> N 

  Implementation ==> add
    import OutputForm

    env : Stack AL := stack [table()]

    newCtx : () -> Void
    newCtx () == push!(table(), env)

    discardCtx : () -> Void
    discardCtx () == pop! env

    addMacro : M -> Void
    addMacro m ==
      ctx := top env
      ctx(m.name) := m

    findMacro : Symbol -> Union(M, "failed")
    findMacro name ==
      for ctx in parts env repeat
        if key?(name, ctx) then
          return ctx(name)
      "failed"

    init () ==
      env := stack [table()]

    rewrite (n : N) : N ==
      ftor := functorOf n
      ftor case SpadFunctor(N) =>
        [[ftor.name, ftor.args, rewrite ftor.type, rewrite ftor.extends, rewrite ftor.capsule] $ SpadFunctor(N)]

      sum := sumTypeOf n
      sum case SpadSumType(N) =>
        [[sum.kind, [rewrite typ for typ in sum.types]] $ SpadSumType(N)]

      record := recordTypeOf n
      record case SpadRecordType(N) =>
        [[[[field.name, rewrite field.type] for field in record.fields]] $ SpadRecordType(N)]
        
      union := unionTypeOf n
      union case SpadUnionType(N) =>
        varl : List Union(N, SpadNamedType(N)) := []
        for var in union.variants repeat
          var case N =>
            varl := [rewrite var, :varl]
          var case SpadNamedType(N) =>
            varl := [[var.name, rewrite var.type], :varl]
        [[reverse varl] $ SpadUnionType(N)]
      
      fun := mappingTypeOf n
      fun case SpadMappingType(N) =>
        [[[rewrite arg for arg in fun.args], rewrite fun.type] $ SpadMappingType(N)]

      named := namedTypeOf n
      named case SpadNamedType(N) =>
        [[named.name, rewrite named.type] $ SpadNamedType(N)]

      seq := sequenceOf n
      seq case SpadSequence(N) =>
        newCtx()
        seq' := [[seq.kind, [rewrite ex for ex in seq.list]] $ SpadSequence(N)]
        --print (env :: OutputForm)
        discardCtx()
        seq'

      lambda := lambdaOf n
      lambda case SpadLambda(N) =>
        [[lambda.args, rewrite lambda.type, rewrite lambda.body] $ SpadLambda(N)]

      apply := applyOf n
      apply case SpadApply(N) =>
        funsym := symbolOf apply.function
        if funsym case Symbol then
          m := findMacro (funsym :: Symbol)
          if m case M then
            #apply.args ~= #m.args =>
              error(["Wrong number of arguments (", #apply.args, ") ",
                     "passed to macro", m.name, "/", #m.args])
            newCtx ()
            for m_arg in m.args for arg in apply.args repeat
              addMacro ([m_arg, [], arg] $ SpadMacro(N))
            apply' := rewrite m.body
            discardCtx()
            return apply'
        [[rewrite apply.function, [rewrite arg for arg in apply.args]] $ SpadApply(N)]

      assign := assignOf n
      assign case SpadAssign(N) =>
        [[rewrite assign.lvalue, rewrite assign.rvalue] $ SpadAssign(N)]

      loop := loopOf n
      loop case SpadLoop(N) =>
        -- BUG: parser ma problemy z listami rozrzuconymi po liniach
        nitors : List SpadIterator(N) :=
          [[itor.var, rewrite itor.seq] for itor in loop.itors]
        nguards := [rewrite guard for guard in loop.guards]
        [[loop.kind, nitors, nguards, rewrite loop.body] $ SpadLoop(N)]

      scond := conditionalOf n
      scond case SpadConditional(N) =>
        c := rewrite scond.cond
        t := rewrite scond.truebr
        f : Union(N, "empty") := (scond.falsebr case N => rewrite (scond.falsebr :: N); "empty")
        [[c, t, f] $ SpadConditional(N)]

      func := functionOf n
      func case SpadFunction(N) =>
        argl : List Union(String, SpadNamedType(N)) := []
        for arg in func.args repeat
          argl := if arg case SpadNamedType(N)
            then [[arg.name, rewrite arg.type], :argl]
            else [arg, :argl]
        [[func.name, reverse argl, rewrite func.type, rewrite func.body] $ SpadFunction(N)]

      smacro := macroOf n
      smacro case SpadMacro(N) =>
        addMacro smacro
        emptyNode()

      simport := importOf n
      simport case SpadImport(N) =>
        [[rewrite simport.type] $ SpadImport(N)]

      typexpr := typeExprOf n
      typexpr case SpadTypeExpr(N) =>
        [[typexpr.kind, rewrite typexpr.expr, rewrite typexpr.type] $ SpadTypeExpr(N)]

      segment := segmentOf n
      segment case SpadSegment(N) =>
        b := rewrite segment.start
        s := rewrite segment.step
        seg : SpadSegment(N) :=
          segment.end case "infinity" => [b, s]
          [b, rewrite (segment.end :: N), s]
        [seg]

      sym := symbolOf n
      sym case Symbol =>
        m := findMacro (sym :: Symbol)
        m case "failed" => n
        #m.args ~= 0 =>
          error ["Attempted to apply arguments to parameterless macro ", m.name]
        rewrite m.body

      -- no need to rewrite float, integer and string values
      -- just return unchanged
      n

)abbrev package SPTYPCHK SpadTypeChecker
++ Author: Krystian Baclawski
++ Date Created: December 2013
++ Date Last Updated: January 2014
++ Description:
++ Experimental type checker with bottom-up approach.
SpadTypeChecker() : with
    check : SExpression -> Void 
      ++ check(sex) runs type checker for parse tree
  == add
    import OutputForm
    import SpadNode
    import SpadTreeMacroExpander

    check e ==
      init()
      -- print (e :: OutputForm)
      n : SpadNode := parse e
      print (n :: OutputForm)
      n := rewrite n 
      print (n :: OutputForm)
