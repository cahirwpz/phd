)boot $LINELENGTH := 180

)abbrev package SEXHELP SExpressionHelper
++ Helper functions for s-expression handling
SExpressionHelper() : with
    capsule? : SExpression -> Boolean
    case? : SExpression -> Boolean
    category? : SExpression -> Boolean
    coerce? : SExpression -> Boolean
    collect? : SExpression -> Boolean
    exit? : SExpression -> Boolean
    function? : SExpression -> Boolean
    functor? : SExpression -> Boolean
    itor? : SExpression -> Boolean
    guard? : SExpression -> Boolean
    has? : SExpression -> Boolean
    if? : SExpression -> Boolean
    ifelse? : SExpression -> Boolean
    import? : SExpression -> Boolean
    is? : SExpression -> Boolean
    join? : SExpression -> Boolean
    lambda? : SExpression -> Boolean
    let? : SExpression -> Boolean
    listof? : SExpression -> Boolean
    loop? : SExpression -> Boolean
    macro? : SExpression -> Boolean
    mapping? : SExpression -> Boolean
    nobranch? : SExpression -> Boolean
    progn? : SExpression -> Boolean
    quote? : SExpression -> Boolean
    record? : SExpression -> Boolean
    seq? : SExpression -> Boolean
    signature? : SExpression -> Boolean
    step? : SExpression -> Boolean
    tuple? : SExpression -> Boolean
    union? : SExpression -> Boolean
    var? : SExpression -> Boolean
    while? : SExpression -> Boolean
  == add
    list_of_eq? : (SExpression, Symbol, Integer) -> Boolean
    list_of_eq? (ex, sym, n) ==
      not list? ex => false
      not (#ex = n) => false
      list_ex := destruct ex
      not symbol? list_ex.1 => false
      symbol list_ex.1 = sym

    list_of_ge? : (SExpression, Symbol, Integer) -> Boolean
    list_of_ge? (ex, sym, n) ==
      not list? ex => false
      #ex < n => false
      list_ex := destruct ex
      not symbol? list_ex.1 => false
      symbol list_ex.1 = sym

    nobranch? ex ==
      symbol? ex and symbol ex = 'noBranch => true
      false

    functor? ex ==
      list_of_ge?(ex, 'DEF, 4) =>
        fifth := ex.5
        capsule? fifth or list_of_eq?(fifth, 'add, 3) -- add ?!?!
      false

    capsule? ex == list_of_ge?(ex, 'CAPSULE, 1)
    case? ex == list_of_eq?(ex, 'case, 3)
    category? ex == list_of_ge?(ex, 'CATEGORY, 3)
    coerce? ex == list_of_eq?(ex, '::, 3) or list_of_eq?(ex, 'pretend, 3) or list_of_eq?(ex, '@, 3)
    collect? ex == list_of_ge?(ex, 'COLLECT, 3)
    exit? ex == list_of_eq?(ex, 'exit, 3)
    function? ex == list_of_eq?(ex, 'DEF, 5)
    itor? ex == list_of_eq?(ex, 'IN, 3)
    guard? ex == list_of_eq?(ex, '|, 2)
    has? ex == list_of_eq?(ex, 'has, 3)
    ifelse? ex == list_of_eq?(ex, 'IF, 4)
    import? ex == list_of_eq?(ex, 'import, 2)
    is? ex == list_of_eq?(ex, 'is, 3)
    join? ex == list_of_ge?(ex, 'Join, 2)
    lambda? ex == list_of_eq?(ex, '+->, 3)
    let? ex == list_of_eq?(ex, 'LET, 3)
    listof? ex == list_of_ge?(ex, 'LISTOF, 3)
    loop? ex == list_of_ge?(ex, 'REPEAT, 3)
    macro? ex == list_of_eq?(ex, 'MDEF, 5)
    mapping? ex == list_of_ge?(ex, 'Mapping, 2)
    progn? ex == list_of_ge?(ex, 'PROGN, 2)
    quote? ex == list_of_eq?(ex, 'QUOTE, 2)
    record? ex == list_of_ge?(ex, 'Record, 3)
    seq? ex == list_of_ge?(ex, 'SEQ, 2)
    signature? ex == list_of_eq?(ex, 'SIGNATURE, 3) or list_of_eq?(ex, 'SIGNATURE, 4)
    step? ex == list_of_eq?(ex, 'STEP, 4) or list_of_eq?(ex, 'STEP, 5)
    tuple? ex == list_of_ge?(ex, '_@Tuple, 3)
    union? ex == list_of_ge?(ex, 'Union, 3)
    var? ex == list_of_eq?(ex, ':, 3)
    while? ex == list_of_eq?(ex, 'WHILE, 2)

)abbrev package OUTFHELP OutputFormHelper
++ Helper function for output form printing
OutputFormHelper() : with
    separateBy : (List OutputForm, OutputForm) -> OutputForm
    spaces : List OutputForm -> OutputForm
  == add
    import OutputForm
    import Integer

    separateBy (l, sep) ==
      empty? l => ""
      max_width := "max"/[width i for i in l]
      if max_width >= _$LINELENGTH$Lisp
        then
          j := 0
          nl := #l - 1
          res := []
          for i in l repeat
            res :=
              if j < nl
                then [hconcat [i, sep], :res]
                else [i, :res]
            j := j + 1
          pile (reverse res)
        else
          res := [first l]
          for i in rest l repeat
            res := [i, sep, :res]
          hconcat (reverse res)

    spaces l ==
      separateBy(l, " ")

)abbrev package DEP Dependent
Dependent(I : SetCategory, T : SetCategory) : SetCategory with
    construct : (I, T, Union(T, "empty")) -> %
    pred : % -> I
    ptrue : % -> T
    pfalse : % -> Union(T, "empty")
  == add
    import OutputForm

    Rep := Record(d_pred : I, d_ptrue : T, d_pfalse : Union(T, "empty"))

    construct(p, pt, pf) ==
      construct(p, pt, pf)$Rep

    pred d == d.d_pred
    ptrue d == d.d_ptrue
    pfalse d == d.d_pfalse

    coerce d ==
      if d.d_pfalse case "empty" then
        pile([hconcat ["if ", d.d_pred :: OutputForm],
              hconcat [hspace 1, "then ", d.d_ptrue :: OutputForm]])
      else
        pile([hconcat ["if ", d.d_pred :: OutputForm],
              hconcat [hspace 1, "then ", d.d_ptrue :: OutputForm],
              hconcat [hspace 1, "else ", d.d_pfalse :: OutputForm]])

)abbrev package SFTYPE FunctorType
SFunctorType(D) ==> Record(ft_name : Symbol, ft_args : List(D))

FunctorType(D : SetCategory) : with
    name : % -> Symbol
    args : % -> List(D)
    construct : (Symbol, List(D)) -> %
  == add
    rep(x) ==> (x pretend SFunctorType(D))
    args x == rep(x).ft_args
    name x == rep(x).ft_name
    construct(n, al) == [n, al]$SFunctorType(D) pretend %

)abbrev package SPTYPE SpadType
++ SPAD type representation
SpadType() : SetCategory with
    parse : SExpression -> %
      ++ parse(ex)
    empty : %
      ++ empty
    unknown? : % -> Boolean
      ++ unknown?(type)
    is_functor? : % -> Boolean
  == add
    -- parametrem funktora może być wartość (dowolna)
    MappingType := Record(m_args : List %, m_type : %)
    SignatureType := Record(sig_name : Symbol, sig_type : MappingType)
    FieldType := Record(f_name : Symbol, f_type : %)
    RecordType := List FieldType
    UnionType := List Union(%, FieldType)
    DependentType ==> Dependent(SExpression, %)

    -- (: (: s (SExpression)) MPT)
    -- (s : SExpression) : MPT

    Rep := Union(sum : Record(kind : Union("join", "domain"), types : List %),
                 record : RecordType,
                 union : UnionType,
                 deptype : DependentType,
                 functor : FunctorType(%),
                 mapping : MappingType,
                 singleton : String,
                 signature : SignatureType,
                 integer : Integer,
                 unknown : "unknown")

    import SExpressionHelper
    import OutputForm
    import OutputFormHelper

    empty == construct("unknown")

    unknown? t ==
      t case unknown

    parse ex ==
      -- print (hconcat ["type: ", ex :: OutputForm])

      null? ex => construct("unknown")
      string? ex => construct(string ex)
      integer? ex => construct(integer ex)
      symbol? ex => construct(construct(symbol ex, []))

      signature? ex =>
        -- (SIGNATURE name (RetType Arg1Type Arg2Type ...))
        -- (SIGNATURE name Type constant)
        name := symbol ex.2
        result := parse(car ex.3)
        targs := if #ex = 3
          then [ parse e for e in destruct(cdr ex.3) ]
          else [ parse ex.4 ]
        construct(construct(name, construct(targs, result)))

      ifelse? ex =>
        (spred, strue, sfalse) := (ex.2, ex.3, ex.4)
        nobranch? sfalse =>
          construct(construct(spred, parse strue, "empty"))
        construct(construct(spred, parse strue, parse sfalse))

      record? ex =>
        -- (Record (: field1 Type1) (: field2 Type2) ...)
        mk_record_field := (s : SExpression) : FieldType +->
          construct(symbol s.2, parse s.3)

        construct([mk_record_field e for e in destruct cdr ex]$RecordType)

      union? ex =>
        -- (Union (: field1 Type1) (: field2 Type2) ...)
        -- (Union Type1 Type2 ...)
        mk_union_field := (s : SExpression) : Union(%, FieldType) +->
          var? s => construct(symbol s.2, parse s.3)
          parse s

        construct([mk_union_field e for e in destruct cdr ex]$UnionType)

      category? ex =>
        -- (CATEGORY domain ...)
        -- (CATEGORY package ...)
        signatures := destruct cdr(cdr ex)
        construct(construct("domain", [ parse s for s in signatures ]))

      var? ex or mapping? ex =>
        mk_fntype := (s : SExpression) : % +->
          not list? s =>
            parse s
          head := car s
          symbol? head and symbol head = ': =>
            parse s.3
          parse s
        
        sig := reverse [mk_fntype e for e in destruct(cdr(ex))]$List(%)
        construct(construct(reverse(rest sig), first sig)$MappingType)

      args := [ parse e for e in destruct cdr(ex) ]

      join? ex =>
        -- (Join ...)
        construct(construct("join", args))

      progn? ex =>
        construct(construct("domain", args))

      construct(construct(symbol(car ex), args))

    coerce(type : %) : OutputForm ==
      coerce_field := (f : FieldType) : OutputForm +->
        hconcat [f.f_name :: OutputForm, " : ", f.f_type :: OutputForm]
      coerce_union_field := (f : Union(%, FieldType)) : OutputForm +->
        f case % => f :: OutputForm
        coerce_field f
      type case singleton =>
        type.singleton :: OutputForm
      type case integer =>
        type.integer :: OutputForm
      type case record =>
        hconcat ["Record", paren [coerce_field f for f in type.record]]
      type case union =>
        hconcat ["Union", paren [coerce_union_field f for f in type.union]]
      type case signature =>
        s := type.signature
        name := s.sig_name :: OutputForm
        args := [arg :: OutputForm for arg in s.sig_type.m_args]
        ret := s.sig_type.m_type :: OutputForm
        if #args = 1
          then hconcat [name, " : ", first args, " -> ", ret]
          else hconcat [name, " : ", paren args, " -> ", ret]
      type case deptype =>
        type.deptype :: OutputForm
      type case sum =>
        ts := [ t :: OutputForm for t in type.sum.types ]
        type.sum.kind = "join" =>
          hconcat ["Join(", pile ts, ")"]
        type.sum.kind = "domain" =>
          pile [hconcat["{", pile ts], "}"]
      type case functor =>
        f := type.functor
        name' := (name f) :: OutputForm
        args' := [ t :: OutputForm for t in (args f) ]
        empty? args' =>
          name'
        hconcat [ name', paren args' ]
      type case mapping =>
        ts := [t :: OutputForm for t in type.mapping.m_args]
        if #ts > 1
          then
            hconcat [paren ts, " -> ", type.mapping.m_type :: OutputForm]
          else
            hconcat [first ts, " -> ", type.mapping.m_type :: OutputForm]
      ""

)abbrev package SPIMP SpadImport
++ SPAD domain / category / package import declaration
SpadImport() : SetCategory with
    parse : SExpression -> %
      ++ parse(ex)
  == add
    Rep := SpadType

    import OutputForm

    parse ex ==
      (parse ex.2)$Rep

    coerce ex ==
      hconcat ["import ", (coerce ex)$Rep]

)abbrev package SPVAR SpadVariable
++ SPAD variable declaration representation
SpadVariable() : SetCategory with
    construct : (Symbol, SpadType) -> %
      ++ construct(name,type)
    construct : Symbol -> %
      ++ construct(name)
    parse : SExpression -> %
      ++ parse(ex)
    name : % -> Symbol
  == add
    Rep := Record(arg_name : Symbol, arg_type : SpadType)

    import OutputForm
    import OutputFormHelper
    import SExpressionHelper

    construct(name, type) ==
      construct(name, type)$Rep

    construct name ==
      construct(name, empty)$Rep

    parse ex ==
      --print (hconcat ["variable: ", ex :: OutputForm])

      var? ex =>
        construct(symbol ex.2, parse ex.3)
      symbol? ex =>
        construct(symbol ex)

      print "------"
      print (ex :: OutputForm)
      error "not a variable definition"

    coerce var ==
      name := var.arg_name :: OutputForm
      type := var.arg_type
      typename : OutputForm :=
        if unknown? type
          then "?"
          else type :: OutputForm
      spaces [name, ":", typename]

    name var ==
      var.arg_name

)abbrev package SPEXPR SpadExpression
++ SPAD generic expression
SpadExpression() : SetCategory with
    parse : SExpression -> %
      ++ parse(ex) parses s-expression into SpadExpression
  == add
    SAssign := Record(lval : %, rval : %)
    SCoerce := Record(exp : %, kind : Symbol, type : SpadType)
    SIterator := Record(i_var : Symbol, i_seq : %)
    SLoop := Record(l_type : Union("loop", "collect"), l_itor : List SIterator, l_guard : List %, l_body : %)
    SIfElse := Dependent(%, %)
    SLambda := Record(f_args : List Symbol, f_type : SpadType, f_body : %)
    SApply := Record(a_fun : %, a_args : List %)
    SSeq := Record(s_type : Union("prog", "list", "tuple"), s_expr : List %)
    SRange := Record(start : %, end : Union(%, "infinity"), step : %)
    STypeOf := Record(t_kind : Union("case", "has", "is", ":"), t_expr : %, t_type : SpadType)

    Rep := Union(seq : SSeq,
                 lambda : SLambda,
                 apply : SApply,
                 assign : SAssign,
                 coerce : SCoerce,
                 loop : SLoop,
                 ifelse : SIfElse,
                 type : SpadType,
                 typeof : STypeOf,
                 range : SRange,
                 dfloat : DoubleFloat,
                 integer : Integer,
                 symbol : Symbol,
                 string : String)

    import OutputForm
    import OutputFormHelper
    import SExpression
    import SExpressionHelper
    import SpadVariable

    parse ex ==
      -- czemu odkomentowanie linii niżej wywala kompilację ?
      -- print (hconcat ["expression: ", ex :: OutputForm])
      -- print (ex :: OutputForm)

      seq? ex =>
        -- {sequence of expressions}
        -- (SEQ expr1 expr2 ...)
        construct(["prog", [parse e for e in destruct cdr ex]])

      tuple? ex =>
        -- {tuple constructor}
        -- (@Tuple expr1 expr2 ...)
        construct(["tuple", [parse e for e in destruct cdr ex]])

      lambda? ex =>
        -- (+-> arg body)
        not list? ex.2 =>
          lt := convert [convert '_:, convert [], convert []]
          construct [[symbol ex.2], (parse lt)$SpadType, parse ex.3]

        -- (+-> (: (: arg Type) RetType) body) 
        -- (+-> (: (@Tuple (: arg1 Type1) (: arg2 Type2)) RetType) body)
        t := cdr ex.2
        (ltype, rtype) := destruct t

        args := if tuple? ltype then destruct cdr(ltype) else [ltype]

        arg_name := (s : SExpression) : Symbol +->
          symbol(if list? s then s.2 else s)
        arg_type := (s : SExpression) : SExpression +->
          if list? s then s.3 else convert []

        lsig :=
          convert cons(convert '_:, append([arg_type arg for arg in args], [rtype]))
        largs := [arg_name arg for arg in args]
        construct [largs, parse lsig, parse ex.3]

      var? ex =>
        -- {expression with type annotation}
        -- (: expr Type) 
        construct([":", parse ex.2, parse ex.3])

      case? ex => 
        -- {expression with "case" operator}
        -- (case expr Type)
        construct(["case", parse ex.2, parse ex.3])

      has? ex => 
        -- {expression with "has" operator}
        -- (has expr Type)
        construct(["has", parse ex.2, parse ex.3])

      is? ex => 
        -- {expression with "is" operator}
        -- (is expr Type)
        construct(["is", parse ex.2, parse ex.3])

      let? ex =>
        -- {assignment}
        -- (LET expr value)
        construct([parse ex.2, parse ex.3])

      ifelse? ex =>
        -- {if-then-else expression of if-then statement}
        -- (IF condition expr1 expr2)
        -- (IF condition expr 'noBranch)
        -- (IF condition 'noBranch expr)
        (c, l, r) := (ex.2, ex.3, ex.4)
        sc : SIfElse :=
          nobranch? l =>
            pc := parse (convert [convert '_not, c])
            construct(pc, parse r, "empty")
          nobranch? r =>
            construct(parse c, parse l, "empty")
          construct(parse c, parse l, parse r)
        construct sc

      coerce? ex =>
        -- {coerce, select, cast expression}
        -- (:: expr Type)
        -- (@ expr Type)
        -- (pretend expr Type)
        construct([parse ex.2, symbol ex.1, parse ex.3] $ SCoerce)

      collect? ex or loop? ex =>
        lst := destruct cdr ex
        body := parse(last lst)
        lst := reverse(rest(reverse(lst)))

        print hconcat [(car ex) :: OutputForm, paren [e :: OutputForm for e in lst]]

        range : SRange
        itors : List SIterator := []
        guards : List % := []

        for e in lst repeat
          -- upewnić się ze strażnikami, w collect też może być while
          itor? e =>
            -- (IN item sequence)
            itors := cons([symbol e.2, parse e.3], itors)
          step? e =>
            -- (STEP i m k n) -> i := m..n by k
            -- (STEP i m k) -> i := m.. by k
            range := if #e = 4
              then  [parse e.3, "infinity", parse e.4]
              else  [parse e.3, parse e.5, parse e.4]
            itors := cons([symbol e.2, construct range], itors)
          guard? e or while? e =>
            -- should they be mixed together ?
            -- ('| cond)
            -- (WHILE cond)
            guards := cons(parse e.2, guards)
          print "------"
          print (e :: OutputForm)
          error "unrecognized loop construct"

        reverse!(itors)
        reverse!(guards)

        #guards > 1 => error "loop: more than one guard!"

        if collect? ex
          then construct ["collect", itors, guards, body]
          else construct ["loop", itors, guards, body]

      record? ex or union? ex =>
        stype : SpadType := parse ex
        construct(stype)

      list? ex and #ex > 0 =>
        l := [parse e for e in destruct ex]
        symbol? ex.1 and symbol ex.1 = 'construct =>
          construct(["list", rest l])
        construct([first l, rest l])

      string? ex =>
        construct(string ex)

      symbol? ex =>
        construct(symbol ex)

      integer? ex =>
        construct(integer ex)

      float? ex =>
        construct(float ex)

      null? ex =>
        construct(["list", []])

      print "------"
      print (ex :: OutputForm)
      error "s-expression not handled"

    coerce (ex : %) : OutputForm ==
      ex case range =>
        r := ex.range
        (rstart, rend, rstep) := 
          (r.start :: OutputForm, r.end :: OutputForm, r.step :: OutputForm)
        ofs : List OutputForm := [ rstart, ".." ]
        if not(r.end case "infinity") then
          ofs := concat(ofs, [rend])
        if not(r.step case integer and r.step.integer = 1) then
          ofs := concat(ofs, ["by", rstep])
        spaces ofs
      ex case lambda =>
        hconcat(["function ", paren [e :: OutputForm for e in ex.lambda.f_args],
                 " : ", ex.lambda.f_type :: OutputForm,
                 " == ", ex.lambda.f_body :: OutputForm])
      ex case seq =>
        lst := [ e :: OutputForm for e in ex.seq.s_expr ]
        ex.seq.s_type case "prog" => pile lst
        ex.seq.s_type case "list" => bracket lst
        ex.seq.s_type case "tuple" => paren lst
      ex case apply =>
        fun := ex.apply.a_fun
        args := [ a :: OutputForm for a in ex.apply.a_args ]
        if fun case symbol then
          fun.symbol = 'QUOTE =>
            return hconcat ["'", :args]
          fun.symbol = 'elt =>
            return hconcat [first args, ".", last args]
          fun.symbol = 'exit =>
            return hconcat ["exit{", first args, "}", "(", last args, ")"]
          fun.symbol = 'return =>
            return hconcat ["return{", first args, "}", "(", last args, ")"]
          if #args = 0 then
            fun.symbol = 'Zero => return "0"
            fun.symbol = 'One => return "1"
          if #args = 2 and member?(fun.symbol, ['_-, '_+, '_*, '_/, '_^, '_=, '_~_=, '_<, '_>, '_<_=, '_>_=]) then
            return paren spaces([ args.1 :: OutputForm,
                                  fun.symbol :: OutputForm,
                                  args.2 :: OutputForm ])
        #args = 0 => fun :: OutputForm
        hconcat [fun :: OutputForm, paren args]
      ex case coerce =>
        paren spaces([ex.coerce.exp :: OutputForm,
                      ex.coerce.kind :: OutputForm,
                      ex.coerce.type :: OutputForm])
      ex case loop =>
        itors := [ hconcat [ "for ", e.i_var :: OutputForm, " in ", e.i_seq :: OutputForm ]
                   for e in ex.loop.l_itor ]
        guards := [ spaces ["if", e :: OutputForm] for e in ex.loop.l_guard ]
        body := ex.loop.l_body :: OutputForm
        ex.loop.l_type case "loop" =>
          if empty? itors
            then
              loop_cond := separateBy([e :: OutputForm for e in ex.loop.l_guard ], " and ")
              pile([hconcat ["while ", loop_cond],
                    hconcat [hspace 1, "repeat ", body]])
            else
              pile([hconcat [spaces concat(itors, guards)],
                    hconcat [hspace 1, "repeat ", body]])
        ex.loop.l_type case "collect" =>
          spaces ["[", body, spaces concat(itors, guards), "]"]
      ex case ifelse =>
        ex.ifelse :: OutputForm
      ex case typeof =>
        hconcat([ex.typeof.t_expr :: OutputForm, " ", 
                 ex.typeof.t_kind :: OutputForm, " ",
                 ex.typeof.t_type :: OutputForm])
      ex case assign =>
        hconcat [ex.assign.lval :: OutputForm, " := ", ex.assign.rval :: OutputForm]
      ex case type =>
        ex.type :: OutputForm
      ex case string =>
        ex.string :: OutputForm
      ex case symbol =>
        ex.symbol :: OutputForm
      ex case dfloat =>
        ex.dfloat :: OutputForm
      ex case integer =>
        ex.integer :: OutputForm

      print "------"
      print (ex :: OutputForm)
      error "not handled"

)abbrev package SPFN SpadFunction
++ SPAD function
SpadFunction() : SetCategory with
    construct : (Symbol, List SpadVariable, SpadType, SpadExpression) -> %
      ++ construct(name,varlist,type,exp)
    parse : SExpression -> %
      ++ parse(ex) parses s-expression into a SpadFunction
  == add
    Rep := Record(fn_name : Symbol,
                  fn_args : List SpadVariable,
                  fn_type : SpadType,
                  fn_body : SpadExpression)

    import OutputForm
    import SExpressionHelper
    import SpadVariable
    import SpadExpression

    construct(name, args, type, body) == 
      [name, args, type, body] $ Rep

    parse ex ==
      --print (hconcat ["function: ", ex :: OutputForm])

      function? ex =>
        name := symbol car(ex.2)
        arg_names := destruct cdr(ex.2)
        arg_types := destruct cdr(ex.3)
        args := [ construct(symbol s, parse t) for s in arg_names for t in arg_types ]
        type := car ex.3
        body := ex.5
        pbody : SpadExpression := (parse body)$SpadExpression
        construct(name, args, parse type, pbody)

      print "------"
      print (ex :: OutputForm)
      error "not a function"

    coerce fn ==
      args := [ arg :: OutputForm for arg in fn.fn_args ]
      body := [ fn.fn_body :: OutputForm ]
      ret_type := if unknown? fn.fn_type
        then "" :: OutputForm
        else hconcat([" : ", fn.fn_type :: OutputForm])
      hconcat([fn.fn_name :: OutputForm,
               paren args, ret_type,
               " == ", pile body, ""])

)abbrev package SPMACRO SpadMacro
++ SPAD macro representation
SpadMacro() : SetCategory with
    construct : (Symbol, List Symbol, SExpression) -> %
      ++ construct(name,args,exp)
    parse : SExpression -> %
      ++ parse(ex)
  == add
    Rep := Record(md_name : Symbol,
                  md_args : List Symbol,
                  md_body : SExpression)

    import OutputForm
    import SExpressionHelper

    construct(name, args, body) ==
      construct(name, args, body)$Rep

    parse ex ==
      --print (hconcat ["macro: ", ex :: OutputForm])

      macro? ex =>
        name := symbol car(ex.2)
        args := [ symbol s for s in destruct(cdr(ex.2)) ]
        body := ex.5
        construct(name, args, body)

      print "------"
      print (ex :: OutputForm)
      error "not a macro definition"

    coerce m ==
      args := [ arg :: OutputForm for arg in m.md_args ]
      margs := 
        if null m.md_args
          then "" :: OutputForm
          else paren args
      hconcat([m.md_name :: OutputForm,
               margs, " ==> ", pile [m.md_body :: OutputForm]])

)abbrev package SPCAPS SpadCapsule
++ SPAD capsule representation
SpadCapsule() : SetCategory with
    parse : SExpression -> %
      ++ parse(sex)
  == add
    DependentCapsule := 
      Record(c_pred : SpadExpression, c_true : %, c_false : Union(%, "empty"))
    CapsuleContent :=
      Union(SpadVariable, SpadExpression, SpadMacro, SpadFunction, SpadImport, DependentCapsule) -- czy nie połączyć z ciałem funkcji

    Rep := List CapsuleContent

    import OutputForm
    import SExpressionHelper
    import SpadFunction
    import SpadMacro
    import SpadVariable

    parse ex ==
      -- print (hconcat ["capsule: ", ex :: OutputForm])

      content : List CapsuleContent := []
      sfun : SpadFunction 
      smacro : SpadMacro 
      svar : SpadVariable
      sexp : SpadExpression
      simp : SpadImport
      sdep : DependentCapsule

      for e in destruct ex repeat
        if exit? e then e := e.3

        function? e =>
          sfun := parse e
          content := [sfun, :content]

        macro? e =>
          smacro := parse e
          content := [smacro, :content]

        var? e =>
          if listof? e.2
            then
              -- (: (LISTOF x y z ...) Type)
              varlst := destruct(cdr e.2)
              for var in varlst repeat
                svar := construct(symbol var, parse e.3)
                content := [svar, :content]
            else
              svar := parse e
              content := [svar, :content]

        let? e =>
          sexp := parse e
          content := [sexp, :content]

        import? e =>
          simp := parse e
          content := [simp, :content]

        ifelse? e =>
          cpred : SpadExpression := parse e.2
          ctrue : %
          cfalse : Union(%, "empty")

          (strue, sfalse) := (e.3, e.4)

          ctrue :=
            seq? strue => parse cdr strue
            parse convert [strue]
          cfalse :=
            nobranch? sfalse => "empty"
            seq? sfalse => parse cdr sfalse
            parse convert [sfalse]
        
          content := [construct(cpred, ctrue, cfalse), :content]

        print "---" :: OutputForm
        print "inside capsule but not handled:"
        print (e :: OutputForm)

      construct(reverse content)

    coerce c ==
      ofs : List OutputForm := []

      for i in c repeat
        i case DependentCapsule =>
          of := pile(
            if i.c_false = "empty" then
              [hconcat ["if ", i.c_pred :: OutputForm],
               hconcat [hspace 1, "then ", i.c_true :: OutputForm]]
            else
              [hconcat ["if ", i.c_pred :: OutputForm],
               hconcat [hspace 1, "then ", i.c_true :: OutputForm],
               hconcat [hspace 1, "else ", i.c_false :: OutputForm]])
          ofs := [of, :ofs]
        ofs := [i :: OutputForm, :ofs]

      hconcat [hspace 2, pile reverse ofs]

)abbrev package SPFTOR SpadFunctor
++ SPAD functor representation
SpadFunctor() : SetCategory with
    parse : SExpression -> %
      ++ parse(sex)
  == add
    Rep := Record(f_name : Symbol,
                  f_args : List SpadVariable,
                  f_type : SpadType,
                  f_extends : SpadType,
                  f_capsule : SpadCapsule)

    import OutputForm
    import SExpressionHelper
    import SpadCapsule

    parse ex ==
      --print (hconcat ["functor: ", ex :: OutputForm])

      functor? ex =>
        name := symbol car(ex.2)
        arg_names := destruct cdr(ex.2)
        arg_types := destruct cdr(ex.3)
        args := [ construct(symbol s, parse t)$SpadVariable 
                  for s in arg_names for t in arg_types ]
        type := car ex.3
        body := ex.5
        capsule := 
          if symbol(car body) = 'add then body.3 else body
        extends :=
          if symbol(car body) = 'add then body.2 else convert []
        construct(name, args, parse type, parse extends, parse cdr capsule)

      print "------"
      print (ex :: OutputForm)
      error "not a functor"

    coerce f ==
      args := [ arg :: OutputForm for arg in f.f_args ]
      blankSeparate(
        [ f.f_name :: OutputForm,
          paren args, ":", 
          hconcat [hspace 2, f.f_type :: OutputForm],
          "==", f.f_extends :: OutputForm, "add",
          f.f_capsule :: OutputForm])

)abbrev package STMEXP SpadTreeMacroExpander
SpadTreeMacroExpander() : with
    expand : SpadFunctor -> SpadFunctor
    expand : SpadType -> SpadType
    expand : SpadExpression -> SpadExpression
  == add
    import SpadCapsule

    env : List SpadMacro

    expand (st : SpadType) : SpadType == st
      --st case sum =>
      --  construct(st.sum.kind, [expand t for t in st.sum.types]) $ ?
      --st case record =>
      --  construct(...) $ RecordType
      --st case union =>
      --  construct(...) $ UnionType
      --st case deptype =>
      --  dt := st.deptype
      --  construct(pred dt, expand ptrue dt, expand pfalse dt) $ DependentType
      --st case functor =>
      --  ft := st.functor
      --  construct(ft.ft_name, [expand e for e ft.ft_args])$ FunctorType
      --st case mapping =>
      --  mt := st.mapping
      --  construct([expand e for e in mt.m_args], expand mt.m_type) $ MappingType
      --st case signature =>
      --  sig := st.signature
      --  construct(sig.sig_name, expand sig.sig_type) $ SignatureType
      --
      --st

    expand (ex : SpadExpression) : SpadExpression == ex
      --ex case seq =>
      --  construct(ex.s_type, [expand e for e in ex.s_sexpr]) $ SSeq
      --ex case lambda =>
      --  construct(ex.f_args, expand ex.f_type, expand ex.f_body) $ SLambda
      --ex case apply =>
      --  construct(expand ex.a_fun, [expand e for e in a_args]) $ SApply
      --  -- handle case where ex.a_fun is Symbol
      --ex case assign =>
      --  construct(expand ex.lval, expand ex.rval) $ SAssign
      --ex case coerce =>
      --  construct(expand ex.exp, ex.kind, expand ex.type) $ SCoerce
      --ex case loop =>
      --  construct(ex.l_type,
      --            [expand e for e in ex.l_itor],
      --            [expand e for e in ex.l_guard],
      --            expand ex.l_body) $ SLoop
      --ex case ifelse =>
      --  construct(expand pred ex, expand ptrue ex, expand pfalse ex) $ SIfElse
      --ex case type =>
      --  expand ex
      --ex case typeof =>
      --  construct(ex.t_kind, expand ex.t_expr, expand ex.t_type) $ STypeOf
      --ex case range =>
      --  ex.end case "infinity" =>
      --    construct(expand ex.start, "infinity", expand ex.step)$SRange
      --  construct(expand ex.start, expand ex.end, expand ex.step)$SRange
      --ex case symbol =>
      --  sex := find(ex, env)
      --  if sex case "failed" then
      --    ex
      --  else
      --    parse ex
      --
      --ex

    expand (f : SpadFunctor) : SpadFunctor == f
      -- old_env := copy env
      --
      --caps := f.capsule
      --
      --for e in caps repeat
      --  if e case SpadMacro then
      --    env := cons(e,env)
      --  else
      --    expand e
      --
      --env := old_env

)abbrev package SPTYPCHK SpadTypeChecker
++ Author: Krystian Baclawski
++ Date Created: December 2013
++ Date Last Updated: January 2014
++ Description:
++ Experimental type checker with bottom-up approach.
SpadTypeChecker() : with
    check : SExpression -> Void 
      ++ check(sex) runs type checker for parse tree
  == add
    import SpadFunctor
    import OutputForm

    check e ==
      -- print (e :: OutputForm)

      -- na poziomie funkcji to nie działa:
      -- SF ==> SpadFunctor
      -- id (x : SExpression) : SExpression == x

      ftor : SpadFunctor := parse e
      print (ftor :: OutputForm)
