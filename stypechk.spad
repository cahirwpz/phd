)boot $LINELENGTH := 180
)compile ParserTools.spad
)compile SpadCategories.spad

)abbrev package OUTFHELP OutputFormHelper
++ Helper function for output form printing
OutputFormHelper() : with
    separateBy : (List OutputForm, OutputForm) -> OutputForm
    spaces : List OutputForm -> OutputForm
  == add
    import OutputForm
    import Integer

    separateBy (l, sep) ==
      empty? l => ""
      max_width := "max"/[width i for i in l]
      if max_width >= _$LINELENGTH$Lisp
        then
          j := 0
          nl := #l - 1
          res := []
          for i in l repeat
            res :=
              if j < nl
                then [hconcat [i, sep], :res]
                else [i, :res]
            j := j + 1
          pile (reverse res)
        else
          res := [first l]
          for i in rest l repeat
            res := [i, sep, :res]
          hconcat (reverse res)

    spaces l ==
      separateBy(l, " ")

)compile SpadType.spad
)compile SpadNode.spad

)abbrev package SPFTOR SpadFunctor
++ SPAD functor representation
SpadFunctor() : Exports == Implementation where
  N ==> SpadNode
  T ==> SpadType(SpadNode)

  Exports ==> ParsableCategory with
    elt : (%, "name") -> Symbol
    elt : (%, "args") -> List SpadNamedType(T)
    elt : (%, "type") -> T
    elt : (%, "extends") -> T
    elt : (%, "capsule") -> N
    construct : (Symbol, List SpadNamedType(T), T, T, N) -> %
  
  Implementation ==> add
    Rep := Record(f_name : Symbol,
                  f_args : List SpadNamedType(T),
                  f_type : T,
                  f_extends : T,
                  f_capsule : N)

    import OutputForm
    import ParserTools
    import SpadNode

    construct(n,al,t,e,c) == [n,al,t,e,c]$Rep

    elt(x,"name") == x.f_name
    elt(x,"args") == x.f_args
    elt(x,"type") == x.f_type
    elt(x,"extends") == x.f_extends
    elt(x,"capsule") == x.f_capsule

    parse ex ==
      --print (hconcat ["functor: ", ex :: OutputForm])

      functor? ex =>
        arg_names := destruct cdr(ex.2)
        arg_types := destruct cdr(ex.3)
        fname := symbol car(ex.2)
        ftype := car ex.3
        fbody := ex.5
        fargs : List SpadNamedType(T) :=
          [ [symbol s, parse t] for s in arg_names for t in arg_types ]
        fcapsule := if symbol(car fbody) = 'add then fbody.3 else fbody
        fextends := if symbol(car fbody) = 'add then fbody.2 else convert []
        fcapsule := convert cons(convert 'SEQ, destruct cdr fcapsule)
        construct(fname, fargs, parse ftype, parse fextends, parse fcapsule)

      print "------"
      print (ex :: OutputForm)
      error "not a functor"

    coerce f ==
      blankSeparate(
        [f.f_name :: OutputForm,
         paren [arg :: OutputForm for arg in f.f_args], ":", 
         hconcat [hspace 2, f.f_type :: OutputForm],
         "==", f.f_extends :: OutputForm, "add",
         f.f_capsule :: OutputForm])

)abbrev domain SPCMM SpadCtorModeMap
SpadCtorModeMap() : SetCategory with
    elt : (%, "name") -> Symbol
    elt : (%, "sig") -> List Symbol
    elt : (%, "type") -> SExpression
    elt : (%, "args") -> List SExpression
    construct : SExpression -> %
  == add
    import OutputForm
    import SExpression

    rep(x) ==> (x pretend SExpression)
    T ==> SpadType(SpadNode)

    elt (x, "name") == (car car car rep(x)) pretend Symbol
    elt (x, "sig") == (cdr car car rep(x)) pretend List Symbol
    elt (x, "type") == (car cdr car rep(x)) 
    elt (x, "args") == (cdr cdr car rep(x)) pretend List SExpression

    construct x == x pretend %

    coerce x ==
      fsig := [hconcat [s :: OutputForm, " : ", (parse a)$T :: OutputForm] for s in x.sig for a in x.args]
      hconcat([x.name :: OutputForm, paren fsig, " : ",
               (parse x.type)$T :: OutputForm])

)abbrev domain SPCC SpadCtorCategory
SpadCtorCategory() : SetCategory == add
    rep(x) ==> (x pretend SExpression)
    T ==> SpadType(SpadNode)

    coerce x ==
      (parse rep(x))$T :: OutputForm

)abbrev domain SPOP SpadOperation
SpadOperation() : SetCategory == add
    rep(x) ==> (x pretend SExpression)
    T ==> SpadType(SpadNode)

    import OutputForm
    import SExpression

    coerce x ==
      sex : SExpression := rep(x)
      --print (sex :: OutputForm)
      opname := symbol sex.1
      sig := destruct sex.2
      tl := [(parse t)$T for t in destruct sig.1]
      if #sig >= 4 then
        tl := concat(tl, [(parse (convert 'constant))$T])
      mt : SpadMappingType(T) :=
        if #tl = 1 then
          [[], tl.1]
        else
          [rest tl, first tl]
      type := [opname, [mt]]$SpadNamedType(T)
      op :=
        if #sig >= 3 and not (symbol? sig.3 and symbol sig.3 = 'T)
          then
            pile([type :: OutputForm,
                  hconcat [hspace 2, "when"],
                  hconcat [hspace 4, (parse sig.3)$SpadNode :: OutputForm]])
          else
            type :: OutputForm
      op

)abbrev domain SPDB SpadDatabase
SpadDatabase() : with
    getOperationList : Symbol -> List SpadOperation
    getCtorArgs : Symbol -> List Symbol
      ++ returns constructor argument names
    getCtorArgsKind : Symbol -> List Boolean
      ++ returns constructor argument kind: true when a type, false when a value
    getCtorCategory : Symbol -> SpadCtorCategory
    getCtorKind : Symbol -> Union("domain", "category", "package")
      ++ returns constructor kind
    getCtorModeMap : Symbol -> SpadCtorModeMap
    getAbbrev : Symbol -> Symbol
    getSourceFile : Symbol -> String
  == add
    import SExpression

    getOperationList t ==
      -- Integer
      sex : SExpression := GETDATABASE(t, 'OPERATIONALIST)$Lisp
      null? sex => error "Unknown constructor!"
      sex pretend List SpadOperation

    getCtorArgsKind t ==
      sex : SExpression := GETDATABASE(t,'COSIG)$Lisp
      null? sex => error "Unknown constructor!"
      (cdr sex) pretend List Boolean

    getCtorCategory t ==
      sex : SExpression := GETDATABASE(t, 'CONSTRUCTORCATEGORY)$Lisp
      null? sex => error "Unknown constructor!"
      sex pretend SpadCtorCategory

    getCtorModeMap t ==
      sex : SExpression := GETDATABASE(t, 'CONSTRUCTORMODEMAP)$Lisp
      null? sex => error "Unknown constructor!"
      sex pretend SpadCtorModeMap

    getCtorArgs t ==
      sex : SExpression := GETDATABASE(t, 'CONSTRUCTORARGS)$Lisp
      sex pretend List Symbol

    getCtorKind t ==
      sex : SExpression := GETDATABASE(t, 'CONSTRUCTORKIND)$Lisp
      null? sex => error "Unknown constructor!"
      kind := symbol sex
      kind = 'domain => "domain"
      kind = 'category => "category"
      kind = 'package => "package"
      error "Unknown constructor kind!"

    getAbbrev t ==
      sex : SExpression := GETDATABASE(t, 'ABBREVIATION)$Lisp
      null? sex => error "Unknown constructor!"
      sex pretend Symbol

    getSourceFile t ==
      sex : SExpression := GETDATABASE(t, 'SOURCEFILE)$Lisp
      null? sex => error "Unknown constructor!"
      sex pretend String

)abbrev package STMEXP SpadTreeMacroExpander
SpadTreeMacroExpander() : Type with 
    rewrite : SpadType(SpadNode) -> SpadType(SpadNode)
    rewrite : SpadNode -> SpadNode
    rewrite : SpadFunctor -> SpadFunctor
  == add
    N ==> SpadNode
    T ==> SpadType(N)

    import OutputForm

    env : AssociationList(Symbol, SpadMacro(N)) := table()

    rewrite (t : T) : T ==
      sum := sumTypeOf t
      sum case SpadSumType(T) =>
        [[sum.kind, [rewrite typ for typ in sum.types]]]

      record := recordTypeOf t
      record case SpadRecordType(T) =>
        [[[[field.name, rewrite field.type] for field in record.fields]]]
        
      union := unionTypeOf t
      union case SpadUnionType(T) =>
        varl : List Union(T, SpadNamedType(T)) := []
        for var in union.variants repeat
          var case T =>
            varl := [rewrite var, :varl]
          var case SpadNamedType(T) =>
            varl := [[var.name, rewrite var.type], :varl]
        [[reverse varl]]
      
      ftor := functorTypeOf t
      ftor case SpadFunctorType(T) =>
        fsym := ftor.name
        key?(fsym, env) =>
          #ftor.args > 0 =>
            print "Parametrized macros not supported!"
            return t
          rewrite (parse env(fsym).body)$T
        [[ftor.name, [rewrite arg for arg in ftor.args]]]

      fun := mappingTypeOf t
      fun case SpadMappingType(T) =>
        [[[rewrite arg for arg in fun.args], rewrite fun.type]]

      named := namedTypeOf t
      named case SpadNamedType(T) =>
        [[named.name, rewrite named.type] $ SpadNamedType(T)]

      -- no need to rewrite singleton type
      -- just return unchanged
      t

    rewrite (n : N) : N ==
      seq := sequenceOf n
      seq case SpadSequence(N) =>
        [[seq.kind, [rewrite ex for ex in seq.list]]]

      lambda := lambdaOf n
      lambda case SpadLambda(N) =>
        [[lambda.args, rewrite lambda.type, rewrite lambda.body]$SpadLambda(N)]

      apply := applyOf n
      apply case SpadApply(N) =>
        funsym := symbolOf apply.function
        funsym case Symbol and key?(funsym, env) and #apply.args > 0 =>
          print "Parametrized macros not supported!"
          return n
        [[rewrite apply.function, [rewrite arg for arg in apply.args]]$SpadApply(N)]

      assign := assignOf n
      assign case SpadAssign(N) =>
        [[rewrite assign.lvalue, rewrite assign.rvalue]$SpadAssign(N)]

      loop := loopOf n
      loop case SpadLoop(N) =>
        -- BUG: parser ma problemy z listami rozrzuconymi po liniach
        nitors := [[itor.var, rewrite itor.seq] for itor in loop.itors]
        nguards := [rewrite guard for guard in loop.guards]
        [[loop.kind, nitors, nguards, rewrite loop.body]]

      scond := conditionalOf n
      scond case SpadConditional(N) =>
        c := rewrite scond.cond
        t := rewrite scond.truebr
        f := (scond.falsebr case N => rewrite (scond.falsebr :: N); "empty")
        [[c, t, f]$SpadConditional(N)]

      func := functionOf n
      func case SpadFunction(N) =>
        argl : List Union(String, SpadNamedType(T)) := []
        for arg in func.args repeat
          argl := if arg case SpadNamedType(T)
            then [[arg.name, rewrite arg.type], :argl]
            else [arg, :argl]
        [[func.name, reverse argl, rewrite func.type, rewrite func.body]]

      smacro := macroOf n
      smacro case SpadMacro(N) =>
        s := smacro.name
        env(s) := smacro
        emptyNode()

      stype := typeOf n
      stype case SpadType(N) =>
        [rewrite (stype :: SpadType(N))]

      simport := importOf n
      simport case SpadImport(N) =>
        [[rewrite simport.type]$SpadImport(N)]

      typexpr := typeExprOf n
      typexpr case SpadTypeExpr(N) =>
        [[typexpr.kind, rewrite typexpr.expr, rewrite typexpr.type]$SpadTypeExpr(N)]

      segment := segmentOf n
      segment case SpadSegment(N) =>
        b := rewrite segment.start
        s := rewrite segment.step
        seg : SpadSegment(N) :=
          segment.end case "infinity" => [b, s]
          [b, rewrite (segment.end :: N), s]
        [seg]

      sym := symbolOf n
      sym case Symbol =>
        s := sym :: Symbol
        not key?(s, env) => n
        parse env(s).body

      -- no need to rewrite float, integer and string values
      -- just return unchanged
      n

    rewrite (f : SpadFunctor) : SpadFunctor ==
      env := table()
      ncapsule := rewrite f.capsule
      print (env :: OutputForm)
      [f.name, f.args, f.type, f.extends, ncapsule]

)abbrev package SPTYPCHK SpadTypeChecker
++ Author: Krystian Baclawski
++ Date Created: December 2013
++ Date Last Updated: January 2014
++ Description:
++ Experimental type checker with bottom-up approach.
SpadTypeChecker() : with
    check : SExpression -> Void 
      ++ check(sex) runs type checker for parse tree
  == add
    import OutputForm
    import SpadFunctor
    import SpadTreeMacroExpander

    check e ==
      --print (e :: OutputForm)
      ftor : SpadFunctor := parse e
      print (ftor :: OutputForm)
      nftor := rewrite ftor
      print (nftor :: OutputForm)
