)boot $LINELENGTH := 180
)compile ParserTools.spad
)compile SpadCategories.spad

)abbrev package OUTFHELP OutputFormHelper
++ Helper function for output form printing
OutputFormHelper() : with
    separateBy : (List OutputForm, OutputForm) -> OutputForm
    spaces : List OutputForm -> OutputForm
  == add
    import OutputForm
    import Integer

    separateBy (l, sep) ==
      empty? l => ""
      max_width := "max"/[width i for i in l]
      if max_width >= _$LINELENGTH$Lisp
        then
          j := 0
          nl := #l - 1
          res := []
          for i in l repeat
            res :=
              if j < nl
                then [hconcat [i, sep], :res]
                else [i, :res]
            j := j + 1
          pile (reverse res)
        else
          res := [first l]
          for i in rest l repeat
            res := [i, sep, :res]
          hconcat (reverse res)

    spaces l ==
      separateBy(l, " ")

)compile SpadType.spad
)compile SpadNode.spad

)abbrev package SPFTOR SpadFunctor
++ SPAD functor representation
SpadFunctor() : ParsableCategory with
    elt : (%, "name") -> Symbol
    elt : (%, "args") -> List SpadSymbolDecl(SpadNode)
    elt : (%, "type") -> SpadType(SpadNode)
    elt : (%, "extends") -> SpadType(SpadNode)
    elt : (%, "capsule") -> SpadNode
  == add
    Rep := Record(f_name : Symbol,
                  f_args : List SpadSymbolDecl(SpadNode),
                  f_type : SpadType(SpadNode),
                  f_extends : SpadType(SpadNode),
                  f_capsule : SpadNode)

    import OutputForm
    import ParserTools
    import SpadNode

    elt(x,"name") == x.f_name
    elt(x,"args") == x.f_args
    elt(x,"type") == x.f_type
    elt(x,"extends") == x.f_extends
    elt(x,"capsule") == x.f_capsule

    parse ex ==
      --print (hconcat ["functor: ", ex :: OutputForm])

      functor? ex =>
        arg_names := destruct cdr(ex.2)
        arg_types := destruct cdr(ex.3)
        fname := symbol car(ex.2)
        ftype := car ex.3
        fbody := ex.5
        fargs : List SpadSymbolDecl(SpadNode) :=
          [ [symbol s, parse t] for s in arg_names for t in arg_types ]
        fcapsule := if symbol(car fbody) = 'add then fbody.3 else fbody
        fextends := if symbol(car fbody) = 'add then fbody.2 else convert []
        fcapsule := convert cons(convert 'SEQ, destruct cdr fcapsule)
        construct(fname, fargs, parse ftype, parse fextends, parse fcapsule)

      print "------"
      print (ex :: OutputForm)
      error "not a functor"

    coerce f ==
      blankSeparate(
        [f.f_name :: OutputForm,
         paren [arg :: OutputForm for arg in f.f_args], ":", 
         hconcat [hspace 2, f.f_type :: OutputForm],
         "==", f.f_extends :: OutputForm, "add",
         f.f_capsule :: OutputForm])

)abbrev package STMEXP SpadTreeMacroExpander
SpadTreeMacroExpander() : with
    walk : SpadFunctor -> SpadFunctor
    walk : SpadType(SpadNode) -> SpadType(SpadNode)
    walk : SpadNode -> SpadNode
  == add
    env : List SpadMacro

    expand (st : SpadType(SpadNode)) : SpadType(SpadNode) == st
      --st case sum =>
      --  construct(st.sum.kind, [expand t for t in st.sum.types]) $ ?
      --st case record =>
      --  construct(...) $ RecordType
      --st case union =>
      --  construct(...) $ UnionType
      --st case deptype =>
      --  dt := st.deptype
      --  construct(pred dt, expand ptrue dt, expand pfalse dt) $ DependentType
      --st case functor =>
      --  ft := st.functor
      --  construct(ft.ft_name, [expand e for e ft.ft_args])$ FunctorType
      --st case mapping =>
      --  mt := st.mapping
      --  construct([expand e for e in mt.m_args], expand mt.m_type) $ MappingType
      --st case signature =>
      --  sig := st.signature
      --  construct(sig.sig_name, expand sig.sig_type) $ SignatureType
      --
      --st

    expand (ex : SpadNode) : SpadNode == ex
      --ex case seq =>
      --  construct(ex.s_type, [expand e for e in ex.s_sexpr]) $ SSeq
      --ex case lambda =>
      --  construct(ex.f_args, expand ex.f_type, expand ex.f_body) $ SLambda
      --ex case apply =>
      --  construct(expand ex.a_fun, [expand e for e in a_args]) $ SApply
      --  -- handle case where ex.a_fun is Symbol
      --ex case assign =>
      --  construct(expand ex.lval, expand ex.rval) $ SAssign
      --ex case coerce =>
      --  construct(expand ex.exp, ex.kind, expand ex.type) $ SCoerce
      --ex case loop =>
      --  construct(ex.l_type,
      --            [expand e for e in ex.l_itor],
      --            [expand e for e in ex.l_guard],
      --            expand ex.l_body) $ SLoop
      --ex case ifelse =>
      --  construct(expand pred ex, expand ptrue ex, expand pfalse ex) $ SIfElse
      --ex case type =>
      --  expand ex
      --ex case typeof =>
      --  construct(ex.t_kind, expand ex.t_expr, expand ex.t_type) $ STypeOf
      --ex case range =>
      --  ex.end case "infinity" =>
      --    construct(expand ex.start, "infinity", expand ex.step)$SRange
      --  construct(expand ex.start, expand ex.end, expand ex.step)$SRange
      --ex case symbol =>
      --  sex := find(ex, env)
      --  if sex case "failed" then
      --    ex
      --  else
      --    parse ex
      --
      --ex

    expand (f : SpadFunctor) : SpadFunctor == f
      -- old_env := copy env
      --
      --caps := f.capsule
      --
      --for e in caps repeat
      --  if e case SpadMacro then
      --    env := cons(e,env)
      --  else
      --    expand e
      --
      --env := old_env

)abbrev package SPTYPCHK SpadTypeChecker
++ Author: Krystian Baclawski
++ Date Created: December 2013
++ Date Last Updated: January 2014
++ Description:
++ Experimental type checker with bottom-up approach.
SpadTypeChecker() : with
    check : SExpression -> Void 
      ++ check(sex) runs type checker for parse tree
  == add
    import SpadFunctor
    import OutputForm

    check e ==
      -- print (e :: OutputForm)

      -- na poziomie funkcji to nie dziaÅ‚a:
      -- SF ==> SpadFunctor
      -- id (x : SExpression) : SExpression == x

      ftor : SpadFunctor := parse e
      print (ftor :: OutputForm)
