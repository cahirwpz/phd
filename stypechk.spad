)boot $LINELENGTH := 180
)compile ParserTools.spad

)abbrev package OUTFHELP OutputFormHelper
++ Helper function for output form printing
OutputFormHelper() : with
    separateBy : (List OutputForm, OutputForm) -> OutputForm
    spaces : List OutputForm -> OutputForm
  == add
    import OutputForm
    import Integer

    separateBy (l, sep) ==
      empty? l => ""
      max_width := "max"/[width i for i in l]
      if max_width >= _$LINELENGTH$Lisp
        then
          j := 0
          nl := #l - 1
          res := []
          for i in l repeat
            res :=
              if j < nl
                then [hconcat [i, sep], :res]
                else [i, :res]
            j := j + 1
          pile (reverse res)
        else
          res := [first l]
          for i in rest l repeat
            res := [i, sep, :res]
          hconcat (reverse res)

    spaces l ==
      separateBy(l, " ")

)abbrev package DEP Dependent
Dependent(I : SetCategory, T : SetCategory) : SetCategory with
    elt : (%, "pred") -> I
    elt : (%, "ptrue") -> T
    elt : (%, "pfalse") -> Union(T, "empty")
    construct : (I, T, Union(T, "empty")) -> %
  == add
    Rep := Record(d_pred : I, d_ptrue : T, d_pfalse : Union(T, "empty"))

    import OutputForm

    elt(x, "pred") == x.d_pred
    elt(x, "ptrue") == x.d_ptrue
    elt(x, "pfalse") == x.d_pfalse

    construct(p, pt, pf) == [p, pt, pf] $ Rep

    coerce d ==
      if d.d_pfalse case "empty" then
        pile([hconcat ["if ", d.d_pred :: OutputForm],
              hconcat [hspace 1, "then ", d.d_ptrue :: OutputForm]])
      else
        pile([hconcat ["if ", d.d_pred :: OutputForm],
              hconcat [hspace 1, "then ", d.d_ptrue :: OutputForm],
              hconcat [hspace 1, "else ", d.d_pfalse :: OutputForm]])

)abbrev package SPTFTOR SpadFunctorType
SpadFunctorType(T : ParsableCategory) : ParsableCategory with
    elt : (%, "name") -> Symbol
    elt : (%, "args") -> List(T)
    construct : (Symbol, List(T)) -> %
  == add
    -- parametrem funktora może być wartość (dowolna)
    FunctorType(T) ==>
      Record(ft_name : Symbol, ft_args : List(T))
    rep(x) ==> (x pretend FunctorType(T))

    elt(x, "args") == rep(x).ft_args
    elt(x, "name") == rep(x).ft_name

    construct(n, al) == [n, al]$FunctorType(T) pretend %

    parse ex ==
      fargs : List(T) := [ parse e for e in destruct cdr(ex) ]
      [ symbol car ex, fargs ]

    coerce ftor ==
      fname := ftor.name :: OutputForm
      fargs := [ t :: OutputForm for t in ftor.args ]
      empty? fargs => fname
      hconcat [ fname, paren fargs ]

)abbrev package SPTMAP SpadMappingType
SpadMappingType(T : ParsableCategory) : ParsableCategory with
    elt : (%, "args") -> List(T)
    elt : (%, "type") -> T
    construct : (List(T), T) -> %
  == add
    MappingType(T) ==>
      Record(m_args : List(T), m_type : T)
    rep(x) ==> (x pretend MappingType(T))

    import ParserTools

    elt(x, "args") == rep(x).m_args
    elt(x, "type") == rep(x).m_type

    construct(al, t) == [al, t]$(MappingType T) pretend %

    parseFunType : SExpression -> T
    parseFunType s ==
      if firstSymbol? (s, ':) then parse s.3 else parse s
        
    parse ex ==
      sig : List(T) := reverse [ parseFunType e for e in destruct cdr ex ]
      [ reverse(rest sig), first sig ]

    coerce mapping ==
      ts := [t :: OutputForm for t in mapping.args]
      src := if #ts > 1 then paren ts else first ts
      hconcat [src, " -> ", mapping.type :: OutputForm]

)abbrev package SPTSUM SpadSumType
SpadSumType(T : ParsableCategory) : ParsableCategory with
    elt : (%, "types") -> List(T)
    elt : (%, "kind") -> Union("join", "domain", "package", "list")
    construct : (Union("join", "domain", "package", "list"), List(T)) -> %
  == add
    SumType(T) ==>
      Record(s_kind : Union("join", "domain", "package", "list"), s_types : List(T))
    rep(x) ==> (x pretend SumType(T))

    import ParserTools

    elt(x, "kind") == rep(x).s_kind
    elt(x, "types") == rep(x).s_types

    construct(k, tl) == [k, tl]$(SumType T) pretend %

    parse ex ==
      lst :=
        domain? ex or package? ex =>
          -- (CATEGORY domain ...)
          -- (CATEGORY package ...)
          destruct cdr(cdr(ex))
        join? ex or progn? ex =>
          -- (Join ...)
          -- (PROGN ...)
          destruct cdr(ex)

      args : List(T) := [ parse e for e in lst ]

      domain? ex => ["domain", args]
      package? ex => ["package", args]
      join? ex => ["join", args]
      progn? ex => ["list", args]

    coerce(sum : %) : OutputForm ==
      ts := [ t :: OutputForm for t in sum.types ]
      sum.kind case "join" => hconcat ["Join(", pile ts, ")"]
      pile [hconcat["{", pile ts], "}"]

)abbrev package SPTSIG SpadSignatureType
SpadSignatureType(T : ParsableCategory) : ParsableCategory with
    elt : (%, "name") -> Symbol
    elt : (%, "type") -> SpadMappingType(T)
    construct : (Symbol, SpadMappingType T) -> %
  == add
    SignatureType(T) ==>
      Record(s_name : Symbol, s_type : SpadMappingType(T))
    rep(x) ==> (x pretend (SignatureType T))

    elt(x, "name") == rep(x).s_name
    elt(x, "type") == rep(x).s_type

    construct(n, t) == [n, t]$(SignatureType T) pretend %

    parse ex ==
      -- (SIGNATURE name (RetType Arg1Type Arg2Type ...))
      -- (SIGNATURE name Type constant)
      res : T := parse(car ex.3)
      targs : List(T) := if #ex = 3
        then [ parse e for e in destruct(cdr ex.3) ]
        else [ parse ex.4 ]
      [ symbol ex.2, construct(targs, res) ]

    coerce(sig : %) : OutputForm ==
      hconcat [sig.name :: OutputForm, " : ", sig.type :: OutputForm]

)abbrev package SPTNAMED SpadNamedType
SpadNamedType(T : ParsableCategory) : ParsableCategory with
    elt : (%, "name") -> Symbol
    elt : (%, "type") -> T
    construct : (Symbol, T) -> %
  == add
    NamedType(T) ==>
      Record(n_name : Symbol, n_type : T)
    rep(x) ==> (x pretend (NamedType T))

    import SExpression

    elt(x, "name") == rep(x).n_name
    elt(x, "type") == rep(x).n_type

    construct(n, t) == [n, t]$(NamedType T) pretend %

    parse ex ==
      -- (: field Type)
      [ symbol ex.2, (parse ex.3) $ T ]

    coerce(field : %) : OutputForm ==
      hconcat [field.name :: OutputForm, " : ", field.type :: OutputForm]

)abbrev package SPTREC SpadRecordType
SpadRecordType(T : ParsableCategory) : ParsableCategory with
    elt : (%, "fields") -> List SpadNamedType(T)
    construct : List SpadNamedType(T) -> %
  == add
    Rep := List SpadNamedType(T)

    elt(x, "fields") == x pretend List SpadNamedType(T)

    construct fl == fl pretend %

    parse ex ==
      -- (Record (: field1 Type1) (: field2 Type2) ...)
      construct [parse e for e in destruct cdr ex]

    coerce(record : %) : OutputForm ==
      hconcat ["Record", paren [f :: OutputForm for f in record]]

)abbrev package SPTUNION SpadUnionType
SpadUnionType(T : ParsableCategory) : ParsableCategory with
    elt : (%, "variants") -> List Union(T, SpadNamedType(T))
    construct : List Union(T, SpadNamedType(T)) -> %
  == add
    Rep := List Union(T, SpadNamedType(T))

    import ParserTools

    elt(x, "variants") == x pretend List Union(T, SpadNamedType(T))

    construct fl == fl pretend %

    parseUnionField : SExpression -> Union(T, SpadNamedType(T))
    parseUnionField s ==
      var? s => construct(symbol s.2, parse s.3) $ SpadNamedType(T)
      (parse s) $ T

    parse ex ==
      -- (Union (: field1 Type1) (: field2 Type2) ...)
      -- (Union Type1 Type2 ...)
      construct [parseUnionField e for e in destruct cdr ex]

    coerce_field : Union(T, SpadNamedType(T)) -> OutputForm
    coerce_field f ==
      f case T => (f :: T) :: OutputForm
      (f :: SpadNamedType(T)) :: OutputForm

    coerce(union : %) : OutputForm ==
      hconcat ["Union", paren [coerce_field v for v in union.variants]]

)abbrev package SPTYPE SpadType
++ SPAD type representation
SpadType() : ParsableCategory with
    empty : %
    unknownType? : % -> Boolean
    functorType? : % -> Boolean
    sumType? : % -> Boolean
    recordType? : % -> Boolean
    unionType? : % -> Boolean
    mappingType? : % -> Boolean
    signatureType? : % -> Boolean
  == add
    DependentType := Dependent(SExpression, %)

    Rep := Union(sum : SpadSumType(%),
                 record : SpadRecordType(%),
                 union : SpadUnionType(%),
                 deptype : DependentType,
                 functor : SpadFunctorType(%),
                 mapping : SpadMappingType(%),
                 signature : SpadSignatureType(%),
                 singleton : String,
                 integer : Integer,
                 unknown : "unknown")

    import ParserTools
    import OutputForm
    import OutputFormHelper

    empty == ["unknown"]

    unknownType? t == t case unknown
    functorType? t == t case functor
    sumType? t == t case sum
    recordType? t == t case record
    unionType? t == t case union
    mappingType? t == t case mapping
    signatureType? t == t case signature

    parse ex ==
      -- print (hconcat ["type: ", ex :: OutputForm])

      null? ex => ["unknown"]
      string? ex => [string ex]
      integer? ex => [integer ex]
      symbol? ex => [construct(symbol ex, [])]

      signature? ex =>
        [(parse ex) $ SpadSignatureType(%)]
      record? ex =>
        [(parse ex) $ SpadRecordType(%)]
      union? ex => 
        [(parse ex) $ SpadUnionType(%)]
      var? ex or mapping? ex => 
        [(parse ex) $ SpadMappingType(%)]
      domain? ex or package? ex or join? ex or progn? ex =>
        [(parse ex) $ SpadSumType(%)]

      ifelse? ex =>
        (spred, strue, sfalse) := (ex.2, ex.3, ex.4)
        nobranch? sfalse =>
          construct(construct(spred, parse strue, "empty"))
        construct(construct(spred, parse strue, parse sfalse))

      [(parse ex) $ SpadFunctorType(%)]

    coerce ex ==
      ex case record => ex.record :: OutputForm
      ex case union => ex.union :: OutputForm
      ex case singleton => ex.singleton :: OutputForm
      ex case integer => ex.integer :: OutputForm
      ex case signature => ex.signature :: OutputForm
      ex case deptype => ex.deptype :: OutputForm
      ex case sum => ex.sum :: OutputForm
      ex case functor => ex.functor :: OutputForm
      ex case mapping => ex.mapping :: OutputForm
      ex case unknown => ""

      error "coerce $ SpadType: Variant not handled!"

)abbrev domain SPIMP SpadImport
++ SPAD domain / category / package import declaration
SpadImport() : ParsableCategory == add
  import OutputForm

  parse ex ==
    (parse ex.2)$SpadType pretend %

  coerce ex ==
    hconcat ["import ", (ex pretend SpadType) :: OutputForm]

)abbrev domain SPDCL SpadSymbolDecl
++ SPAD variable declaration representation
SpadSymbolDecl() : ParsableCategory with
    elt : (%, "name") -> Symbol
    elt : (%, "type") -> SpadType
    construct : (Symbol, SpadType) -> %
      ++ construct(name,type)
    construct : Symbol -> %
      ++ construct(name)
  == add
    Rep := Record(s_name : Symbol, s_type : SpadType)

    import OutputForm
    import OutputFormHelper
    import ParserTools

    elt(x, "name") == x.s_name
    elt(x, "type") == x.s_type

    construct(aname, atype) == [aname, atype]$Rep
    construct(aname) == [aname, empty]$Rep

    parse ex ==
      --print (hconcat ["variable: ", ex :: OutputForm])

      var? ex =>
        construct(symbol ex.2, parse ex.3)
      symbol? ex =>
        construct(symbol ex)

      print (ex :: OutputForm)
      error "parse $ SpadSymbolDecl: not a variable definition!"

    coerce var ==
      aname := var.s_name :: OutputForm
      atype : OutputForm :=
        if unknownType? var.s_type then "?" else coerce var.s_type
      spaces [aname, ":", atype]

)abbrev category SPEXCAT SpadExpressionCategory
SpadExpressionCategory() : Category == ParsableCategory with
  getSymbol : % -> Union(Symbol, "failed")
  getInteger : % -> Union(Integer, "failed")
  construct : SpadSegment(%) -> %

)abbrev domain SPEXASS SpadAssign
SpadAssign(E : ParsableCategory) : ParsableCategory with
    elt : (%, "lvalue") -> E
    elt : (%, "rvalue") -> E
    construct : (E, E) -> %
  == add
    Assign(T) ==> Record(lv : T, rv : T)
    rep(x) ==> (x pretend Assign(E))

    elt(x, "lvalue") == rep(x).lv
    elt(x, "rvalue") == rep(x).rv

    construct (lval, rval) == [lval, rval]$Assign(E) pretend %

    parse ex ==
      -- (LET expr value)
      construct(parse ex.2, parse ex.3)

    coerce assign ==
      hconcat [rep(assign).lv :: OutputForm, " := ", rep(assign).rv :: OutputForm]

)abbrev domain SPEXAPP SpadApply
SpadApply(E : SpadExpressionCategory) : ParsableCategory with
    elt : (%, "function") -> E
    elt : (%, "args") -> List E
    construct : (E, List E) -> %
  == add
    Apply(T) ==> Record(a_fn : T, a_args : List T)
    rep(x) ==> (x pretend Apply(E))

    import OutputFormHelper

    elt(x, "function") == rep(x).a_fn
    elt(x, "args") == rep(x).a_args

    construct (fn, lst) == [fn, lst]$Apply(E) pretend %

    coerce apply ==
      fun := apply.function
      argl := [ a :: OutputForm for a in apply.args ]
      funsym := getSymbol fun

      funsym case "failed" =>
        #argl = 0 => fun :: OutputForm
        hconcat [fun :: OutputForm, paren argl]

      funsym = 'QUOTE =>
        hconcat ["'", :argl]
      funsym = 'elt =>
        hconcat [first argl, ".", last argl]
      funsym = 'exit =>
        hconcat ["exit{", first argl, "}", "(", last argl, ")"]
      funsym = 'return =>
        hconcat ["return{", first argl, "}", "(", last argl, ")"]
      #argl = 0 and funsym = 'Zero => "0"
      #argl = 0 and funsym = 'One => "1"
      #argl = 2 and member?(funsym, ['_-, '_+, '_*, '_/, '_^, '_=, '_~_=, '_<, '_>, '_<_=, '_>_=]) =>
        paren spaces([argl.1 :: OutputForm,
                      funsym :: OutputForm,
                      argl.2 :: OutputForm ])

      -- finally, every other function call
      hconcat [funsym :: OutputForm, paren argl]

)abbrev domain SPEXSEG SpadSegment
SpadSegment(E : SpadExpressionCategory) : ParsableCategory with
    elt : (%, "start") -> E
    elt : (%, "end") -> Union(E, "infinity")
    elt : (%, "step") -> E
    construct : (E, E) -> %
    construct : (E, E, E) -> %
  == add
    Range(T) ==> Record(r_start : T, r_end : Union(T, "infinity"), r_step : T)
    rep(x) ==> (x pretend Range(E))

    import OutputFormHelper

    elt(x, "start") == rep(x).r_start
    elt(x, "end") == rep(x).r_end
    elt(x, "step") == rep(x).r_step

    construct(f,l,s) == [f,l,s]$Range(E) pretend %
    construct(f,s) == [f,"infinity",s]$Range(E) pretend %

    parse ex ==
      -- (SEGMENT first last)
      construct(parse ex.2, parse ex.3)

    coerce range ==
      (rstart, rend, rstep) := (range.start :: OutputForm,
                                range.end :: OutputForm,
                                range.step :: OutputForm)
      ofs : List OutputForm := [ rstart, ".." ]
      if not(range.end case "infinity") then
        ofs := concat(ofs, [rend])
      i := getInteger range.step
      if i case Integer and i ~= 1 then
        ofs := concat(ofs, ["by", rstep])
      spaces ofs

)abbrev package SPEXITR SpadIterator
SpadIterator(E : SpadExpressionCategory) : ParsableCategory with
    elt : (%, "var") -> Symbol
    elt : (%, "seq") -> E
    construct : (Symbol, E) -> %
  == add
    Iterator(T) ==> Record(i_var : Symbol, i_seq : T)
    rep(x) ==> (x pretend Iterator(E))

    elt(x, "var") == rep(x).i_var
    elt(x, "seq") == rep(x).i_seq

    construct(v,s) == [v,s]$Iterator(E) pretend %

    coerce itor ==
      hconcat ["for ", itor.var :: OutputForm, " in ", itor.seq :: OutputForm]

)abbrev domain SPEXTYP SpadTypeExpression
SpadTypeExpression(E : SpadExpressionCategory) : ParsableCategory with
    elt : (%, "kind") -> Symbol
    elt : (%, "expr") -> E
    elt : (%, "type") -> E
    construct : (Symbol, E, E) -> %
  == add
    TypeExpr(T) ==> Record(t_kind : Symbol, t_expr : T, t_type : T)
    rep(x) ==> (x pretend TypeExpr(E))

    import SExpression

    elt(x,"kind") == rep(x).t_kind
    elt(x,"expr") == rep(x).t_expr
    elt(x,"type") == rep(x).t_type

    construct(k,e,t) ==
      operators : List Symbol :=
        ['case, 'has, 'is, 'pretend, ':, '::, '@]
      not member?(k, operators) =>
        error "Not a type expression operator!"
      [k,e,t]$TypeExpr(E) pretend %

    parse ex ==
      construct(symbol ex.1, parse ex.2, parse ex.3)

    coerce ex ==
      hconcat([ex.expr :: OutputForm, " ",
               ex.kind :: OutputForm, " ",
               ex.type :: OutputForm])

)abbrev domain SPEXLP SpadLoop
SpadLoop(E : SpadExpressionCategory) : ParsableCategory with
    elt : (%, "kind") -> Union("loop", "collect")
    elt : (%, "itors") -> List SpadIterator(E)
    elt : (%, "guards") -> List E
    elt : (%, "body") -> E
    construct : (Union("loop", "collect"), List SpadIterator(E), List E, E) -> %
  == add
    Loop(T) ==>
      Record(l_kind : Union("loop", "collect"),
             l_itors : List SpadIterator(T),
             l_guards : List T,
             l_body : T)
    rep(x) ==> (x pretend Loop(E))

    import ParserTools
    import OutputForm
    import OutputFormHelper

    elt(x,"kind") == rep(x).l_kind
    elt(x,"itors") == rep(x).l_itors
    elt(x,"guards") == rep(x).l_guards
    elt(x,"body") == rep(x).l_body

    construct(k,il,gl,b) == [k,il,gl,b]$Loop(E) pretend %

    parse ex ==
      lst := destruct cdr ex
      l_body := parse(last lst) $ E
      lst := reverse(rest(reverse(lst)))

      -- print hconcat [(car ex) :: OutputForm, paren [e :: OutputForm for e in lst]]

      range : SpadSegment(E)
      l_itors : List SpadIterator(E) := []
      l_guards : List E := []

      for e in lst repeat
        -- upewnić się ze strażnikami, w collect też może być while
        itor? e =>
          -- (IN item sequence)
          l_itors := cons([symbol e.2, parse e.3], l_itors)
        step? e =>
          -- (STEP i m k n) -> i := m..n by k
          -- (STEP i m k) -> i := m.. by k
          range : SpadSegment(E) := if #e = 4
            then [parse e.3, parse e.4]
            else [parse e.3, parse e.5, parse e.4]
          l_itors := cons([symbol e.2, construct range], l_itors)
        guard? e or while? e =>
          -- should they be mixed together ?
          -- ('| cond)
          -- (WHILE cond)
          l_guards := cons(parse e.2, l_guards)
        print "------"
        print (e :: OutputForm)
        error "unrecognized loop construct"

      reverse!(l_itors)
      reverse!(l_guards)

      #l_guards > 1 => error "loop: more than one guard!"

      if collect? ex
        then construct("collect", l_itors, l_guards, l_body)
        else construct("loop", l_itors, l_guards, l_body)

    coerce ex ==
      il := [ i :: OutputForm for i in ex.itors ]
      gl := [ spaces ["if", g :: OutputForm] for g in ex.guards ]
      b := ex.body :: OutputForm
      ex.kind case "loop" =>
        if empty? il
          then
            loop_cond := separateBy([g :: OutputForm for g in ex.guards ], " and ")
            pile([hconcat ["while ", loop_cond],
                  hconcat [hspace 1, "repeat ", b]])
          else
            pile([hconcat [spaces concat(il, gl)],
                  hconcat [hspace 1, "repeat ", b]])
      ex.kind case "collect" =>
        spaces ["[", b, spaces concat(il, gl), "]"]

)abbrev domain SPEXLMD SpadLambda
SpadLambda(E : SpadExpressionCategory) : ParsableCategory with
    elt : (%, "args") -> List Symbol
    elt : (%, "type") -> SpadType
    elt : (%, "body") -> E
    construct : (List Symbol, SpadType, E) -> %
  == add
    Lambda(T) ==>
      Record(f_args : List Symbol, f_type : SpadType, f_body : T)
    rep(x) ==> (x pretend Lambda(E))

    import ParserTools
    import OutputForm

    elt(x,"args") == rep(x).f_args
    elt(x,"type") == rep(x).f_type
    elt(x,"body") == rep(x).f_body

    construct(al,t,b) == [al,t,b]$Lambda(E) pretend %

    nameOf : SExpression -> Symbol
    nameOf s == if list? s then symbol s.2 else symbol s

    typeOf : SExpression -> SExpression
    typeOf s == if list? s then s.3 else convert []

    parse ex ==
      -- (+-> arg body)
      not list? ex.2 =>
        sig := convert [convert '_:, convert [], convert []]
        [[symbol ex.2], parse sig, parse ex.3]

      -- (+-> (: (: arg Type) RetType) body) 
      -- (+-> (: (@Tuple (: arg1 Type1) (: arg2 Type2)) RetType) body)
      (ltype, rtype) := destruct(cdr ex.2)

      largs := if tuple? ltype then destruct cdr(ltype) else [ltype]
      lsym := [nameOf arg for arg in largs]
      ltypes := [typeOf arg for arg in largs]

      sig := convert cons(convert '_:, concat(ltypes, [rtype]))

      construct(lsym, parse sig, parse ex.3)

    coerce ex ==
      hconcat(["function ", paren [e :: OutputForm for e in ex.args],
               " : ", ex.type :: OutputForm, " == ", ex.body :: OutputForm])

)abbrev package SPEXSEQ SpadSequence
SpadSequence(E : SpadExpressionCategory) : ParsableCategory with
    elt : (%, "kind") -> Union("prog", "list", "tuple")
    elt : (%, "list") -> List E
    construct : (Union("prog", "list", "tuple"), List(E)) -> %
  == add
    Seq(T) ==>
      Record(s_kind : Union("prog", "list", "tuple"), s_list : List(T))
    rep(x) ==> (x pretend Seq(E))

    import OutputForm

    elt(x, "kind") == rep(x).s_kind
    elt(x, "list") == rep(x).s_list

    construct(k,l) == [k,l]$Seq(E) pretend %

    coerce ex ==
      lst := [ e :: OutputForm for e in ex.list ]
      ex.kind case "prog" => pile lst
      ex.kind case "list" => bracket lst
      ex.kind case "tuple" => paren lst

)abbrev package SPEXPR SpadExpression
++ SPAD generic expression
SpadExpression() : SpadExpressionCategory == add
    SIfElse := Dependent(%, %)

    Rep := Union(seq : SpadSequence(%),
                 lambda : SpadLambda(%),
                 apply : SpadApply(%),
                 assign : SpadAssign(%),
                 loop : SpadLoop(%),
                 ifelse : SIfElse,
                 type : SpadType,
                 typeexpr : SpadTypeExpression(%),
                 range : SpadSegment(%),
                 dfloat : DoubleFloat,
                 integer : Integer,
                 symbol : Symbol,
                 string : String)

    import OutputForm
    import OutputFormHelper
    import SExpression
    import ParserTools
    import SpadSymbolDecl

    getSymbol ex ==
      if ex case symbol then ex.symbol else "failed"
    getInteger ex ==
      if ex case integer then ex.integer else "failed"

    parse ex ==
      -- czemu odkomentowanie linii niżej wywala kompilację ?
      -- print (hconcat ["expression: ", ex :: OutputForm])
      -- print (ex :: OutputForm)

      seq? ex =>
        -- {sequence of expressions}
        -- (SEQ expr1 expr2 ...)
        construct(["prog", [parse e for e in destruct cdr ex]])

      tuple? ex =>
        -- {tuple constructor}
        -- (@Tuple expr1 expr2 ...)
        construct(["tuple", [parse e for e in destruct cdr ex]])

      lambda? ex =>
        [(parse ex) $ SpadLambda(%)]

      var? ex or case? ex or has? ex or is? ex or pretend? ex or coerce? ex or typesel? ex => 
        -- {expression with type annotation}
        -- (: expr Type) 
        -- {expression with "case" operator}
        -- (case expr Type)
        -- {expression with "has" operator}
        -- (has expr Type)
        -- {expression with "is" operator}
        -- (is expr Type)
        -- {expression with "pretend" operator}
        -- (pretend expr Type)
        -- {expression with "::" coerce operator}
        -- (:: expr Type)
        -- {expression with "@" type selector operator}
        -- (@ expr Type)
        [(parse ex) $ SpadTypeExpression(%)]

      let? ex =>
        [(parse ex) $ SpadAssign(%)]

      ifelse? ex =>
        -- {if-then-else expression of if-then statement}
        -- (IF condition expr1 expr2)
        -- (IF condition expr 'noBranch)
        -- (IF condition 'noBranch expr)
        (c, l, r) := (ex.2, ex.3, ex.4)
        sc : SIfElse :=
          nobranch? l =>
            pc := parse (convert [convert '_not, c])
            construct(pc, parse r, "empty")
          nobranch? r =>
            construct(parse c, parse l, "empty")
          construct(parse c, parse l, parse r)
        construct sc

      collect? ex or loop? ex =>
        [(parse ex) $ SpadLoop(%)]

      record? ex or union? ex =>
        [(parse ex) $ SpadType]

      list? ex and #ex > 0 =>
        lst := [parse e for e in destruct ex]
        symbol? ex.1 and symbol ex.1 = 'construct =>
          construct(["list", rest lst])
        construct([first lst, rest lst])

      string? ex =>
        construct(string ex)

      symbol? ex =>
        construct(symbol ex)

      integer? ex =>
        construct(integer ex)

      float? ex =>
        construct(float ex)

      null? ex =>
        construct(["list", []])

      print "parse $ SpadExpression:"
      print (ex :: OutputForm)
      error "SExpression not handled!"

    coerce ex ==
      ex case range => ex.range :: OutputForm
      ex case lambda => ex.lambda :: OutputForm
      ex case seq => ex.seq :: OutputForm
      ex case apply => ex.apply :: OutputForm
      ex case loop => ex.loop :: OutputForm
      ex case ifelse => ex.ifelse :: OutputForm
      ex case typeexpr => ex.typeexpr :: OutputForm
      ex case assign => ex.assign :: OutputForm
      ex case type => ex.type :: OutputForm
      ex case string => ex.string :: OutputForm
      ex case symbol => ex.symbol :: OutputForm
      ex case dfloat => ex.dfloat :: OutputForm
      ex case integer => ex.integer :: OutputForm

      error "coerce $ SpadExpression: variant not handled!"

)abbrev package SPFN SpadFunction
++ SPAD function
SpadFunction() : ParsableCategory with
    elt : (%, "name") -> Symbol
    elt : (%, "args") -> List Union(String, SpadSymbolDecl)
    elt : (%, "type") -> SpadType
    elt : (%, "body") -> SpadExpression
    construct : (Symbol, List Union(String, SpadSymbolDecl), SpadType, SpadExpression) -> %
      ++ construct(name,varlist,type,exp)
  == add
    Rep := Record(fn_name : Symbol,
                  fn_args : List Union(String, SpadSymbolDecl),
                  fn_type : SpadType,
                  fn_body : SpadExpression)

    import OutputForm
    import ParserTools
    import SpadSymbolDecl
    import SpadExpression

    elt(x, "name") == x.fn_name
    elt(x, "args") == x.fn_args
    elt(x, "type") == x.fn_type
    elt(x, "body") == x.fn_body

    construct(fname, fargs, ftype, fbody) == 
      [fname, fargs, ftype, fbody] $ Rep

    parse_arg : (SExpression, SExpression) -> Union(String, SpadSymbolDecl)
    parse_arg(s, t) ==
      string? s =>
        string s
      construct(symbol s, parse t)

    parse ex ==
      -- print (hconcat ["function: ", ex :: OutputForm])

      function? ex =>
        fname := symbol car(ex.2)
        arg_names := destruct cdr(ex.2)
        arg_types := destruct cdr(ex.3)
        fargs := [ parse_arg(s, t) for s in arg_names for t in arg_types ]
        ftype := car ex.3
        fbody := ex.5
        construct(fname, fargs, parse ftype, parse fbody)

      print "------"
      print (ex :: OutputForm)
      error "not a function"

    coerce fn ==
      fargs := [ arg :: OutputForm for arg in fn.fn_args ]
      fbody := [ fn.fn_body :: OutputForm ]
      retType := if unknownType? fn.fn_type
        then "" :: OutputForm
        else hconcat([" : ", fn.fn_type :: OutputForm])
      hconcat([fn.fn_name :: OutputForm,
               paren fargs, retType,
               " == ", pile fbody, ""])

)abbrev package SPMACRO SpadMacro
++ SPAD macro representation
SpadMacro() : ParsableCategory with
    elt : (%, "name") -> Symbol
    elt : (%, "args") -> List Symbol
    elt : (%, "body") -> SExpression
    construct : (Symbol, List Symbol, SExpression) -> %
      ++ construct(name,args,exp)
  == add
    Rep := Record(md_name : Symbol,
                  md_args : List Symbol,
                  md_body : SExpression)

    import OutputForm
    import ParserTools

    elt(x, "name") == x.md_name
    elt(x, "args") == x.md_args
    elt(x, "body") == x.md_body

    construct(mname, margs, mbody) ==
      [mname, margs, mbody]$Rep

    parse ex ==
      --print (hconcat ["macro: ", ex :: OutputForm])

      macro? ex =>
        mname := symbol car(ex.2)
        margs := [ symbol s for s in destruct(cdr(ex.2)) ]
        mbody := ex.5
        construct(mname, margs, mbody)

      print "------"
      print (ex :: OutputForm)
      error "not a macro definition"

    coerce m ==
      margs := 
        if null m.md_args
          then "" :: OutputForm
          else paren [ arg :: OutputForm for arg in m.md_args ]
      hconcat([m.md_name :: OutputForm,
               margs, " ==> ", pile [m.md_body :: OutputForm]])

)abbrev package SPCAPS SpadCapsule
++ SPAD capsule representation
SpadCapsule() : ParsableCategory
  == add
    DependentCapsule := 
      Record(c_pred : SpadExpression, c_true : %, c_false : Union(%, "empty"))
    CapsuleContent :=
      Union(SpadSymbolDecl, SpadExpression, SpadMacro, SpadFunction, SpadImport, DependentCapsule) -- czy nie połączyć z ciałem funkcji

    Rep := List CapsuleContent

    import OutputForm
    import ParserTools
    import SpadFunction
    import SpadMacro
    import SpadSymbolDecl

    parse ex ==
      -- print (hconcat ["capsule: ", ex :: OutputForm])

      content : List CapsuleContent := []
      sfun : SpadFunction 
      smacro : SpadMacro 
      svar : SpadSymbolDecl
      sexp : SpadExpression
      simp : SpadImport
      sdep : DependentCapsule

      for e in destruct ex repeat
        if exit? e then e := e.3

        function? e =>
          sfun := parse e
          content := [sfun, :content]

        macro? e =>
          smacro := parse e
          content := [smacro, :content]

        var? e =>
          if listof? e.2
            then
              -- (: (LISTOF x y z ...) Type)
              varlst := destruct(cdr e.2)
              for var in varlst repeat
                svar := construct(symbol var, parse e.3)
                content := [svar, :content]
            else
              svar := parse e
              content := [svar, :content]

        let? e =>
          sexp := parse e
          content := [sexp, :content]

        import? e =>
          simp := parse e
          content := [simp, :content]

        ifelse? e =>
          cpred : SpadExpression := parse e.2
          ctrue : %
          cfalse : Union(%, "empty")

          (strue, sfalse) := (e.3, e.4)

          ctrue :=
            seq? strue => parse cdr strue
            parse convert [strue]
          cfalse :=
            nobranch? sfalse => "empty"
            seq? sfalse => parse cdr sfalse
            parse convert [sfalse]
        
          content := [construct(cpred, ctrue, cfalse), :content]

        print "---" :: OutputForm
        print "inside capsule but not handled:"
        print (e :: OutputForm)

      construct(reverse content)

    coerce c ==
      ofs : List OutputForm := []

      for i in c repeat
        i case DependentCapsule =>
          of := pile(
            if i.c_false = "empty" then
              [hconcat ["if ", i.c_pred :: OutputForm],
               hconcat [hspace 1, "then ", i.c_true :: OutputForm]]
            else
              [hconcat ["if ", i.c_pred :: OutputForm],
               hconcat [hspace 1, "then ", i.c_true :: OutputForm],
               hconcat [hspace 1, "else ", i.c_false :: OutputForm]])
          ofs := [of, :ofs]
        ofs := [i :: OutputForm, :ofs]

      hconcat [hspace 2, pile reverse ofs]

)abbrev package SPFTOR SpadFunctor
++ SPAD functor representation
SpadFunctor() : ParsableCategory with
    elt : (%, "name") -> Symbol
    elt : (%, "args") -> List SpadSymbolDecl
    elt : (%, "type") -> SpadType
    elt : (%, "extends") -> SpadType
    elt : (%, "capsule") -> SpadCapsule
  == add
    Rep := Record(f_name : Symbol,
                  f_args : List SpadSymbolDecl,
                  f_type : SpadType,
                  f_extends : SpadType,
                  f_capsule : SpadCapsule)

    import OutputForm
    import ParserTools
    import SpadCapsule

    elt(x,"name") == x.f_name
    elt(x,"args") == x.f_args
    elt(x,"type") == x.f_type
    elt(x,"extends") == x.f_extends
    elt(x,"capsule") == x.f_capsule

    parse ex ==
      --print (hconcat ["functor: ", ex :: OutputForm])

      functor? ex =>
        arg_names := destruct cdr(ex.2)
        arg_types := destruct cdr(ex.3)
        fname := symbol car(ex.2)
        ftype := car ex.3
        fbody := ex.5
        fargs : List SpadSymbolDecl :=
          [ [symbol s, parse t] for s in arg_names for t in arg_types ]
        fcapsule := if symbol(car fbody) = 'add then fbody.3 else fbody
        fextends := if symbol(car fbody) = 'add then fbody.2 else convert []
        construct(fname, fargs, parse ftype, parse fextends, parse cdr fcapsule)

      print "------"
      print (ex :: OutputForm)
      error "not a functor"

    coerce f ==
      blankSeparate(
        [ f.f_name :: OutputForm,
          paren [arg :: OutputForm for arg in f.f_args], ":", 
          hconcat [hspace 2, f.f_type :: OutputForm],
          "==", f.f_extends :: OutputForm, "add",
          f.f_capsule :: OutputForm])

)abbrev package STMEXP SpadTreeMacroExpander
SpadTreeMacroExpander() : with
    walk : SpadFunctor -> SpadFunctor
    walk : SpadType -> SpadType
    walk : SpadExpression -> SpadExpression
  == add
    import SpadCapsule

    env : List SpadMacro

    expand (st : SpadType) : SpadType == st
      --st case sum =>
      --  construct(st.sum.kind, [expand t for t in st.sum.types]) $ ?
      --st case record =>
      --  construct(...) $ RecordType
      --st case union =>
      --  construct(...) $ UnionType
      --st case deptype =>
      --  dt := st.deptype
      --  construct(pred dt, expand ptrue dt, expand pfalse dt) $ DependentType
      --st case functor =>
      --  ft := st.functor
      --  construct(ft.ft_name, [expand e for e ft.ft_args])$ FunctorType
      --st case mapping =>
      --  mt := st.mapping
      --  construct([expand e for e in mt.m_args], expand mt.m_type) $ MappingType
      --st case signature =>
      --  sig := st.signature
      --  construct(sig.sig_name, expand sig.sig_type) $ SignatureType
      --
      --st

    expand (ex : SpadExpression) : SpadExpression == ex
      --ex case seq =>
      --  construct(ex.s_type, [expand e for e in ex.s_sexpr]) $ SSeq
      --ex case lambda =>
      --  construct(ex.f_args, expand ex.f_type, expand ex.f_body) $ SLambda
      --ex case apply =>
      --  construct(expand ex.a_fun, [expand e for e in a_args]) $ SApply
      --  -- handle case where ex.a_fun is Symbol
      --ex case assign =>
      --  construct(expand ex.lval, expand ex.rval) $ SAssign
      --ex case coerce =>
      --  construct(expand ex.exp, ex.kind, expand ex.type) $ SCoerce
      --ex case loop =>
      --  construct(ex.l_type,
      --            [expand e for e in ex.l_itor],
      --            [expand e for e in ex.l_guard],
      --            expand ex.l_body) $ SLoop
      --ex case ifelse =>
      --  construct(expand pred ex, expand ptrue ex, expand pfalse ex) $ SIfElse
      --ex case type =>
      --  expand ex
      --ex case typeof =>
      --  construct(ex.t_kind, expand ex.t_expr, expand ex.t_type) $ STypeOf
      --ex case range =>
      --  ex.end case "infinity" =>
      --    construct(expand ex.start, "infinity", expand ex.step)$SRange
      --  construct(expand ex.start, expand ex.end, expand ex.step)$SRange
      --ex case symbol =>
      --  sex := find(ex, env)
      --  if sex case "failed" then
      --    ex
      --  else
      --    parse ex
      --
      --ex

    expand (f : SpadFunctor) : SpadFunctor == f
      -- old_env := copy env
      --
      --caps := f.capsule
      --
      --for e in caps repeat
      --  if e case SpadMacro then
      --    env := cons(e,env)
      --  else
      --    expand e
      --
      --env := old_env

)abbrev package SPTYPCHK SpadTypeChecker
++ Author: Krystian Baclawski
++ Date Created: December 2013
++ Date Last Updated: January 2014
++ Description:
++ Experimental type checker with bottom-up approach.
SpadTypeChecker() : with
    check : SExpression -> Void 
      ++ check(sex) runs type checker for parse tree
  == add
    import SpadFunctor
    import OutputForm

    check e ==
      -- print (e :: OutputForm)

      -- na poziomie funkcji to nie działa:
      -- SF ==> SpadFunctor
      -- id (x : SExpression) : SExpression == x

      ftor : SpadFunctor := parse e
      print (ftor :: OutputForm)
