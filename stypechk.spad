)boot $LINELENGTH := 180
)compile ParserTools.spad
)compile SpadCategories.spad

)abbrev package OUTFHELP OutputFormHelper
++ Helper function for output form printing
OutputFormHelper() : with
    separateBy : (List OutputForm, OutputForm) -> OutputForm
    spaces : List OutputForm -> OutputForm
  == add
    import OutputForm
    import Integer

    separateBy (l, sep) ==
      empty? l => ""
      max_width := "max"/[width i for i in l]
      if max_width >= _$LINELENGTH$Lisp
        then
          j := 0
          nl := #l - 1
          res := []
          for i in l repeat
            res :=
              if j < nl
                then [hconcat [i, sep], :res]
                else [i, :res]
            j := j + 1
          pile (reverse res)
        else
          res := [first l]
          for i in rest l repeat
            res := [i, sep, :res]
          hconcat (reverse res)

    spaces l ==
      separateBy(l, " ")

)compile SpadType.spad
)compile SpadNode.spad

)abbrev package SPFTOR SpadFunctor
++ SPAD functor representation
SpadFunctor() : ParsableCategory with
    elt : (%, "name") -> Symbol
    elt : (%, "args") -> List SpadSymbolDecl(SpadNode)
    elt : (%, "type") -> SpadType(SpadNode)
    elt : (%, "extends") -> SpadType(SpadNode)
    elt : (%, "capsule") -> SpadNode
  == add
    Rep := Record(f_name : Symbol,
                  f_args : List SpadSymbolDecl(SpadNode),
                  f_type : SpadType(SpadNode),
                  f_extends : SpadType(SpadNode),
                  f_capsule : SpadNode)

    import OutputForm
    import ParserTools
    import SpadNode

    elt(x,"name") == x.f_name
    elt(x,"args") == x.f_args
    elt(x,"type") == x.f_type
    elt(x,"extends") == x.f_extends
    elt(x,"capsule") == x.f_capsule

    parse ex ==
      --print (hconcat ["functor: ", ex :: OutputForm])

      functor? ex =>
        arg_names := destruct cdr(ex.2)
        arg_types := destruct cdr(ex.3)
        fname := symbol car(ex.2)
        ftype := car ex.3
        fbody := ex.5
        fargs : List SpadSymbolDecl(SpadNode) :=
          [ [symbol s, parse t] for s in arg_names for t in arg_types ]
        fcapsule := if symbol(car fbody) = 'add then fbody.3 else fbody
        fextends := if symbol(car fbody) = 'add then fbody.2 else convert []
        fcapsule := convert cons(convert 'SEQ, destruct cdr fcapsule)
        construct(fname, fargs, parse ftype, parse fextends, parse fcapsule)

      print "------"
      print (ex :: OutputForm)
      error "not a functor"

    coerce f ==
      blankSeparate(
        [f.f_name :: OutputForm,
         paren [arg :: OutputForm for arg in f.f_args], ":", 
         hconcat [hspace 2, f.f_type :: OutputForm],
         "==", f.f_extends :: OutputForm, "add",
         f.f_capsule :: OutputForm])

)abbrev package STMEXP SpadTreeMacroExpander
SpadTreeMacroExpander() : with
    walk : SpadFunctor -> SpadFunctor
    walk : SpadType(SpadNode) -> SpadType(SpadNode)
    walk : SpadNode -> SpadNode
  == add
    T ==> SpadType(SpadNode)

    import OutputForm

    env : List SpadMacro(SpadNode)

    walk (t : SpadType(SpadNode)) : SpadType(SpadNode) ==
      sum := sumTypeOf t
      sum case SpadSumType(T) =>
        for typ in sum.types repeat
          walk typ

      record := recordTypeOf t
      record case SpadRecordType(T) =>
        for field in record.fields repeat
          walk field.type
        
      union := unionTypeOf t
      union case SpadUnionType(T) =>
        for variant in union.variants repeat
          variant case T =>
            walk (variant :: T)
          variant case SpadNamedType(T) =>
            walk variant.type
      
      ftor := functorTypeOf t
      ftor case SpadFunctorType(T) =>
        for arg in ftor.args repeat
          walk arg

      fun := mappingTypeOf t
      fun case SpadMappingType(T) =>
        for arg in fun.args repeat
          walk arg
        walk fun.type

      --sig := signatureTypeOf t
      --sig case SpadSignatureType(T) =>
      --  ...

      --singleton := singletonTypeOf t
      --singleton case String =>
      --  ...

      t

    walk (n : SpadNode) : SpadNode ==
      seq := sequenceOf n
      seq case SpadSequence(SpadNode) =>
        for expr in seq.list repeat
          walk expr

      lambda := lambdaOf n
      lambda case SpadLambda(SpadNode) =>
        walk lambda.type
        walk lambda.body

      apply := applyOf n
      apply case SpadApply(SpadNode) =>
        walk apply.function
        for arg in apply.args repeat
          walk arg

      assign := assignOf n
      assign case SpadAssign(SpadNode) =>
        walk assign.lvalue
        walk assign.rvalue

      loop := loopOf n
      loop case SpadLoop(SpadNode) =>
        for itor in loop.itors repeat
          -- walk itor.var
          walk itor.seq
        for guard in loop.guards repeat
          walk guard
        walk loop.body

      cond := conditionalOf n
      cond case SpadConditional(SpadNode) =>
        walk cond.cond 
        walk cond.truebr
        cond.falsebr case SpadNode =>
          walk (cond.falsebr :: SpadNode)

      func := functionOf n
      func case SpadFunction(SpadNode) =>
        for arg in func.args repeat
          arg case SpadSymbolDecl(SpadNode) =>
            walk arg.type
        walk func.type
        walk func.body

      smacro := macroOf n
      smacro case SpadMacro(SpadNode) =>
        print (smacro.name :: OutputForm)

      stype := typeOf n
      stype case SpadType(SpadNode) =>
        walk stype

      simport := importOf n
      simport case SpadImport(SpadNode) =>
        walk simport.type

      typexpr := typeExprOf n
      typexpr case SpadTypeExpression(SpadNode) =>
        walk typexpr.expr
        walk typexpr.type

      segment := segmentOf n
      segment case SpadSegment(SpadNode) =>
        walk segment.start
        walk segment.step
        segment.end case SpadNode =>
          walk (segment.end :: SpadNode)

      --sym := symbolOf n
      --sym case Symbol =>
      --  ...

      --f := floatOf n
      --f case DoubleFloat =>
      --  ...

      --i := integerOf n
      --i case Integer =>
      --  ...
        
      --str := stringOf n
      --str case String =>
      --  ...

      n

    walk (f : SpadFunctor) : SpadFunctor ==
      walk f.capsule
      f

)abbrev package SPTYPCHK SpadTypeChecker
++ Author: Krystian Baclawski
++ Date Created: December 2013
++ Date Last Updated: January 2014
++ Description:
++ Experimental type checker with bottom-up approach.
SpadTypeChecker() : with
    check : SExpression -> Void 
      ++ check(sex) runs type checker for parse tree
  == add
    import OutputForm
    import SpadFunctor
    import SpadTreeMacroExpander

    check e ==
      -- print (e :: OutputForm)

      ftor : SpadFunctor := parse e
      walk ftor
      print (ftor :: OutputForm)
