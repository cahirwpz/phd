)boot $LINELENGTH := 180

)abbrev package SEXHELP SExpressionHelper
++ Helper functions for s-expression handling
SExpressionHelper() : with
    firstSymbol? : (SExpression, Symbol) -> Boolean

    capsule? : SExpression -> Boolean
    case? : SExpression -> Boolean
    coerce? : SExpression -> Boolean
    collect? : SExpression -> Boolean
    domain? : SExpression -> Boolean
    exit? : SExpression -> Boolean
    function? : SExpression -> Boolean
    functor? : SExpression -> Boolean
    itor? : SExpression -> Boolean
    guard? : SExpression -> Boolean
    has? : SExpression -> Boolean
    if? : SExpression -> Boolean
    ifelse? : SExpression -> Boolean
    import? : SExpression -> Boolean
    is? : SExpression -> Boolean
    join? : SExpression -> Boolean
    lambda? : SExpression -> Boolean
    let? : SExpression -> Boolean
    listof? : SExpression -> Boolean
    loop? : SExpression -> Boolean
    macro? : SExpression -> Boolean
    mapping? : SExpression -> Boolean
    nobranch? : SExpression -> Boolean
    package? : SExpression -> Boolean
    progn? : SExpression -> Boolean
    quote? : SExpression -> Boolean
    record? : SExpression -> Boolean
    seq? : SExpression -> Boolean
    signature? : SExpression -> Boolean
    step? : SExpression -> Boolean
    tuple? : SExpression -> Boolean
    union? : SExpression -> Boolean
    var? : SExpression -> Boolean
    while? : SExpression -> Boolean
  == add
    firstSymbol? (ex, sym) ==
        not list? ex => false
        fst := car ex
        not symbol? fst => false
        symbol fst = sym

    list_of_eq? : (SExpression, Symbol, Integer) -> Boolean
    list_of_eq? (ex, sym, n) ==
      not list? ex => false
      not (#ex = n) => false
      list_ex := destruct ex
      not symbol? list_ex.1 => false
      symbol list_ex.1 = sym

    list_of_ge? : (SExpression, Symbol, Integer) -> Boolean
    list_of_ge? (ex, sym, n) ==
      not list? ex => false
      #ex < n => false
      list_ex := destruct ex
      not symbol? list_ex.1 => false
      symbol list_ex.1 = sym

    nobranch? ex ==
      symbol? ex and symbol ex = 'noBranch => true
      false

    functor? ex ==
      list_of_ge?(ex, 'DEF, 5) =>
        fifth := ex.5
        firstSymbol? (car ex.3, 'Category) => true
        capsule? fifth => true
        list_of_eq?(fifth, 'add, 3) => true
      false

    capsule? ex == list_of_ge?(ex, 'CAPSULE, 1)
    case? ex == list_of_eq?(ex, 'case, 3)
    coerce? ex == list_of_eq?(ex, '::, 3) or list_of_eq?(ex, 'pretend, 3) or list_of_eq?(ex, '@, 3)
    collect? ex == list_of_ge?(ex, 'COLLECT, 3)
    domain? ex == list_of_ge?(ex, 'CATEGORY, 3) and symbol ex.2 = 'domain
    exit? ex == list_of_eq?(ex, 'exit, 3)
    function? ex == list_of_eq?(ex, 'DEF, 5)
    itor? ex == list_of_eq?(ex, 'IN, 3)
    guard? ex == list_of_eq?(ex, '|, 2)
    has? ex == list_of_eq?(ex, 'has, 3)
    ifelse? ex == list_of_eq?(ex, 'IF, 4)
    import? ex == list_of_eq?(ex, 'import, 2)
    is? ex == list_of_eq?(ex, 'is, 3)
    join? ex == list_of_ge?(ex, 'Join, 2)
    lambda? ex == list_of_eq?(ex, '+->, 3)
    let? ex == list_of_eq?(ex, 'LET, 3)
    listof? ex == list_of_ge?(ex, 'LISTOF, 3)
    loop? ex == list_of_ge?(ex, 'REPEAT, 3)
    macro? ex == list_of_eq?(ex, 'MDEF, 5)
    mapping? ex == list_of_ge?(ex, 'Mapping, 2)
    package? ex == list_of_ge?(ex, 'CATEGORY, 3) and symbol ex.2 = 'package
    progn? ex == list_of_ge?(ex, 'PROGN, 2)
    quote? ex == list_of_eq?(ex, 'QUOTE, 2)
    record? ex == list_of_ge?(ex, 'Record, 3)
    seq? ex == list_of_ge?(ex, 'SEQ, 2)
    signature? ex == list_of_eq?(ex, 'SIGNATURE, 3) or list_of_eq?(ex, 'SIGNATURE, 4)
    step? ex == list_of_eq?(ex, 'STEP, 4) or list_of_eq?(ex, 'STEP, 5)
    tuple? ex == list_of_ge?(ex, '_@Tuple, 3)
    union? ex == list_of_ge?(ex, 'Union, 3)
    var? ex == list_of_eq?(ex, ':, 3)
    while? ex == list_of_eq?(ex, 'WHILE, 2)

)abbrev category PARSE Parsable
Parsable() : Category == SetCategory with
  parse : SExpression -> %

)abbrev package OUTFHELP OutputFormHelper
++ Helper function for output form printing
OutputFormHelper() : with
    separateBy : (List OutputForm, OutputForm) -> OutputForm
    spaces : List OutputForm -> OutputForm
  == add
    import OutputForm
    import Integer

    separateBy (l, sep) ==
      empty? l => ""
      max_width := "max"/[width i for i in l]
      if max_width >= _$LINELENGTH$Lisp
        then
          j := 0
          nl := #l - 1
          res := []
          for i in l repeat
            res :=
              if j < nl
                then [hconcat [i, sep], :res]
                else [i, :res]
            j := j + 1
          pile (reverse res)
        else
          res := [first l]
          for i in rest l repeat
            res := [i, sep, :res]
          hconcat (reverse res)

    spaces l ==
      separateBy(l, " ")

)abbrev package DEP Dependent
Dependent(I : SetCategory, T : SetCategory) : SetCategory with
    construct : (I, T, Union(T, "empty")) -> %
    pred : % -> I
    ptrue : % -> T
    pfalse : % -> Union(T, "empty")
  == add
    import OutputForm

    Rep := Record(d_pred : I, d_ptrue : T, d_pfalse : Union(T, "empty"))

    construct(p, pt, pf) ==
      construct(p, pt, pf)$Rep

    pred d == d.d_pred
    ptrue d == d.d_ptrue
    pfalse d == d.d_pfalse

    coerce d ==
      if d.d_pfalse case "empty" then
        pile([hconcat ["if ", d.d_pred :: OutputForm],
              hconcat [hspace 1, "then ", d.d_ptrue :: OutputForm]])
      else
        pile([hconcat ["if ", d.d_pred :: OutputForm],
              hconcat [hspace 1, "then ", d.d_ptrue :: OutputForm],
              hconcat [hspace 1, "else ", d.d_pfalse :: OutputForm]])

)abbrev package SPTFTOR SpadFunctorType
SpadFunctorType(T : Parsable) : Parsable with
    name : % -> Symbol
    args : % -> List(T)
    construct : (Symbol, List(T)) -> %
  == add
    -- parametrem funktora może być wartość (dowolna)
    FunctorType(T) ==>
      Record(ft_name : Symbol, ft_args : List(T))
    rep(x) ==> (x pretend FunctorType(T))

    args x == rep(x).ft_args
    name x == rep(x).ft_name

    construct(n, al) == [n, al]$FunctorType(T) pretend %

    parse ex ==
      args : List(T) := [ parse e for e in destruct cdr(ex) ]
      [ symbol car ex, args ]

    coerce(ftor : %) : OutputForm ==
      name' := (name ftor) :: OutputForm
      args' := [ t :: OutputForm for t in (args ftor) ]
      empty? args' => name'
      hconcat [ name', paren args' ]

)abbrev package SPTMAP SpadMappingType
SpadMappingType(T : Parsable) : Parsable with
    args : % -> List(T)
    type : % -> T
    construct : (List(T), T) -> %
  == add
    MappingType(T) ==>
      Record(m_args : List(T), m_type : T)
    rep(x) ==> (x pretend MappingType(T))

    import SExpressionHelper

    args x == rep(x).m_args
    type x == rep(x).m_type

    construct(al, t) == [al, t]$(MappingType T) pretend %

    parseFunType : SExpression -> T
    parseFunType s ==
      if firstSymbol? (s, ':) then parse s.3 else parse s
        
    parse ex ==
      sig : List(T) := reverse [ parseFunType e for e in destruct cdr ex ]
      [ reverse(rest sig), first sig ]

    coerce(mapping : %) : OutputForm ==
      ts := [t :: OutputForm for t in (args mapping)]
      if #ts > 1
        then hconcat [paren ts, " -> ", (type mapping) :: OutputForm]
        else hconcat [first ts, " -> ", (type mapping) :: OutputForm]

)abbrev package SPTSUM SpadSumType
SpadSumType(T : Parsable) : Parsable with
    elt : (%, "types") -> List(T)
    elt : (%, "kind") -> Union("join", "domain", "package", "list")
    construct : (Union("join", "domain", "package", "list"), List(T)) -> %
  == add
    SumType(T) ==>
      Record(s_kind : Union("join", "domain", "package", "list"), s_types : List(T))
    rep(x) ==> (x pretend SumType(T))

    import SExpressionHelper

    elt(x, "kind") == rep(x).s_kind
    elt(x, "types") == rep(x).s_types

    construct(k, tl) == [k, tl]$(SumType T) pretend %

    parse ex ==
      lst :=
        domain? ex or package? ex =>
          -- (CATEGORY domain ...)
          -- (CATEGORY package ...)
          destruct cdr(cdr(ex))
        join? ex or progn? ex =>
          -- (Join ...)
          -- (PROGN ...)
          destruct cdr(ex)

      args : List(T) := [ parse e for e in lst ]

      domain? ex => ["domain", args]
      package? ex => ["package", args]
      join? ex => ["join", args]
      progn? ex => ["list", args]

    coerce(sum : %) : OutputForm ==
      ts := [ t :: OutputForm for t in sum.types ]
      sum.kind case "join" => hconcat ["Join(", pile ts, ")"]
      pile [hconcat["{", pile ts], "}"]

)abbrev package SPTSIG SpadSignatureType
SpadSignatureType(T : Parsable) : Parsable with
    elt : (%, "name") -> Symbol
    elt : (%, "type") -> SpadMappingType(T)
    construct : (Symbol, SpadMappingType T) -> %
  == add
    SignatureType(T) ==>
      Record(s_name : Symbol, s_type : SpadMappingType(T))
    rep(x) ==> (x pretend (SignatureType T))

    elt(x, "name") == rep(x).s_name
    elt(x, "type") == rep(x).s_type

    construct(n, t) == [n, t]$(SignatureType T) pretend %

    parse ex ==
      -- (SIGNATURE name (RetType Arg1Type Arg2Type ...))
      -- (SIGNATURE name Type constant)
      res : T := parse(car ex.3)
      targs : List(T) := if #ex = 3
        then [ parse e for e in destruct(cdr ex.3) ]
        else [ parse ex.4 ]
      [ symbol ex.2, construct(targs, res) ]

    coerce(sig : %) : OutputForm ==
      hconcat [sig.name :: OutputForm, " : ", sig.type :: OutputForm]

)abbrev package SPTNAMED SpadNamedType
SpadNamedType(T : Parsable) : Parsable with
    elt : (%, "name") -> Symbol
    elt : (%, "type") -> T
    construct : (Symbol, T) -> %
    parse : SExpression -> %
  == add
    NamedType(T) ==>
      Record(n_name : Symbol, n_type : T)
    rep(x) ==> (x pretend (NamedType T))

    import SExpression

    elt(x, "name") == rep(x).n_name
    elt(x, "type") == rep(x).n_type

    construct(n, t) == [n, t]$(NamedType T) pretend %

    parse ex ==
      -- (: field Type)
      [ symbol ex.2, (parse ex.3) $ T ]

    coerce(field : %) : OutputForm ==
      hconcat [field.name :: OutputForm, " : ", field.type :: OutputForm]

)abbrev package SPTREC SpadRecordType
SpadRecordType(T : Parsable) : Parsable with
    elt : (%, "fields") -> List SpadNamedType(T)
    construct : List SpadNamedType(T) -> %
    parse : SExpression -> %
  == add
    Rep := List SpadNamedType(T)

    elt(x, "fields") == x pretend List SpadNamedType(T)

    construct fl == fl pretend %

    parse ex ==
      -- (Record (: field1 Type1) (: field2 Type2) ...)
      construct [parse e for e in destruct cdr ex]

    coerce(record : %) : OutputForm ==
      hconcat ["Record", paren [f :: OutputForm for f in record]]

)abbrev package SPTUNION SpadUnionType
SpadUnionType(T : Parsable) : Parsable with
    elt : (%, "variants") -> List Union(T, SpadNamedType(T))
    construct : List Union(T, SpadNamedType(T)) -> %
  == add
    Rep := List Union(T, SpadNamedType(T))

    import SExpressionHelper

    elt(x, "variants") == x pretend List Union(T, SpadNamedType(T))

    construct fl == fl pretend %

    parseUnionField : SExpression -> Union(T, SpadNamedType(T))
    parseUnionField s ==
      var? s => construct(symbol s.2, parse s.3) $ SpadNamedType(T)
      (parse s) $ T

    parse ex ==
      -- (Union (: field1 Type1) (: field2 Type2) ...)
      -- (Union Type1 Type2 ...)
      construct [parseUnionField e for e in destruct cdr ex]

    coerce_field : Union(T, SpadNamedType(T)) -> OutputForm
    coerce_field f ==
      f case T => (f :: T) :: OutputForm
      (f :: SpadNamedType(T)) :: OutputForm

    coerce(union : %) : OutputForm ==
      hconcat ["Union", paren [coerce_field v for v in union.variants]]

)abbrev package SPTYPE SpadType
++ SPAD type representation
SpadType() : Parsable with
    empty : %
    unknownType? : % -> Boolean
    functorType? : % -> Boolean
  == add
    DependentType := Dependent(SExpression, %)

    Rep := Union(sum : SpadSumType(%),
                 record : SpadRecordType(%),
                 union : SpadUnionType(%),
                 deptype : DependentType,
                 functor : SpadFunctorType(%),
                 mapping : SpadMappingType(%),
                 signature : SpadSignatureType(%),
                 singleton : String,
                 integer : Integer,
                 unknown : "unknown")

    import SExpressionHelper
    import OutputForm
    import OutputFormHelper

    empty == construct("unknown")

    unknownType? t == t case unknown
    functorType? t == t case functor

    parse ex ==
      -- print (hconcat ["type: ", ex :: OutputForm])

      null? ex => ["unknown"]
      string? ex => [string ex]
      integer? ex => [integer ex]
      symbol? ex => [construct(symbol ex, [])]

      signature? ex =>
        [(parse ex) $ SpadSignatureType(%)]
      record? ex =>
        [(parse ex) $ SpadRecordType(%)]
      union? ex => 
        [(parse ex) $ SpadUnionType(%)]
      var? ex or mapping? ex => 
        [(parse ex) $ SpadMappingType(%)]
      domain? ex or package? ex or join? ex or progn? ex =>
        [(parse ex) $ SpadSumType(%)]

      ifelse? ex =>
        (spred, strue, sfalse) := (ex.2, ex.3, ex.4)
        nobranch? sfalse =>
          construct(construct(spred, parse strue, "empty"))
        construct(construct(spred, parse strue, parse sfalse))

      [(parse ex) $ SpadFunctorType(%)]

    coerce(type : %) : OutputForm ==
      type case record => type.record :: OutputForm
      type case union => type.union :: OutputForm
      type case singleton => type.singleton :: OutputForm
      type case integer => type.integer :: OutputForm
      type case signature => type.signature :: OutputForm
      type case deptype => type.deptype :: OutputForm
      type case sum => type.sum :: OutputForm
      type case functor => type.functor :: OutputForm
      type case mapping => type.mapping :: OutputForm
      ""

)abbrev package SPIMP SpadImport
++ SPAD domain / category / package import declaration
SpadImport() : SetCategory with
    parse : SExpression -> %
      ++ parse(ex)
  == add
    import OutputForm

    parse ex ==
      (parse ex.2)$SpadType pretend %

    coerce ex ==
      hconcat ["import ", (ex pretend SpadType) :: OutputForm]

)abbrev package SPVAR SpadVariable
++ SPAD variable declaration representation
SpadVariable() : SetCategory with
    construct : (Symbol, SpadType) -> %
      ++ construct(name,type)
    construct : Symbol -> %
      ++ construct(name)
    parse : SExpression -> %
      ++ parse(ex)
    name : % -> Symbol
  == add
    Rep := Record(arg_name : Symbol, arg_type : SpadType)

    import OutputForm
    import OutputFormHelper
    import SExpressionHelper

    construct(name, type) ==
      construct(name, type)$Rep

    construct name ==
      construct(name, empty)$Rep

    parse ex ==
      --print (hconcat ["variable: ", ex :: OutputForm])

      var? ex =>
        construct(symbol ex.2, parse ex.3)
      symbol? ex =>
        construct(symbol ex)

      print "------"
      print (ex :: OutputForm)
      error "not a variable definition"

    coerce var ==
      name := var.arg_name :: OutputForm
      type := var.arg_type
      typename : OutputForm :=
        if unknownType? type
          then "?"
          else type :: OutputForm
      spaces [name, ":", typename]

    name var ==
      var.arg_name

)abbrev package SPEXPR SpadExpression
++ SPAD generic expression
SpadExpression() : SetCategory with
    parse : SExpression -> %
      ++ parse(ex) parses s-expression into SpadExpression
  == add
    SAssign := Record(lval : %, rval : %)
    SCoerce := Record(exp : %, kind : Symbol, type : SpadType)
    SIterator := Record(i_var : Symbol, i_seq : %)
    SLoop := Record(l_type : Union("loop", "collect"), l_itor : List SIterator, l_guard : List %, l_body : %)
    SIfElse := Dependent(%, %)
    SLambda := Record(f_args : List Symbol, f_type : SpadType, f_body : %)
    SApply := Record(a_fun : %, a_args : List %)
    SSeq := Record(s_type : Union("prog", "list", "tuple"), s_expr : List %)
    SRange := Record(start : %, end : Union(%, "infinity"), step : %)
    STypeOf := Record(t_kind : Union("case", "has", "is", ":"), t_expr : %, t_type : SpadType)

    Rep := Union(seq : SSeq,
                 lambda : SLambda,
                 apply : SApply,
                 assign : SAssign,
                 coerce : SCoerce,
                 loop : SLoop,
                 ifelse : SIfElse,
                 type : SpadType,
                 typeof : STypeOf,
                 range : SRange,
                 dfloat : DoubleFloat,
                 integer : Integer,
                 symbol : Symbol,
                 string : String)

    import OutputForm
    import OutputFormHelper
    import SExpression
    import SExpressionHelper
    import SpadVariable

    parse ex ==
      -- czemu odkomentowanie linii niżej wywala kompilację ?
      -- print (hconcat ["expression: ", ex :: OutputForm])
      -- print (ex :: OutputForm)

      seq? ex =>
        -- {sequence of expressions}
        -- (SEQ expr1 expr2 ...)
        construct(["prog", [parse e for e in destruct cdr ex]])

      tuple? ex =>
        -- {tuple constructor}
        -- (@Tuple expr1 expr2 ...)
        construct(["tuple", [parse e for e in destruct cdr ex]])

      lambda? ex =>
        -- (+-> arg body)
        not list? ex.2 =>
          lt := convert [convert '_:, convert [], convert []]
          construct [[symbol ex.2], (parse lt)$SpadType, parse ex.3]

        -- (+-> (: (: arg Type) RetType) body) 
        -- (+-> (: (@Tuple (: arg1 Type1) (: arg2 Type2)) RetType) body)
        t := cdr ex.2
        (ltype, rtype) := destruct t

        args := if tuple? ltype then destruct cdr(ltype) else [ltype]

        arg_name := (s : SExpression) : Symbol +->
          symbol(if list? s then s.2 else s)
        arg_type := (s : SExpression) : SExpression +->
          if list? s then s.3 else convert []

        lsig :=
          convert cons(convert '_:, append([arg_type arg for arg in args], [rtype]))
        largs := [arg_name arg for arg in args]
        construct [largs, parse lsig, parse ex.3]

      var? ex =>
        -- {expression with type annotation}
        -- (: expr Type) 
        construct([":", parse ex.2, parse ex.3])

      case? ex => 
        -- {expression with "case" operator}
        -- (case expr Type)
        construct(["case", parse ex.2, parse ex.3])

      has? ex => 
        -- {expression with "has" operator}
        -- (has expr Type)
        construct(["has", parse ex.2, parse ex.3])

      is? ex => 
        -- {expression with "is" operator}
        -- (is expr Type)
        construct(["is", parse ex.2, parse ex.3])

      let? ex =>
        -- {assignment}
        -- (LET expr value)
        construct([parse ex.2, parse ex.3])

      ifelse? ex =>
        -- {if-then-else expression of if-then statement}
        -- (IF condition expr1 expr2)
        -- (IF condition expr 'noBranch)
        -- (IF condition 'noBranch expr)
        (c, l, r) := (ex.2, ex.3, ex.4)
        sc : SIfElse :=
          nobranch? l =>
            pc := parse (convert [convert '_not, c])
            construct(pc, parse r, "empty")
          nobranch? r =>
            construct(parse c, parse l, "empty")
          construct(parse c, parse l, parse r)
        construct sc

      coerce? ex =>
        -- {coerce, select, cast expression}
        -- (:: expr Type)
        -- (@ expr Type)
        -- (pretend expr Type)
        construct([parse ex.2, symbol ex.1, parse ex.3] $ SCoerce)

      collect? ex or loop? ex =>
        lst := destruct cdr ex
        body := parse(last lst)
        lst := reverse(rest(reverse(lst)))

        -- print hconcat [(car ex) :: OutputForm, paren [e :: OutputForm for e in lst]]

        range : SRange
        itors : List SIterator := []
        guards : List % := []

        for e in lst repeat
          -- upewnić się ze strażnikami, w collect też może być while
          itor? e =>
            -- (IN item sequence)
            itors := cons([symbol e.2, parse e.3], itors)
          step? e =>
            -- (STEP i m k n) -> i := m..n by k
            -- (STEP i m k) -> i := m.. by k
            range := if #e = 4
              then  [parse e.3, "infinity", parse e.4]
              else  [parse e.3, parse e.5, parse e.4]
            itors := cons([symbol e.2, construct range], itors)
          guard? e or while? e =>
            -- should they be mixed together ?
            -- ('| cond)
            -- (WHILE cond)
            guards := cons(parse e.2, guards)
          print "------"
          print (e :: OutputForm)
          error "unrecognized loop construct"

        reverse!(itors)
        reverse!(guards)

        #guards > 1 => error "loop: more than one guard!"

        if collect? ex
          then construct ["collect", itors, guards, body]
          else construct ["loop", itors, guards, body]

      record? ex or union? ex =>
        stype : SpadType := parse ex
        construct(stype)

      list? ex and #ex > 0 =>
        l := [parse e for e in destruct ex]
        symbol? ex.1 and symbol ex.1 = 'construct =>
          construct(["list", rest l])
        construct([first l, rest l])

      string? ex =>
        construct(string ex)

      symbol? ex =>
        construct(symbol ex)

      integer? ex =>
        construct(integer ex)

      float? ex =>
        construct(float ex)

      null? ex =>
        construct(["list", []])

      print "------"
      print (ex :: OutputForm)
      error "s-expression not handled"

    coerce (ex : %) : OutputForm ==
      ex case range =>
        r := ex.range
        (rstart, rend, rstep) := 
          (r.start :: OutputForm, r.end :: OutputForm, r.step :: OutputForm)
        ofs : List OutputForm := [ rstart, ".." ]
        if not(r.end case "infinity") then
          ofs := concat(ofs, [rend])
        if not(r.step case integer and r.step.integer = 1) then
          ofs := concat(ofs, ["by", rstep])
        spaces ofs
      ex case lambda =>
        hconcat(["function ", paren [e :: OutputForm for e in ex.lambda.f_args],
                 " : ", ex.lambda.f_type :: OutputForm,
                 " == ", ex.lambda.f_body :: OutputForm])
      ex case seq =>
        lst := [ e :: OutputForm for e in ex.seq.s_expr ]
        ex.seq.s_type case "prog" => pile lst
        ex.seq.s_type case "list" => bracket lst
        ex.seq.s_type case "tuple" => paren lst
      ex case apply =>
        fun := ex.apply.a_fun
        args := [ a :: OutputForm for a in ex.apply.a_args ]
        if fun case symbol then
          fun.symbol = 'QUOTE =>
            return hconcat ["'", :args]
          fun.symbol = 'elt =>
            return hconcat [first args, ".", last args]
          fun.symbol = 'exit =>
            return hconcat ["exit{", first args, "}", "(", last args, ")"]
          fun.symbol = 'return =>
            return hconcat ["return{", first args, "}", "(", last args, ")"]
          if #args = 0 then
            fun.symbol = 'Zero => return "0"
            fun.symbol = 'One => return "1"
          if #args = 2 and member?(fun.symbol, ['_-, '_+, '_*, '_/, '_^, '_=, '_~_=, '_<, '_>, '_<_=, '_>_=]) then
            return paren spaces([ args.1 :: OutputForm,
                                  fun.symbol :: OutputForm,
                                  args.2 :: OutputForm ])
        #args = 0 => fun :: OutputForm
        hconcat [fun :: OutputForm, paren args]
      ex case coerce =>
        paren spaces([ex.coerce.exp :: OutputForm,
                      ex.coerce.kind :: OutputForm,
                      ex.coerce.type :: OutputForm])
      ex case loop =>
        itors := [ hconcat [ "for ", e.i_var :: OutputForm, " in ", e.i_seq :: OutputForm ]
                   for e in ex.loop.l_itor ]
        guards := [ spaces ["if", e :: OutputForm] for e in ex.loop.l_guard ]
        body := ex.loop.l_body :: OutputForm
        ex.loop.l_type case "loop" =>
          if empty? itors
            then
              loop_cond := separateBy([e :: OutputForm for e in ex.loop.l_guard ], " and ")
              pile([hconcat ["while ", loop_cond],
                    hconcat [hspace 1, "repeat ", body]])
            else
              pile([hconcat [spaces concat(itors, guards)],
                    hconcat [hspace 1, "repeat ", body]])
        ex.loop.l_type case "collect" =>
          spaces ["[", body, spaces concat(itors, guards), "]"]
      ex case ifelse =>
        ex.ifelse :: OutputForm
      ex case typeof =>
        hconcat([ex.typeof.t_expr :: OutputForm, " ", 
                 ex.typeof.t_kind :: OutputForm, " ",
                 ex.typeof.t_type :: OutputForm])
      ex case assign =>
        hconcat [ex.assign.lval :: OutputForm, " := ", ex.assign.rval :: OutputForm]
      ex case type =>
        ex.type :: OutputForm
      ex case string =>
        ex.string :: OutputForm
      ex case symbol =>
        ex.symbol :: OutputForm
      ex case dfloat =>
        ex.dfloat :: OutputForm
      ex case integer =>
        ex.integer :: OutputForm

      print "------"
      print (ex :: OutputForm)
      error "not handled"

)abbrev package SPFN SpadFunction
++ SPAD function
SpadFunction() : SetCategory with
    construct : (Symbol, List SpadVariable, SpadType, SpadExpression) -> %
      ++ construct(name,varlist,type,exp)
    parse : SExpression -> %
      ++ parse(ex) parses s-expression into a SpadFunction
  == add
    Rep := Record(fn_name : Symbol,
                  fn_args : List Union(String, SpadVariable),
                  fn_type : SpadType,
                  fn_body : SpadExpression)

    import OutputForm
    import SExpressionHelper
    import SpadVariable
    import SpadExpression

    construct(name, args, type, body) == 
      [name, args, type, body] $ Rep

    parse_arg : (SExpression, SExpression) -> Union(String, SpadVariable)
    parse_arg(s, t) ==
      string? s =>
        string s
      construct(symbol s, parse t)

    parse ex ==
      -- print (hconcat ["function: ", ex :: OutputForm])

      function? ex =>
        name := symbol car(ex.2)
        arg_names := destruct cdr(ex.2)
        arg_types := destruct cdr(ex.3)
        args := [ parse_arg(s, t) for s in arg_names for t in arg_types ]
        type := car ex.3
        body := ex.5
        pbody : SpadExpression := (parse body)$SpadExpression
        construct(name, args, parse type, pbody)

      print "------"
      print (ex :: OutputForm)
      error "not a function"

    coerce fn ==
      args := [ arg :: OutputForm for arg in fn.fn_args ]
      body := [ fn.fn_body :: OutputForm ]
      ret_type := if unknownType? fn.fn_type
        then "" :: OutputForm
        else hconcat([" : ", fn.fn_type :: OutputForm])
      hconcat([fn.fn_name :: OutputForm,
               paren args, ret_type,
               " == ", pile body, ""])

)abbrev package SPMACRO SpadMacro
++ SPAD macro representation
SpadMacro() : SetCategory with
    construct : (Symbol, List Symbol, SExpression) -> %
      ++ construct(name,args,exp)
    parse : SExpression -> %
      ++ parse(ex)
  == add
    Rep := Record(md_name : Symbol,
                  md_args : List Symbol,
                  md_body : SExpression)

    import OutputForm
    import SExpressionHelper

    construct(name, args, body) ==
      construct(name, args, body)$Rep

    parse ex ==
      --print (hconcat ["macro: ", ex :: OutputForm])

      macro? ex =>
        name := symbol car(ex.2)
        args := [ symbol s for s in destruct(cdr(ex.2)) ]
        body := ex.5
        construct(name, args, body)

      print "------"
      print (ex :: OutputForm)
      error "not a macro definition"

    coerce m ==
      args := [ arg :: OutputForm for arg in m.md_args ]
      margs := 
        if null m.md_args
          then "" :: OutputForm
          else paren args
      hconcat([m.md_name :: OutputForm,
               margs, " ==> ", pile [m.md_body :: OutputForm]])

)abbrev package SPCAPS SpadCapsule
++ SPAD capsule representation
SpadCapsule() : SetCategory with
    parse : SExpression -> %
      ++ parse(sex)
  == add
    DependentCapsule := 
      Record(c_pred : SpadExpression, c_true : %, c_false : Union(%, "empty"))
    CapsuleContent :=
      Union(SpadVariable, SpadExpression, SpadMacro, SpadFunction, SpadImport, DependentCapsule) -- czy nie połączyć z ciałem funkcji

    Rep := List CapsuleContent

    import OutputForm
    import SExpressionHelper
    import SpadFunction
    import SpadMacro
    import SpadVariable

    parse ex ==
      -- print (hconcat ["capsule: ", ex :: OutputForm])

      content : List CapsuleContent := []
      sfun : SpadFunction 
      smacro : SpadMacro 
      svar : SpadVariable
      sexp : SpadExpression
      simp : SpadImport
      sdep : DependentCapsule

      for e in destruct ex repeat
        if exit? e then e := e.3

        function? e =>
          sfun := parse e
          content := [sfun, :content]

        macro? e =>
          smacro := parse e
          content := [smacro, :content]

        var? e =>
          if listof? e.2
            then
              -- (: (LISTOF x y z ...) Type)
              varlst := destruct(cdr e.2)
              for var in varlst repeat
                svar := construct(symbol var, parse e.3)
                content := [svar, :content]
            else
              svar := parse e
              content := [svar, :content]

        let? e =>
          sexp := parse e
          content := [sexp, :content]

        import? e =>
          simp := parse e
          content := [simp, :content]

        ifelse? e =>
          cpred : SpadExpression := parse e.2
          ctrue : %
          cfalse : Union(%, "empty")

          (strue, sfalse) := (e.3, e.4)

          ctrue :=
            seq? strue => parse cdr strue
            parse convert [strue]
          cfalse :=
            nobranch? sfalse => "empty"
            seq? sfalse => parse cdr sfalse
            parse convert [sfalse]
        
          content := [construct(cpred, ctrue, cfalse), :content]

        print "---" :: OutputForm
        print "inside capsule but not handled:"
        print (e :: OutputForm)

      construct(reverse content)

    coerce c ==
      ofs : List OutputForm := []

      for i in c repeat
        i case DependentCapsule =>
          of := pile(
            if i.c_false = "empty" then
              [hconcat ["if ", i.c_pred :: OutputForm],
               hconcat [hspace 1, "then ", i.c_true :: OutputForm]]
            else
              [hconcat ["if ", i.c_pred :: OutputForm],
               hconcat [hspace 1, "then ", i.c_true :: OutputForm],
               hconcat [hspace 1, "else ", i.c_false :: OutputForm]])
          ofs := [of, :ofs]
        ofs := [i :: OutputForm, :ofs]

      hconcat [hspace 2, pile reverse ofs]

)abbrev package SPFTOR SpadFunctor
++ SPAD functor representation
SpadFunctor() : SetCategory with
    parse : SExpression -> %
      ++ parse(sex)
  == add
    Rep := Record(f_name : Symbol,
                  f_args : List SpadVariable,
                  f_type : SpadType,
                  f_extends : SpadType,
                  f_capsule : SpadCapsule)

    import OutputForm
    import SExpressionHelper
    import SpadCapsule

    parse ex ==
      --print (hconcat ["functor: ", ex :: OutputForm])

      functor? ex =>
        name := symbol car(ex.2)
        arg_names := destruct cdr(ex.2)
        arg_types := destruct cdr(ex.3)
        args := [ construct(symbol s, parse t)$SpadVariable 
                  for s in arg_names for t in arg_types ]
        type := car ex.3
        body := ex.5
        capsule := 
          if symbol(car body) = 'add then body.3 else body
        extends :=
          if symbol(car body) = 'add then body.2 else convert []
        construct(name, args, parse type, parse extends, parse cdr capsule)

      print "------"
      print (ex :: OutputForm)
      error "not a functor"

    coerce f ==
      args := [ arg :: OutputForm for arg in f.f_args ]
      blankSeparate(
        [ f.f_name :: OutputForm,
          paren args, ":", 
          hconcat [hspace 2, f.f_type :: OutputForm],
          "==", f.f_extends :: OutputForm, "add",
          f.f_capsule :: OutputForm])

)abbrev package STMEXP SpadTreeMacroExpander
SpadTreeMacroExpander() : with
    expand : SpadFunctor -> SpadFunctor
    expand : SpadType -> SpadType
    expand : SpadExpression -> SpadExpression
  == add
    import SpadCapsule

    env : List SpadMacro

    expand (st : SpadType) : SpadType == st
      --st case sum =>
      --  construct(st.sum.kind, [expand t for t in st.sum.types]) $ ?
      --st case record =>
      --  construct(...) $ RecordType
      --st case union =>
      --  construct(...) $ UnionType
      --st case deptype =>
      --  dt := st.deptype
      --  construct(pred dt, expand ptrue dt, expand pfalse dt) $ DependentType
      --st case functor =>
      --  ft := st.functor
      --  construct(ft.ft_name, [expand e for e ft.ft_args])$ FunctorType
      --st case mapping =>
      --  mt := st.mapping
      --  construct([expand e for e in mt.m_args], expand mt.m_type) $ MappingType
      --st case signature =>
      --  sig := st.signature
      --  construct(sig.sig_name, expand sig.sig_type) $ SignatureType
      --
      --st

    expand (ex : SpadExpression) : SpadExpression == ex
      --ex case seq =>
      --  construct(ex.s_type, [expand e for e in ex.s_sexpr]) $ SSeq
      --ex case lambda =>
      --  construct(ex.f_args, expand ex.f_type, expand ex.f_body) $ SLambda
      --ex case apply =>
      --  construct(expand ex.a_fun, [expand e for e in a_args]) $ SApply
      --  -- handle case where ex.a_fun is Symbol
      --ex case assign =>
      --  construct(expand ex.lval, expand ex.rval) $ SAssign
      --ex case coerce =>
      --  construct(expand ex.exp, ex.kind, expand ex.type) $ SCoerce
      --ex case loop =>
      --  construct(ex.l_type,
      --            [expand e for e in ex.l_itor],
      --            [expand e for e in ex.l_guard],
      --            expand ex.l_body) $ SLoop
      --ex case ifelse =>
      --  construct(expand pred ex, expand ptrue ex, expand pfalse ex) $ SIfElse
      --ex case type =>
      --  expand ex
      --ex case typeof =>
      --  construct(ex.t_kind, expand ex.t_expr, expand ex.t_type) $ STypeOf
      --ex case range =>
      --  ex.end case "infinity" =>
      --    construct(expand ex.start, "infinity", expand ex.step)$SRange
      --  construct(expand ex.start, expand ex.end, expand ex.step)$SRange
      --ex case symbol =>
      --  sex := find(ex, env)
      --  if sex case "failed" then
      --    ex
      --  else
      --    parse ex
      --
      --ex

    expand (f : SpadFunctor) : SpadFunctor == f
      -- old_env := copy env
      --
      --caps := f.capsule
      --
      --for e in caps repeat
      --  if e case SpadMacro then
      --    env := cons(e,env)
      --  else
      --    expand e
      --
      --env := old_env

)abbrev package SPTYPCHK SpadTypeChecker
++ Author: Krystian Baclawski
++ Date Created: December 2013
++ Date Last Updated: January 2014
++ Description:
++ Experimental type checker with bottom-up approach.
SpadTypeChecker() : with
    check : SExpression -> Void 
      ++ check(sex) runs type checker for parse tree
  == add
    import SpadFunctor
    import OutputForm

    check e ==
      -- print (e :: OutputForm)

      -- na poziomie funkcji to nie działa:
      -- SF ==> SpadFunctor
      -- id (x : SExpression) : SExpression == x

      ftor : SpadFunctor := parse e
      print (ftor :: OutputForm)
