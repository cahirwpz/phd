)abbrev category STWALKC SpadTreeWalkerCategory
SpadTreeWalkerCategory() : Category == Definition where
  N ==> SpadNode
  APP ==> SpadApply(N)
  ASS ==> SpadAssign(N)
  CE ==> SpadCondExpr(N)
  SC ==> SpadCase(N)
  FN ==> SpadFunction(N)
  FT ==> SpadFunctor(N)
  IM ==> SpadImport(N)
  IT ==> SpadIterator(N)
  LP ==> SpadLoop(N)
  M ==> SpadMacro(N)
  MR ==> SpadMarker(N)
  NR ==> SpadNodeRef(N)
  MT ==> SpadMappingType(N)
  RT ==> SpadRecordType(N)
  SEG ==> SpadSegment(N)
  SEQ ==> SpadSequence(N)
  ST ==> SpadSubType(N)
  TC ==> SpadTypeCoerce(N)
  TD ==> SpadTypeDecl(N)
  TG ==> SpadTypeGuard(N)
  TEH ==> SpadTypeHas(N)
  TEI ==> SpadTypeIs(N)
  TEP ==> SpadTypePretend(N)
  TI ==> SpadTypeInfo(N)
  TO ==> SpadTypeOrigin(N)
  TS ==> SpadTypeSelect(N)
  TVL ==> SpadTypeValue(N)
  TV ==> SpadTypeVar(N)
  UT ==> SpadUnionType(N)
  W ==> SpadWhere(N)

  Definition ==> with
      gensym : () -> Symbol

      rewrite : APP -> N
      rewrite : ASS -> N
      rewrite : SC -> N
      rewrite : CE -> N
      rewrite : FN -> N
      rewrite : FT -> N
      rewrite : IM -> N
      rewrite : IT -> N
      rewrite : LP -> N
      rewrite : M -> N
      rewrite : MR -> N
      rewrite : MT -> N
      rewrite : NR -> N
      rewrite : RT -> N
      rewrite : SEG -> N
      rewrite : SEQ -> N
      rewrite : String -> N
      rewrite : Symbol -> N
      rewrite : ST -> N
      rewrite : TC -> N
      rewrite : TD -> N
      rewrite : TG -> N
      rewrite : TEH -> N
      rewrite : TEI -> N
      rewrite : TEP -> N
      rewrite : TI -> N
      rewrite : TO -> N
      rewrite : TS -> N
      rewrite : TVL -> N
      rewrite : TV -> N
      rewrite : UT -> N
      rewrite : W -> N
      rewrite : N -> N 
    add
      gensym() ==
        GENSYM()$Lisp

      rewrite (a : APP) : N ==
        nodeApp(rewrite a.function, [rewrite arg for arg in a.args])

      rewrite (a : ASS) : N ==
        nodeAssign(rewrite a.lval, rewrite a.rval)

      rewrite (cn : CE) : N ==
        nodeCondExpr(rewrite cn.cond, rewrite cn.truebr, rewrite cn.falsebr)

      rewrite (fn : FN) : N ==
        args' := [rewrite arg for arg in fn.args]
        nodeFun(fn.name, args', rewrite fn.type, rewrite fn.body)

      rewrite (ft : FT) : N ==
        nodeFtor(ft.name, [(rewrite [arg]) :: TD for arg in ft.args],
                 rewrite ft.type, rewrite ft.extends, rewrite ft.capsule)

      rewrite (im : IM) : N ==
        nodeImport(rewrite im.type)

      rewrite (it : IT) : N ==
        nodeIterator(it.var, rewrite it.seq)

      rewrite (lp : LP) : N ==
        nodeLoop(lp.kind, 
                 [rewrite itor for itor in lp.itors],
                 [rewrite guard for guard in lp.guards],
                 rewrite lp.body)

      rewrite (m : M) : N ==
        nodeMacro(m.name, m.args, rewrite m.body)

      rewrite (mr : MR) : N == [mr]

      rewrite (nr : NR) : N == [nr]

      rewrite (mt : MT) : N ==
        nodeMappingType([rewrite arg for arg in mt.args], rewrite mt.result)

      rewrite (rt : RT) : N ==
        nodeRecordType [(rewrite [f]) :: TD for f in fields rt]

      rewrite (seg : SEG) : N ==
        nodeSeg(rewrite seg.start, rewrite seg.end, rewrite seg.step)

      rewrite (s : SEQ) : N ==
        [collapse [s.kind, [rewrite n for n in s.list]]]

      rewrite (s : String) : N == [s]

      rewrite (s : Symbol) : N == [s]

      rewrite (te : SC) : N ==
        nodeCase(rewrite te.expr, rewrite te.type)

      rewrite (te : ST) : N ==
        nodeSubType(rewrite te.expr, rewrite te.type)

      rewrite (te : TC) : N ==
        nodeTypeCoerce(rewrite te.expr, rewrite te.type)

      rewrite (te : TD) : N ==
        nodeTypeDecl(rewrite te.expr, rewrite te.type)

      rewrite (te : TG) : N ==
        nodeTypeGuard(rewrite te.expr, rewrite te.type)

      rewrite (te : TEH) : N ==
        nodeTypeHas(rewrite te.expr, rewrite te.type)

      rewrite (te : TEI) : N ==
        nodeTypeIs(rewrite te.expr, rewrite te.type)

      rewrite (te : TEP) : N ==
        nodeTypePretend(rewrite te.expr, rewrite te.type)

      rewrite (ti : TI) : N ==
        nodeTypeInfo(ti.name, [rewrite(arg) :: TD for arg in ti.args],
                     [rewrite hasItem for hasItem in ti.hasList],
                     [rewrite constraint for constraint in ti.constraints],
                     rewrite(ti.body) :: SEQ)

      rewrite (te : TO) : N ==
        nodeTypeOrigin(rewrite te.expr, rewrite te.type)

      rewrite (te : TS) : N ==
        nodeTypeSelect(rewrite te.expr, rewrite te.type)

      rewrite (tv : TVL) : N ==
        nodeTypeValue(rewrite tv.type, rewrite tv.value)

      rewrite (tv : TV) : N == [tv]

      rewrite (ut : UT) : N ==
        nodeUnionType [rewrite v for v in variants ut]

      rewrite (w : W) : N ==
        nodeWhere(rewrite w.body, rewrite w.env)

      rewrite (n : N) : N ==
        apply? n => rewrite (n :: APP)
        assign? n => rewrite (n :: ASS)
        case? n => rewrite (n :: SC)
        condExpr? n => rewrite (n :: CE)
        function? n or lambda? n => rewrite (n :: FN)
        functor? n => rewrite (n :: FT)
        import? n => rewrite (n :: IM)
        iterator? n => rewrite (n :: IT)
        loop? n => rewrite (n :: LP)
        macro? n => rewrite (n :: M)
        mappingType? n => rewrite (n :: MT)
        marker? n => rewrite(n :: MR)
        nodeRef? n => rewrite (n :: NR)
        recordType? n => rewrite (n :: RT)
        segment? n => rewrite (n :: SEG)
        sequence? n => rewrite (n :: SEQ)
        string? n => rewrite (n :: String)
        symbol? n => rewrite (n :: Symbol)
        subType? n => rewrite (n :: ST)
        typeCoerce? n => rewrite (n :: TC)
        typeDecl? n => rewrite (n :: TD)
        typeGuard? n => rewrite (n :: TG)
        typeHas? n => rewrite (n :: TEH)
        typeIs? n => rewrite (n :: TEI)
        typeInfo? n => rewrite (n :: TI)
        typePretend? n => rewrite (n :: TEP)
        typeOrigin? n => rewrite (n :: TO)
        typeSelect? n => rewrite (n :: TS)
        typeValue? n => rewrite (n :: TVL)
        typeVar? n => rewrite (n :: TV)
        unionType? n => rewrite (n :: UT)
        where? n => rewrite (n :: W)
        -- skip integer, float and empty node
        integer? n or float? n or emptyNode? n => n
        error "rewrite: variant not handled"
