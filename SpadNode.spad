)abbrev category SNCAT SpadNodeCategory
SpadNodeCategory() : Category == ParsableCategory with
  construct : SpadApply(%) -> %
  construct : SpadAssign(%) -> %
  construct : SpadCase(%) -> %
  construct : SpadCondExpr(%) -> %
  construct : SpadFunction(%) -> %
  construct : SpadFunctor(%) -> %
  construct : SpadImport(%) -> %
  construct : SpadIterator(%) -> %
  construct : SpadLambda(%) -> %
  construct : SpadLoop(%) -> %
  construct : SpadMacro(%) -> %
  construct : SpadMappingType(%) -> %
  construct : SpadMarker(%) -> %
  construct : SpadNodeRef(%) -> %
  construct : SpadRecordType(%) -> %
  construct : SpadSegment(%) -> %
  construct : SpadSequence(%) -> %
  construct : SpadSubType(%) -> %
  construct : SpadTypeCoerce(%) -> %
  construct : SpadTypeDecl(%) -> %
  construct : SpadTypeGuard(%) -> %
  construct : SpadTypeHas(%) -> %
  construct : SpadTypeIs(%) -> %
  construct : SpadTypeOrigin(%) -> %
  construct : SpadTypePretend(%) -> %
  construct : SpadTypeSelect(%) -> %
  construct : SpadTypeVar(%) -> %
  construct : SpadUnionType(%) -> %
  construct : SpadWhere(%) -> %

  construct : DoubleFloat -> %
  construct : Integer -> %
  construct : String -> %
  construct : Symbol -> %

  emptyNode : () -> %

  apply? : % -> Boolean
  assign? : % -> Boolean
  capsule? : % -> Boolean
  case? : % -> Boolean
  condExpr? : % -> Boolean
  emptyNode? : % -> Boolean
  float? : % -> Boolean
  function? : % -> Boolean
  functor? : % -> Boolean
  import? : % -> Boolean
  integer? : % -> Boolean
  iterator? : % -> Boolean
  lambda? : % -> Boolean
  loop? : % -> Boolean
  macro? : % -> Boolean
  mappingType? : % -> Boolean
  marker? : % -> Boolean
  nodeRef? : % -> Boolean
  recordType? : % -> Boolean
  segment? : % -> Boolean
  sequence? : % -> Boolean
  signatureList? : % -> Boolean
  string? : % -> Boolean
  subType? : % -> Boolean
  symbol? : % -> Boolean
  typeAny? : % -> Boolean
  typeCoerce? : % -> Boolean
  typeDecl? : % -> Boolean
  typeExpr? : % -> Boolean
  typeGuard? : % -> Boolean
  typeHas? : % -> Boolean
  typeIs? : % -> Boolean
  typePretend? : % -> Boolean
  typeOrigin? : % -> Boolean
  typeSelect? : % -> Boolean
  typeUndef?: % -> Boolean
  typeVar? : % -> Boolean
  unionType? : % -> Boolean
  where? : % -> Boolean

  value? : % -> Boolean
  true? : % -> Boolean
  false? : % -> Boolean

  coerce : % -> DoubleFloat
  coerce : % -> Integer
  coerce : % -> String
  coerce : % -> Symbol

  coerce : % -> SpadApply(%)
  coerce : % -> SpadAssign(%)
  coerce : % -> SpadCase(%)
  coerce : % -> SpadCondExpr(%)
  coerce : % -> SpadFunction(%)
  coerce : % -> SpadFunctor(%)
  coerce : % -> SpadImport(%)
  coerce : % -> SpadIterator(%)
  coerce : % -> SpadLambda(%)
  coerce : % -> SpadLoop(%)
  coerce : % -> SpadMacro(%)
  coerce : % -> SpadMappingType(%)
  coerce : % -> SpadMarker(%)
  coerce : % -> SpadNodeRef(%)
  coerce : % -> SpadRecordType(%)
  coerce : % -> SpadSegment(%)
  coerce : % -> SpadSequence(%)
  coerce : % -> SpadSubType(%)
  coerce : % -> SpadTypeCoerce(%)
  coerce : % -> SpadTypeDecl(%)
  coerce : % -> SpadTypeGuard(%)
  coerce : % -> SpadTypeHas(%)
  coerce : % -> SpadTypeIs(%)
  coerce : % -> SpadTypeOrigin(%)
  coerce : % -> SpadTypePretend(%)
  coerce : % -> SpadTypeSelect(%)
  coerce : % -> SpadTypeVar(%)
  coerce : % -> SpadUnionType(%)
  coerce : % -> SpadWhere(%)

  convert : % -> SExpression

  constructor? : Symbol -> Boolean

  parseNonNull : SExpression -> %

)abbrev category STECAT SpadTypeExprCategory
SpadTypeExprCategory(N : SpadNodeCategory) : Category == ParsableCategory with
    construct : (N, N) -> %
    elt : (%, "expr") -> N
    elt : (%, "type") -> N
  add
    parse ex == [parse ex.2, parse ex.3]
    n = m == n.expr = m.expr and n.type = m.type

)abbrev domain SMARKER SpadMarker
SpadMarker(N : SpadNodeCategory) : Exports == Implementation where
  PF ==> PrintableForm

  Exports ==> ParsableCategory with
    construct : Union("%any", "%undef") -> %

  Implementation ==> add
    Rep := Union(any : "%any", undef : "%undef")

    import ParserTools

    construct s ==
      s case "%any" => ["%any"]$Rep
      s case "%undef" => ["%undef"]$Rep

    parse ex == 
      symbol ex.2 = 'any => ["%any"]$Rep
      symbol ex.2 = 'undef => ["%undef"]$Rep

    convert x ==
      s :=
        x case any => 'any
        x case undef => 'undef
      convert [convert("@Marker" :: Symbol), convert s]

    coerce (x : %) : PF ==
      x case any => "%any" :: PF 
      x case undef => "%undef" :: PF

    n = m ==
      EQUAL(n, m)$Lisp

)abbrev domain SNODEREF SpadNodeRef
SpadNodeRef(N : SpadNodeCategory) : Exports == Implementation where
  PI ==> PositiveInteger
  PF ==> PrintableForm

  Exports ==> ParsableCategory with
    construct : (PI, PI) -> %

    elt : (%, "major") -> PI
    elt : (%, "minor") -> PI

  Implementation ==> add
    Rep := Record(m_major : PI, m_minor : PI)

    import ParserTools

    construct(i : PI, j : PI) == [i, j]$Rep

    elt(x, "major") == x.m_major
    elt(x, "minor") == x.m_minor

    parse ex ==
      [(integer ex.2) :: PI, (integer ex.3) :: PI]

    convert x ==
      convert [convert("@NodeRef" :: Symbol), convert x.m_major, convert x.m_minor]

    coerce (x : %) : PF ==
      hconcat ["#" :: PF, x.m_major :: PF, "." :: PF, x.m_minor :: PF]

    x = y ==
      x.m_major = y.m_major and x.m_minor = y.m_minor

)abbrev domain STYPEVAR SpadTypeVar
SpadTypeVar(N : SpadNodeCategory) : Exports == Implementation where
  NNI ==> NonNegativeInteger
  PF ==> PrintableForm

  Exports ==> Join(ParsableCategory, OrderedSet) with
    construct : (NNI, NNI) -> %

    elt : (%, "major") -> NNI
    elt : (%, "minor") -> NNI

  Implementation ==> add
    Rep := Record(m_major : NNI, m_minor : NNI)

    import ParserTools

    construct(ma, mi) == [ma, mi]$Rep

    elt(x, "major") == x.m_major
    elt(x, "minor") == x.m_minor

    parse ex ==
      [(integer ex.2) :: NNI, (integer ex.3) :: NNI]

    convert x ==
      convert [convert('_@TypeVar), convert x.m_major, convert x.m_minor]

    coerce (x : %) : PF ==
      x.m_major = 0 and x.m_minor = 0 => "%" :: PF
      x.m_major = 0 => hconcat ["%" :: PF, x.m_minor :: PF]
      hconcat ["%" :: PF, x.m_major :: PF, "." :: PF, x.m_minor :: PF]

    x = y ==
      x.m_major = y.m_major and x.m_minor = y.m_minor

    x < y ==
      (x.m_major < y.m_major) or (x.m_major = y.m_major and x.m_minor < y.m_minor)

)abbrev domain SMTYPE SpadMappingType
SpadMappingType(N : SpadNodeCategory) : Exports == Implementation where
  PF ==> PrintableForm

  Exports ==> ParsableCategory with
    elt : (%, "args") -> List(N)
    elt : (%, "result") -> N
    construct : (List(N), N) -> %

  Implementation ==> add
    Rep := Record(m_args : List(N), m_result : N)

    import ParserTools
    import SExpression

    elt(x, "args") == x.m_args
    elt(x, "result") == x.m_result

    construct(al, t) == [al, t]$Rep

    parseFunType : SExpression -> N
    parseFunType s ==
      if firstSymbol? (s, ':) then parse s.3 else parse s
        
    parse ex ==
      sig : List(N) := [parseFunType e for e in destruct cdr ex]
      [rest sig, first sig]

    convert x ==
      ts := [convert t for t in [x.result, :x.args]]
      convert [convert ("Mapping" :: Symbol), :ts]

    coerce n ==
      coerceType (t : N) : PF ==
        if emptyNode? t then "?" :: PF else t :: PF
      ts := [coerceType t for t in n.args]
      src := if #ts ~= 1 then paren ts else first ts
      spaces [src, "->" :: PF, coerceType n.result]

    n = m ==
      n.result = m.result and n.args = m.args

)abbrev domain STDECL SpadTypeDecl
SpadTypeDecl(N : SpadNodeCategory) :SpadTypeExprCategory(N) == add
  MT ==> SpadMappingType(N)
  PF ==> PrintableForm

  import ParserTools

  Rep := Record(n_expr : N, n_type : N)

  elt(x, "expr") == x.n_expr
  elt(x, "type") == x.n_type

  construct(e : N, t : N) == [e, t]$Rep

  parse ex ==
    var? ex =>
      -- (: field Type)
      [parse(ex.2)$N, parseNonNull ex.3]
    symbol? ex =>
      [[symbol ex], emptyNode()]
    signature? ex =>
      -- (SIGNATURE name (RetType Arg1Type Arg2Type ...))
      -- (SIGNATURE name Type constant)
      -- (SIGNATURE (name) Type constant) ???
      name :=
        list? ex.2 => symbol ex.2.1
        symbol ex.2
      res : N := parse car ex.3
      targs : List(N) := if #ex = 3
        then [parse e for e in destruct cdr ex.3]
        else [parse ex.4]
      [[name], [[targs, res]$MT]]
    error "Cannot parse type declaration!"

  convert x ==
    if mappingType? x.type then
      convert [convert ("SIGNATURE" :: Symbol), convert x.expr, cdr convert x.type]
    else
      convert [convert (":" :: Symbol), convert x.expr, convert x.type]

  coerce n ==
    typeName := (emptyNode? n.type => "?" :: PF; n.type :: PF)
    spaces [n.expr :: PF, ":" :: PF, typeName]

)abbrev domain SRTYPE SpadRecordType
SpadRecordType(N : SpadNodeCategory) : Exports == Implementation where
  PF ==> PrintableForm
  TD ==> SpadTypeDecl(N)
  SEX ==> SExpression

  Exports ==> ParsableCategory with
    construct : List(TD) -> Union(%, "failed")
    fields : % -> List(TD)
    wellFormed? : % -> Boolean

  Implementation ==> add
    Rep := List(TD)

    import ParserTools
    import SExpression
    import Logger('Parser)

    construct x == (wellFormed? x => [x]$Rep; "failed")

    fields x == x :: Rep

    wellFormed? x ==
      names : List(Symbol) := []
      for f in fields x repeat ++ BUG? runtime crashes when using "x.fields"
        not (recordType? f.type or unionType? f.type or mappingType? f.type or
             apply? f.type or string? f.type or symbol? f.type or typeVar? f.type) =>
          warn ["Record has a field with wrong type:" :: PF, bold(f :: PF)]
          return false
        name := f.expr :: Symbol
        member?(name, names) =>
          warn (["Record has two fields with the same identifier" :: PF,
                 string bold(name :: PF), "!" :: PF])
          return false
        names := [name, :names]
      true

    parseField (field : SEX, ex : SEX) : TD ==
      not var? field =>
        fail (["Cannot parse a record type" :: PF, bold convert(ex),
               "- malformed field" :: PF, bold convert(field), "!":: PF])
        error ""
      [[symbol field.2], parse field.3]

    parse ex ==
      -- (Record (: field1 Type1) (: field2 Type2) ...)
      fields := [parseField(f, ex) for f in destruct cdr ex]
      wellFormed? fields => fields
      fail ["Malformed record type" :: PF, bold(fields :: PF), "!" :: PF]
      error ""

    convert x ==
      convert [convert ("Record" :: Symbol), :[convert f for f in fields x]]

    coerce x ==
      hconcat ["Record" :: PF, paren [f :: PF for f in fields x]]

    n = m ==
      #(fields n) ~= #(fields m) => false
      "and"/[nf = mf for nf in fields n for mf in fields m]

)abbrev domain SUTYPE SpadUnionType
SpadUnionType(N : SpadNodeCategory) : Exports == Implementation where
  TD ==> SpadTypeDecl(N)
  PF ==> PrintableForm
  SEX ==> SExpression

  Exports ==> ParsableCategory with
    construct : List(N) -> Union(%, "failed")
    variants : % -> List(N)
    wellFormed? : % -> Boolean

  Implementation ==> add
    Rep := List(N)

    import ParserTools
    import SExpression
    import Logger('Parser)

    construct x == (wellFormed? x => [x]$Rep; "failed")

    variants x == x :: Rep

    wellFormed? x ==
      ++ tagged union
      typeDecl? (first variants x) =>
        names : List(Symbol) := []
        for v in variants x repeat
          not typeDecl? v =>
            warn ("Mixing tagged and untagged variants is not allowed." :: PF)
            return false
          n := (v :: TD).expr :: Symbol
          t := (v :: TD).type
          not (recordType? t or unionType? t or mappingType? t or apply? t or
               string? t or symbol? t or typeVar? t) =>
            warn (["Unions has a variant" :: PF, string(n :: PF),
                   "with wrong type:" :: PF, t :: PF])
            return false
          member?(n, names) =>
            warn (["Union has two variants with the same identifier:" :: PF,
                   string(n :: PF)])
            return false
          names := [n, :names]
        true

      ++ untagged union
      types : List(N) := []
      for t in variants x repeat
        typeDecl? t =>
          warn ("Mixing tagged and untagged variants is not allowed." :: PF)
          return false
        not (recordType? t or unionType? t or mappingType? t or
             apply? t or string? t or symbol? t or typeVar? t) =>
          warn ["Union has a variant with wrong type:" :: PF, t :: PF]
          return false
        member?(t, types) =>
          warn ["Union has two variants with the same type:" :: PF, t :: PF]
          return false
        types := [t, :types]
      true

    parseVariant (s : SEX) : N ==
      var? s => [[[symbol s.2], parse s.3]$TD]
      parse s

    parse ex ==
      -- (Union (: field1 Type1) (: field2 Type2) ...)
      -- (Union Type1 Type2 ...)
      variants := [parseVariant e for e in destruct cdr ex]
      wellFormed? variants => variants
      fail ["Malformed union type:" :: PF, bold(variants :: PF), "!" :: PF]
      error ""

    convert x ==
      convert [convert ("Union" :: Symbol), :[convert v for v in variants x]]

    coerce x ==
      hconcat ["Union" :: PF, paren [v :: PF for v in variants x]]

    n = m ==
      #(variants n) ~= #(variants m) => false
      "and"/[nv = mv for nv in variants n for mv in variants m]

)abbrev domain SIMPORT SpadImport
++ SPAD domain / category / package import declaration
SpadImport(N : SpadNodeCategory) : Exports == Implementation where
  PF ==> PrintableForm

  Exports ==> ParsableCategory with
    elt : (%, "type") -> N
    construct : N -> %

  Implementation ==> add
    Rep := Record(i_type : N)

    import SExpression

    elt(x, "type") == x.i_type

    construct x == [x]$Rep

    parse ex ==
      [parse ex.2]

    convert x == convert [convert ("import" :: Symbol), convert x.type]

    coerce n ==
      spaces ["import" :: PF, n.type :: PF]

)abbrev domain SASSIGN SpadAssign
SpadAssign(N : SpadNodeCategory) : Exports == Implementation where
  PF ==> PrintableForm

  Exports ==> ParsableCategory with
    elt : (%, "lval") -> N
    elt : (%, "rval") -> N
    construct : (N, N) -> %

  Implementation ==> add
    Rep := Record(a_lval : N, a_rval : N)

    import SExpression

    elt(x, "lval") == x.a_lval
    elt(x, "rval") == x.a_rval

    construct(lv, rv) == [lv, rv]$Rep

    parse ex ==
      -- (LET expr value)
      [parse ex.2, parse ex.3]

    convert x ==
      convert [convert ("LET" :: Symbol), convert x.lval, convert x.rval]

    coerce n ==
      spaces [n.lval :: PF, ":=" :: PF, n.rval :: PF]

)abbrev domain SAPPLY SpadApply
SpadApply(N : SpadNodeCategory) : Exports == Implementation where
  PF ==> PrintableForm

  Exports ==> ParsableCategory with
    elt : (%, "function") -> N
    elt : (%, "args") -> List(N)
    construct : (N, List(N)) -> %

  Implementation ==> add
    Rep := Record(a_fn : N, a_args : List(N))

    import String
    import SExpression

    elt(x, "function") == x.a_fn
    elt(x, "args") == x.a_args

    construct (fn, lst) == [fn, lst]$Rep

    parse ex ==
      lst : List(N) := [parse e for e in destruct ex]
      [first lst, rest lst]

    convert x ==
      convert [convert i for i in [x.function, :x.args]]

    binop : List(Symbol) :=
      ['_-, '_+, '_*, '_/, '_^, '_=, '_~_=, '_<, '_>, '_<_=, '_>_=, 'OR, 'AND, 'or, 'and]

    coerce(n : %) : PF ==
      fun := n.function
      argl : List(PF) := [arg :: PF for arg in n.args]

      not (symbol? fun or nodeRef? fun) =>
        #argl = 0 => fun :: PF
        hconcat [paren(fun :: PF), paren argl]

      nodeRef? fun =>
        hconcat [fun :: PF, paren argl]

      sym := fun :: Symbol

      sym = 'QUOTE =>
        #argl = 1 => symbol(first argl)
        symbol paren(argl)
      sym = 'construct =>
        bracket argl
      sym = 'leave =>
        "break" :: PF
      sym = 'exit =>
        hconcat ["exit" :: PF, brace(first argl), paren(rest argl)]
      sym = 'return =>
        hconcat ["return" :: PF, brace(first argl), paren(rest argl)]
      #argl = 0 and sym = 'Zero => "0" :: PF
      #argl = 0 and sym = 'One => "1" :: PF
      #argl = 2 and member?(sym, binop) =>
        paren spaces [argl.1, (lowerCase string sym) :: PF, argl.2]

      -- handle attribute as functor
      sym = 'ATTRIBUTE => argl.1

      -- finally, process the application
      (constructor? sym) and (empty? argl) => sym :: PF
      hconcat [sym :: PF, paren argl]

    n = m ==
      #n.args ~= #m.args => false
      "and"/([f = g for f in [n.function, :n.args]
                    for g in [m.function, :m.args]])

)abbrev domain SSEGMENT SpadSegment
SpadSegment(N : SpadNodeCategory) : Exports == Implementation where
  PF ==> PrintableForm

  Exports ==> ParsableCategory with
    elt : (%, "start") -> N
    elt : (%, "end") -> N
    elt : (%, "step") -> N
    construct : (N, N) -> %
    construct : (N, N, N) -> %

  Implementation ==> add
    Rep := Record(r_start : N, r_end : N, r_step : N)

    import SExpression

    elt(x, "start") == x.r_start
    elt(x, "end") == x.r_end
    elt(x, "step") == x.r_step

    construct(f, l, s) == [f, l, s]$Rep
    construct(f, s) == [f, emptyNode(), s]$Rep

    parse ex ==
      -- (SEGMENT first last)
      [parse ex.2, parse ex.3]

    convert x ==
      convert [convert x.start, convert x.step, convert x.end]

    coerce n ==
      form : List(PF) := [".." :: PF, n.start :: PF]
      if not emptyNode? n.end then
        form := [n.end :: PF, :form]
      if integer? n.step and (n.step :: Integer) ~= 1 then
        form := [n.step :: PF, "by" :: PF, :form]
      spaces reverse form

)abbrev package SPITOR SpadIterator
SpadIterator(N : SpadNodeCategory) : Exports == Implementation where
  PF ==> PrintableForm

  Exports ==> ParsableCategory with
    elt : (%, "var") -> Symbol
    elt : (%, "seq") -> N
    construct : (Symbol, N) -> %

  Implementation ==> add
    Rep := Record(i_var : Symbol, i_seq : N)

    elt(x, "var") == x.i_var
    elt(x, "seq") == x.i_seq

    construct(v, s) == [v, s]$Rep

    convert x ==
      if segment? x.seq 
        then convert [convert ("STEP" :: Symbol), convert x.var, :(destruct convert x.seq)]
        else convert [convert ("IN" :: Symbol), convert x.var, convert x.seq]

    coerce itor ==
      spaces ["for" :: PF, itor.var :: PF, "in" :: PF, itor.seq :: PF]

)abbrev domain STSEL SpadTypeSelect
SpadTypeSelect(N : SpadNodeCategory) : SpadTypeExprCategory(N) == add
  PF ==> PrintableForm

  Rep := Record(t_expr : N, t_type : N)

  elt(x,"expr") == x.t_expr
  elt(x,"type") == x.t_type

  construct(e, t) == [e, t]$Rep
  convert x == convert [convert '_@, convert x.expr, convert x.type]
  coerce ex == spaces [ex.expr :: PF, '_@ :: PF, ex.type :: PF]

)abbrev domain SSUBTYPE SpadSubType
SpadSubType(N : SpadNodeCategory) : SpadTypeExprCategory(N) == add
  PF ==> PrintableForm

  Rep := Record(t_expr : N, t_type : N)

  elt(x,"expr") == x.t_expr
  elt(x,"type") == x.t_type

  construct(e, t) == [e, t]$Rep
  convert x == convert [convert '_<_:, convert x.expr, convert x.type]
  coerce ex == spaces [ex.expr :: PF, '_<_: :: PF, ex.type :: PF]

)abbrev domain SPRETEND SpadTypePretend
SpadTypePretend(N : SpadNodeCategory) : SpadTypeExprCategory(N) == add
  PF ==> PrintableForm

  Rep := Record(t_expr : N, t_type : N)

  elt(x,"expr") == x.t_expr
  elt(x,"type") == x.t_type

  construct(e, t) == [e, t]$Rep
  convert x == convert [convert '_pretend, convert x.expr, convert x.type]
  coerce ex == spaces [ex.expr :: PF, '_pretend :: PF, ex.type :: PF]

)abbrev domain STIS SpadTypeIs
SpadTypeIs(N : SpadNodeCategory) : SpadTypeExprCategory(N) == add
  PF ==> PrintableForm

  Rep := Record(t_expr : N, t_type : N)

  elt(x,"expr") == x.t_expr
  elt(x,"type") == x.t_type

  construct(e, t) == [e, t]$Rep
  convert x == convert [convert '_is, convert x.expr, convert x.type]
  coerce ex == spaces [ex.expr :: PF, '_is :: PF, ex.type :: PF]

)abbrev domain STHAS SpadTypeHas
SpadTypeHas(N : SpadNodeCategory) : SpadTypeExprCategory(N) == add
  PF ==> PrintableForm

  Rep := Record(t_expr : N, t_type : N)

  elt(x,"expr") == x.t_expr
  elt(x,"type") == x.t_type

  construct(e, t) == [e, t]$Rep
  convert x == convert [convert '_has, convert x.expr, convert x.type]
  coerce ex == spaces [ex.expr :: PF, '_has :: PF, ex.type :: PF]

)abbrev domain SCASE SpadCase
SpadCase(N : SpadNodeCategory) : SpadTypeExprCategory(N) == add
  PF ==> PrintableForm

  Rep := Record(t_expr : N, t_type : N)

  elt(x,"expr") == x.t_expr
  elt(x,"type") == x.t_type

  construct(e, t) == [e, t]$Rep
  convert x == convert [convert '_case, convert x.expr, convert x.type]
  coerce ex == spaces [ex.expr :: PF, '_case :: PF, ex.type :: PF]

)abbrev domain STCOERCE SpadTypeCoerce
SpadTypeCoerce(N : SpadNodeCategory) : SpadTypeExprCategory(N) == add
  PF ==> PrintableForm

  Rep := Record(t_expr : N, t_type : N)

  elt(x,"expr") == x.t_expr
  elt(x,"type") == x.t_type

  construct(e, t) == [e, t]$Rep
  convert x == convert [convert '_:_:, convert x.expr, convert x.type]
  coerce ex == spaces [ex.expr :: PF, '_:_: :: PF, ex.type :: PF]

)abbrev domain STGUARD SpadTypeGuard
SpadTypeGuard(N : SpadNodeCategory) : SpadTypeExprCategory(N) == add
  PF ==> PrintableForm

  Rep := Record(t_expr : N, t_type : N)

  elt(x,"expr") == x.t_expr
  elt(x,"type") == x.t_type

  construct(e, t) == [e, t]$Rep
  convert x == convert [convert '_|, convert x.expr, convert x.type]
  coerce ex == spaces [ex.expr :: PF,  '_| :: PF, ex.type :: PF]

)abbrev domain STORIGIN SpadTypeOrigin
SpadTypeOrigin(N : SpadNodeCategory) : SpadTypeExprCategory(N) == add
  PF ==> PrintableForm

  Rep := Record(t_expr : N, t_type : N)

  elt(x,"expr") == x.t_expr
  elt(x,"type") == x.t_type

  construct(e, t) == [e, t]$Rep
  parse ex == [parse ex.3, parse ex.2]
  convert x == convert [convert 'Sel, convert x.type, convert x.expr]
  coerce ex == spaces [ex.expr :: PF,  '_$ :: PF, ex.type :: PF]

)abbrev domain SLOOP SpadLoop
SpadLoop(N : SpadNodeCategory) : Exports == Implementation where
  K ==> Union("loop", "collect", "repeat")
  IT ==> SpadIterator(N)
  PF ==> PrintableForm

  Exports ==> ParsableCategory with
    elt : (%, "kind") -> K
    elt : (%, "itors") -> List(N)
    elt : (%, "guards") -> List(N)
    elt : (%, "body") -> N
    construct : (K, List(N), List(N), N) -> %

  Implementation ==> add
    Rep := Record(lp_kind : K,
                  lp_itors : List(N),
                  lp_guards : List(N),
                  lp_body : N)

    import ParserTools
    import Logger('Parser)

    elt(x, "kind") == x.lp_kind
    elt(x, "itors") == x.lp_itors
    elt(x, "guards") == x.lp_guards
    elt(x, "body") == x.lp_body

    construct(k, il, gl, b) == [k, il, gl, b]$Rep

    parse ex ==
      repeat? ex =>
        ["repeat", [], [], parse cdr ex]

      lst := destruct cdr ex
      l_body := parse(last lst) $ N
      lst := reverse(rest(reverse(lst)))

      -- println [convert(car ex), paren [convert e for e in lst]]

      range : SpadSegment(N)
      l_itors : List(N) := []
      l_guards : List(N) := []

      for e in lst repeat
        -- TODO:
        -- 1) make sure guards are handled well
        -- 2) a while statement can occur inside collect statement
        itor? e =>
          -- (IN item sequence)
          l_itors := [[[symbol e.2, parse e.3]$IT], :l_itors]
        step? e =>
          -- (STEP i m k n) -> i := m..n by k
          -- (STEP i m k) -> i := m.. by k
          range : SpadSegment(N) := if #e = 4
            then [parse e.3, parse e.4]
            else [parse e.3, parse e.5, parse e.4]
          l_itors := [[[symbol e.2, [range]]$IT], :l_itors]
        guard? e or while? e =>
          -- should they be mixed together ?
          -- ('| cond)
          -- (WHILE cond)
          l_guards := [parse e.2, :l_guards]
        fail pile ["Unrecognized loop construct:" :: PF, convert(e)]
        error ""

      l_itors := reverse l_itors
      l_guards := reverse l_guards

      #l_guards > 1 =>
        fail ("Loop has more than one guard! That should not happen!" :: PF)
        error ""

      if collect? ex
        then ["collect", l_itors, l_guards, l_body]
        else ["loop", l_itors, l_guards, l_body]

    convert x ==
      s : String := (x.kind = "collect" => "COLLECT"; "REPEAT")
      lis := [convert i for i in x.itors]
      lgs := [convert g for g in x.guards]
      lgs :=
        if empty? lis
          then [convert [convert 'WHILE, g] for g in lgs]
          else [convert [convert '_|, g] for g in lgs]
      convert [convert (s :: Symbol), :lis, :lgs, convert x.body]

    coerce n ==
      il := [i :: PF for i in n.itors]
      gl := [spaces ["if" :: PF, g :: PF] for g in n.guards]
      loopBody := n.body :: PF
      n.kind case "loop" =>
        loopExpr : List(PF) :=
          if empty? il then
            loopCond := sepBy(" and " :: PF, [g :: PF for g in n.guards])
            ["while" :: PF, loopCond]
          else
            [:il, :gl]
        vconcat [pile loopExpr, vconcat ["repeat" :: PF, indent(2, loopBody)]]
      n.kind case "collect" =>
        bracket spaces [loopBody, :concat(il, gl)]
      n.kind case "repeat" =>
        spaces ["repeat" :: PF, loopBody]

)abbrev domain SLAMBDA SpadLambda
SpadLambda(N : SpadNodeCategory) : Exports == Implementation where
  PF ==> PrintableForm
  MT ==> SpadMappingType(N)
  TD ==> SpadTypeDecl(N)

  Exports ==> ParsableCategory with
    elt : (%, "args") -> List(TD)
    elt : (%, "type") -> N
    elt : (%, "body") -> N
    construct : (List(TD), N, N) -> %

  Implementation ==> add
    Rep := Record(l_args : List(TD), l_type : N, l_body : N)

    import ParserTools

    elt(x, "args") == x.l_args
    elt(x, "type") == x.l_type
    elt(x, "body") == x.l_body

    construct(al, t, b) == [al, t, b]$Rep

    parse ex ==
      l : Record(args : List(SExpression), type : SExpression) :=
        -- (+-> arg body)
        not list? ex.2 =>
          [[ex.2], convert []]
        -- (+-> (@Tuple (: arg1 Type1) (: arg2 Type2)) body)
        tuple? ex.2 =>
          [destruct cdr ex.2, convert []]
        -- (+-> (: (: arg Type) RetType) body) 
        -- (+-> (: (@Tuple (: arg1 Type1) (: arg2 Type2)) RetType) body)
        var? ex.2 =>
          [(not tuple? ex.2.2 => [ex.2.2]; destruct cdr ex.2.2), ex.2.3]

      largs : List(TD) := []
      for arg in l.args repeat
        var? arg =>
          largs := [[[symbol arg.2], parse arg.3], :largs]
        largs := [[[symbol arg], emptyNode()], :largs]

      [reverse largs, parse l.type, parse ex.3]

    convert x ==
      args := [convert arg for arg in x.args]
      type := [convert '_:, convert args, convert x.type]
      convert [convert '_+_-_>, convert type, convert x.body]

    coerce n ==
      spaces([paren [arg :: PF for arg in n.args], ":" :: PF, n.type :: PF,
             "+->" :: PF, n.body :: PF])

)abbrev package SSEQ SpadSequence
SpadSequence(N : SpadNodeCategory) : Exports == Implementation where
  K ==> Union("Domain", "Package", "Join", "Capsule", "Sequence", "Tuple", "Body")
  PF ==> PrintableForm

  Exports ==> ParsableCategory with
    elt : (%, "kind") -> K
    elt : (%, "list") -> List(N)
    construct : (K, List(N)) -> %

  Implementation ==> add
    Rep := Record(s_kind : K, s_list : List(N))

    import ParserTools

    elt(x, "kind") == x.s_kind
    elt(x, "list") == x.s_list

    construct(k, l) == [k, l]$Rep

    parse ex ==
      content : List N := []

      lst :=
        domain? ex or package? ex =>
          -- (CATEGORY domain ...)
          -- (CATEGORY package ...)
          destruct cdr(cdr(ex))
        -- (@Tuple ...)
        -- (SEQ ...)
        -- (Join ...)
        -- (PROGN ...)
        destruct cdr(ex)

      for e in lst repeat
        var? e =>
          if listof? e.2
            then
              -- (: (LISTOF x y z ...) Type)
              varlst := destruct(cdr e.2)
              for var in varlst repeat
                sexp : N := parse (convert [convert '_:, var, e.3])
                content := [sexp, :content]
            else
              content := [(parse e) $ N, :content]

        content := [(parse e) $ N, :content]

      k : K :=
        capsule? ex => "Capsule"
        seq? ex => "Sequence"
        tuple? ex => "Tuple"
        domain? ex => "Domain"
        package? ex => "Package"
        join? ex => "Join"
        progn? ex => "Body"

      [k, reverse content]

    convert x ==
      ls := [convert i for i in x.list]
      ex :=
        x.kind case "Domain" =>
          [convert ("CATEGORY" :: Symbol), convert ("domain" :: Symbol), :ls]
        x.kind case "Package" =>
          [convert ("CATEGORY" :: Symbol), convert ("package" :: Symbol), :ls]
        x.kind case "Body" =>
          [convert ("PROGN" :: Symbol), :ls]
        x.kind case "Join" =>
          [convert ("Join" :: Symbol), :ls]
        x.kind case "Capsule" =>
          [convert ("CAPSULE" :: Symbol), :ls]
        x.kind case "Sequence" =>
          [convert ("SEQ" :: Symbol), :ls]
        x.kind case "Tuple" => 
          [convert ("@Tuple" :: Symbol), :ls]
      convert ex

    coerce n ==
      ls := [e :: PF for e in n.list | not emptyNode? e]
      empty? ls => "()" :: PF
      n.kind case "Join" =>
        #n.list = 1 => ls.1
        l1 := [m :: PF for m in n.list | apply? m]
        l2 := [m :: PF for m in n.list | not apply? m]
        empty? l1 => vconcat l2
        pile [hconcat ["Join" :: PF, paren l1], :l2]
      n.kind case "Tuple" => paren ls
      vconcat ls

    n = m ==
      n.kind ~= m.kind => false
      n.kind = "Join" =>
        empty? setDifference(n.list, m.list)
      n.list = m.list

)abbrev package SCEXPR SpadCondExpr
SpadCondExpr(N : SpadNodeCategory) : Exports == Implementation where
  PF ==> PrintableForm

  Exports ==> ParsableCategory with
    elt : (%, "cond") -> N
    elt : (%, "truebr") -> N
    elt : (%, "falsebr") -> N
    construct : (N, N, N) -> %

  Implementation ==> add
    Rep := Record(c_cond : N, c_true : N, c_false : N)

    import ParserTools

    elt(x, "cond") == x.c_cond
    elt(x, "truebr") == x.c_true
    elt(x, "falsebr") == x.c_false

    convert x ==
      convert [convert ("IF" :: Symbol), convert x.cond, convert x.truebr, convert x.falsebr]

    construct(c, tb, fb) == [c, tb, fb]$Rep

    parse ex ==
      -- (IF condition expr1 expr2)
      -- (IF condition expr 'noBranch)
      -- (IF condition 'noBranch expr)
      (c, l, r) := (ex.2, ex.3, ex.4)
      nobranch? l =>
        pc : N := parse (convert [convert '_not, c])
        [pc, parse r, emptyNode()]
      nobranch? r =>
        [parse c, parse l, emptyNode()]
      [parse c, parse l, parse r]

    coerce c ==
      fs : List(PF) :=
        [spaces ["if" :: PF, c.cond :: PF],
         pile ["then" :: PF, c.truebr :: PF]]
      if not emptyNode? c.falsebr then
        fs := [:fs, pile ["else" :: PF, c.falsebr :: PF]]
      vconcat fs

)abbrev package SFUNC SpadFunction
SpadFunction(N : SpadNodeCategory) : Exports == Implementation where
  TD ==> SpadTypeDecl(N)
  MT ==> SpadMappingType(N)
  PF ==> PrintableForm
  SEX ==> SExpression

  Exports ==> ParsableCategory with
    elt : (%, "name") -> Symbol
    elt : (%, "args") -> List(N)
    elt : (%, "type") -> N
    elt : (%, "result") -> N
    elt : (%, "body") -> N
    construct : (Symbol, List(N), N, N) -> %
    signature : % -> MT

  Implementation ==> add
    Rep := Record(fn_name : Symbol,
                  fn_args : List(N),
                  fn_type : N,
                  fn_body : N)

    import ParserTools
    import SExpression

    elt(x, "name") == x.fn_name
    elt(x, "args") == x.fn_args
    elt(x, "type") == x.fn_type
    elt(x, "result") == x.fn_type
    elt(x, "body") == x.fn_body

    construct(fname, fargs, ftype, fbody) == 
      [fname, fargs, ftype, fbody]$Rep

    parseArg (s : SEX, t : SEX) : N ==
      string? s => [string s]
      [[[symbol s], parseNonNull t]$TD]

    parse ex ==
      argNames := destruct cdr ex.2
      argTypes := destruct cdr ex.3
      fargs := [parseArg(s, t) for s in argNames for t in argTypes]
      [symbol car ex.2, fargs, parseNonNull car ex.3, parse ex.5]

    convert x ==
      argNames := [convert ((arg :: TD).expr :: Symbol) for arg in x.args]
      types := [convert (arg :: TD).type for arg in x.args]
      types' := [convert [] for i in 0..#x.args]
      fbody := convert x.body
      convert([convert ("DEF" :: Symbol),
               convert [convert x.name, :argNames],
               convert [convert x.type, :types],
               convert types',
               fbody])

    signature fn ==
      types := [(typeDecl? arg => (arg :: TD).type; emptyNode())
                for arg in fn.args]
      [types, fn.type]$MT

    coerce n ==
      fargs := [arg :: PF for arg in n.args]
      retType : List(PF) :=
        emptyNode? n.type => []
        [":" :: PF, n.type :: PF]
      pile ([spaces [n.name :: PF, paren fargs, :retType, "==" :: PF],
             n.body :: PF])

)abbrev package SMACRO SpadMacro
++ SPAD macro representation
SpadMacro(N : SpadNodeCategory) : Exports == Implementation where
  PF ==> PrintableForm

  Exports ==> ParsableCategory with
    elt : (%, "name") -> Symbol
    elt : (%, "args") -> List Symbol
    elt : (%, "body") -> N
    construct : (Symbol, List Symbol, N) -> %
      ++ construct(name,args,exp)
  
  Implementation ==> add
    Rep := Record(md_name : Symbol,
                  md_args : List Symbol,
                  md_body : N)

    import ParserTools

    elt(x, "name") == x.md_name
    elt(x, "args") == x.md_args
    elt(x, "body") == x.md_body

    construct(mname, margs, mbody) ==
      [mname, margs, mbody]$Rep

    parse ex ==
      mname := symbol car(ex.2)
      margs := [ symbol s for s in destruct(cdr(ex.2)) ]
      mbody : N := parse ex.5
      [mname, margs, mbody]

    convert x == convert []

    coerce m ==
      margs := paren [arg :: PF for arg in m.args]
      spaces [m.name :: PF, margs, "==>" :: PF, m.body :: PF]

)abbrev package SWHERE SpadWhere
SpadWhere(N : SpadNodeCategory) : Exports == Implementation where
  PF ==> PrintableForm

  Exports ==> ParsableCategory with
    elt : (%, "body") -> N
    elt : (%, "env") -> N
    construct : (N, N) -> %

  Implementation ==> add
    Rep := Record(w_body : N, w_env : N)

    import ParserTools

    elt(x, "body") == x.w_body
    elt(x, "env") == x.w_env

    construct(d, e) == [d, e]$Rep

    parse ex ==
      [(parse ex.2) $ N, (parse ex.3) $ N]

    convert x == convert []

    coerce w ==
      spaces [w.body :: PF, "where" :: PF, w.env :: PF]

)abbrev package SFTOR SpadFunctor
++ SPAD functor representation
SpadFunctor(N : SpadNodeCategory) : Exports == Implementation where
  TD ==> SpadTypeDecl(N)
  MT ==> SpadMappingType(N)
  PF ==> PrintableForm

  Exports ==> ParsableCategory with
    elt : (%, "name") -> Symbol
    elt : (%, "args") -> List(TD)
    elt : (%, "type") -> N
    elt : (%, "extends") -> N
    elt : (%, "capsule") -> N
    construct : (Symbol, List(TD), N, N, N) -> %
    signature : % -> TD

  Implementation ==> add
    Rep := Record(f_name : Symbol,
                  f_args : List TD,
                  f_type : N,
                  f_extends : N,
                  f_capsule : N)

    import ParserTools
    import SExpression
    import SpadNode

    SEX ==> SExpression

    elt(x, "name") == x.f_name
    elt(x, "args") == x.f_args
    elt(x, "type") == x.f_type
    elt(x, "extends") == x.f_extends
    elt(x, "capsule") == x.f_capsule

    construct(n, al, t, e, c) == [n, al, t, e, c]$Rep

    parse ex ==
      argNames := destruct cdr ex.2
      argTypes := destruct cdr ex.3
      fbody := ex.5
      fargs := [[[symbol s], parse t]$TD for s in argNames for t in argTypes]
      fcapsule := if symbol(car fbody) = 'add then fbody.3 else fbody
      fextends := if symbol(car fbody) = 'add then fbody.2 else convert []
      [symbol car ex.2, fargs, parse car ex.3, parseNonNull fextends, parse fcapsule]

    convert x ==
      argNames := [convert (arg.expr :: Symbol) for arg in x.args]
      argTypes := [convert arg.type for arg in x.args]
      convert([convert 'DEF,
               convert [convert x.name, :argNames],
               convert [convert x.type, :argTypes],
               convert [convert [] for i in 0..#x.args],
               convert x.capsule])

    coerce n ==
      def := spaces [n.name :: PF, paren [arg :: PF for arg in n.args], ":" :: PF]
      impl := pile [spaces ["==" :: PF, n.extends :: PF, "add" :: PF], n.capsule :: PF]
      pile [def, indent(2, n.type :: PF), impl]

    signature ft ==
      [[ft.name], [[[arg.type for arg in ft.args], ft.type]$MT]]

)abbrev domain SNODE SpadNode
++ SPAD generic expression
SpadNode() : Exports == Implementation where
  DF ==> DoubleFloat
  NNI ==> NonNegativeInteger
  PI ==> PositiveInteger
  PF ==> PrintableForm

  APP ==> SpadApply(%)
  ASS ==> SpadAssign(%)
  CE ==> SpadCondExpr(%)
  SC ==> SpadCase(%)
  FN ==> SpadFunction(%)
  FT ==> SpadFunctor(%)
  IM ==> SpadImport(%)
  IT ==> SpadIterator(%)
  LAM ==> SpadLambda(%)
  LP ==> SpadLoop(%)
  MP ==> SpadMarkerPath
  MR ==> SpadMarker(%)
  MT ==> SpadMappingType(%)
  SM ==> SpadMacro(%)
  NR ==> SpadNodeRef(%)
  RT ==> SpadRecordType(%)
  SEG ==> SpadSegment(%)
  SEQ ==> SpadSequence(%)
  ST ==> SpadSubType(%)
  TC ==> SpadTypeCoerce(%)
  TD ==> SpadTypeDecl(%)
  TEH ==> SpadTypeHas(%)
  TEI ==> SpadTypeIs(%)
  TEP ==> SpadTypePretend(%)
  TG ==> SpadTypeGuard(%)
  TO ==> SpadTypeOrigin(%)
  TS ==> SpadTypeSelect(%)
  TV ==> SpadTypeVar(%)
  UT ==> SpadUnionType(%)
  SW ==> SpadWhere(%)
  
  Exports ==> SpadNodeCategory with
    nodeApp : (%, List(%)) -> %
    nodeAssign : (%, %) -> %
    nodeCase : (%, %) -> %
    nodeCondExpr : (%, %, %) -> %
    nodeFtor : (Symbol, List(TD), %, %, %) -> %
    nodeFun : (Symbol, List(%), %, %) -> %
    nodeImport : % -> %
    nodeIterator : (Symbol, %) -> %
    nodeLambda : (List(TD), %, %) -> %
    nodeLoop : (Union("loop", "collect", "repeat"), List(%), List(%), %) -> %
    nodeMacro : (Symbol, List(Symbol), %) -> %
    nodeMappingType : (List(%), %) -> %
    nodeMarker : Union("%any", "%undef") -> %
    nodeNodeRef : (PI, PI) -> %
    nodeRecordType : List(TD) -> %
    nodeSeg : (%, %, %) -> %
    nodeSeq : (Union("Domain", "Package", "Join", "Capsule", "Sequence", "Tuple", "Body"), List(%)) -> %
    nodeSubType : (%, %) -> %
    nodeTypeCoerce : (%, %) -> %
    nodeTypeDecl : (%, %) -> %
    nodeTypeGuard : (%, %) -> %
    nodeTypeHas : (%, %) -> %
    nodeTypeIs : (%, %) -> %
    nodeTypePretend : (%, %) -> %
    nodeTypeOrigin : (%, %) -> %
    nodeTypeSelect : (%, %) -> %
    nodeTypeVar : (NNI, NNI) -> %
    nodeUnionType : List(%) -> %
    nodeWhere : (%, %) -> %

  Implementation ==> add
    Rep := Union(dfloat : DF,
                 int : Integer,
                 str : String,
                 sym : Symbol,
                 apply : APP,
                 assign : ASS,
                 cond : CE, 
                 ftor : FT,
                 func : FN,
                 itor : IT,
                 lambda : LAM,
                 loop : LP,
                 mapping : MT,
                 marker : MR,
                 noderef : NR,
                 record : RT,
                 s_case : SC,
                 segment : SEG,
                 seq : SEQ,
                 s_import : IM,
                 s_macro : SM,
                 subtype : ST,
                 s_where : SW,
                 t_case : TC,
                 t_coerce : TC,
                 t_decl : TD,
                 t_guard : TG,
                 t_has : TEH,
                 t_is : TEI,
                 t_origin: TO,
                 t_pretend : TEP,
                 t_select : TS,
                 typevar : TV,
                 union : UT,
                 empty : "$EmptyNode")

    import SExpression
    import Printer
    import ParserTools
    import Logger('Parser)

    apply? n == n case apply
    assign? n == n case assign
    capsule? n ==
      not n case seq => false
      n.seq.kind = "Capsule"
    case? n == n case s_case
    condExpr? n == n case cond
    float? n == n case dfloat
    function? n == n case func
    functor? n == n case ftor
    import? n == n case s_import
    integer? n == n case int
    iterator? n == n case itor
    lambda? n == n case lambda
    loop? n == n case loop 
    macro? n == n case s_macro 
    mappingType? n == n case mapping 
    marker? n == n case marker
    nodeRef? n == n case noderef
    recordType? n == n case record
    segment? n == n case segment 
    sequence? n == n case seq
    signatureList? n ==
      not n case seq => false
      n.seq.kind ~= "Join"
    string? n == n case str
    symbol? n == n case sym
    typeCoerce? n == n case t_coerce
    typeDecl? n == n case t_decl
    typeGuard? n == n case t_guard
    typeHas? n == n case t_has
    typeIs? n == n case t_is
    typePretend? n == n case t_pretend
    typeOrigin? n == n case t_origin
    typeSelect? n == n case t_select
    subType? n == n case subtype
    unionType? n == n case union
    where? n == n case s_where
    typeAny? n ==
      not n case marker => false
      n :: MR = ["%any"]
    typeVar? n == n case typevar
    typeUndef? n ==
      not n case marker => false
      n :: MR = ["%undef"]

    value? n ==
      float? n or integer? n or string? n or symbol? n

    true? n ==
      n = ['true]

    false? n ==
      n = ['false]

    CoerceError(T) ==>
      error concat ["Cannot coerce SpadNode to ", T, "!"]

    coerce (n : %) : APP ==
      apply? n => n.apply
      CoerceError("SpadApply")

    coerce (n : %) : ASS ==
      assign? n => n.assign
      CoerceError("SpadAssign")

    coerce (n : %) : CE ==
      condExpr? n => n.cond
      CoerceError("SpadCondExpr")

    coerce (n : %) : SC ==
      case? n => n.s_case
      CoerceError("SpadCase")

    coerce (n : %) : FN ==
      function? n => n.func
      CoerceError("SpadFunction")

    coerce (n : %) : FT ==
      functor? n => n.ftor
      CoerceError("SpadFunctor")

    coerce (n : %) : IM ==
      import? n => n.s_import
      CoerceError("SpadImport")

    coerce (n : %) : LAM == 
      lambda? n => n.lambda
      CoerceError("SpadLambda")

    coerce (n : %) : IT == 
      iterator? n => n.itor
      CoerceError("SpadIterator")

    coerce (n : %) : LP ==
      loop? n => n.loop
      CoerceError("SpadLoop")

    coerce (n : %) : SM ==
      macro? n => n.s_macro
      CoerceError("SpadMacro")

    coerce (n : %) : MT == 
      mappingType? n => n.mapping
      CoerceError("SpadMappingType")

    coerce (n : %) : MR == 
      marker? n => n.marker
      CoerceError("SpadMarker")

    coerce (n : %) : NR == 
      nodeRef? n => n.noderef
      CoerceError("SpadNodeRef")

    coerce (n : %) : RT ==
      recordType? n => n.record
      CoerceError("SpadRecordType")

    coerce (n : %) : SEG ==
      segment? n => n.segment
      CoerceError("SpadSegment")

    coerce (n : %) : SEQ ==
      sequence? n => n.seq
      CoerceError("SpadSequence")

    coerce (n : %) : ST ==
      subType? n => n.subtype
      CoerceError("SpadSubType")

    coerce (n : %) : TC ==
      typeCoerce? n => n.t_coerce
      CoerceError("SpadTypeCoerce")

    coerce (n : %) : TD ==
      typeDecl? n => n.t_decl
      CoerceError("SpadTypeDecl")

    coerce (n : %) : TG ==
      typeGuard? n => n.t_guard
      CoerceError("SpadTypeGuard")

    coerce (n : %) : TEH ==
      typeHas? n => n.t_has
      CoerceError("SpadTypeHas")

    coerce (n : %) : TEI ==
      typeIs? n => n.t_is
      CoerceError("SpadTypeIs")

    coerce (n : %) : TEP ==
      typePretend? n => n.t_pretend
      CoerceError("SpadTypePretend")

    coerce (n : %) : TO ==
      typeOrigin? n => n.t_origin
      CoerceError("SpadTypeOrigin")

    coerce (n : %) : TS ==
      typeSelect? n => n.t_select
      CoerceError("SpadTypeSelect")

    coerce (n : %) : TV == 
      typeVar? n => n.typevar
      CoerceError("SpadTypeVar")

    coerce (n : %) : UT ==
      unionType? n => n.union
      CoerceError("SpadUnionType")

    coerce (n : %) : SW ==
      where? n => n.s_where
      CoerceError("SpadWhere")

    coerce (n : %) : DF ==
      float? n => n.dfloat
      CoerceError("DoubleFloat")

    coerce (n : %) : Integer ==
      integer? n => n.int
      CoerceError("Integer")

    coerce (n : %) : Symbol ==
      symbol? n => n.sym
      CoerceError("Symbol")

    coerce (n : %) : String == 
      string? n => n.str
      CoerceError("String")

    emptyNode () == ["$EmptyNode"]$Rep
    emptyNode? n == n case empty

    constructor? s ==
      sex : SExpression := GETDATABASE(s, 'ABBREVIATION)$Lisp
      not null? sex

    construct (n : APP) : % == [n]$Rep
    construct (n : ASS) : % == [n]$Rep
    construct (n : CE) : % == [n]$Rep
    construct (n : SC) : % == [n]$Rep
    construct (n : FN) : % == [n]$Rep
    construct (n : FT) : % == [n]$Rep
    construct (n : IM) : % == [n]$Rep
    construct (n : IT) : % == [n]$Rep
    construct (n : LAM) : % == [n]$Rep
    construct (n : LP) : % == [n]$Rep
    construct (n : SM) : % == [n]$Rep
    construct (n : MT) : % == [n]$Rep
    construct (n : MR) : % == [n]$Rep
    construct (n : NR) : % == [n]$Rep
    construct (n : RT) : % == [n]$Rep
    construct (n : SEG) : % == [n]$Rep
    construct (n : SEQ) : % == [n]$Rep
    construct (n : ST) : % == [n]$Rep
    construct (n : TC) : % == [n]$Rep
    construct (n : TD) : % == [n]$Rep
    construct (n : TG) : % == [n]$Rep
    construct (n : TEH) : % == [n]$Rep
    construct (n : TEI) : % == [n]$Rep
    construct (n : TEP) : % == [n]$Rep
    construct (n : TO) : % == [n]$Rep
    construct (n : TS) : % == [n]$Rep
    construct (n : TV) : % == [n]$Rep
    construct (n : UT) : % == [n]$Rep
    construct (n : SW) : % == [n]$Rep

    construct (n : DF) : % == [n]$Rep
    construct (n : Integer) : % == [n]$Rep
    construct (n : String) : % == [n]$Rep
    construct (n : Symbol) : % == [n]$Rep

    parseNonNull ex ==
      null? ex => emptyNode()
      parse ex

    parse ex ==
      debug ["Parsing expression:" :: PF, convert(ex) :: PF]

      (capsule? ex or seq? ex or tuple? ex or domain? ex or package? ex or
       join? ex or progn? ex) =>
        -- (SEQ expr1 expr2 ...)
        -- (CAPSULE expr1 expr2 ...)
        -- (@Tuple expr1 expr2 ...)
        [parse(ex)$SEQ]

      import? ex => [parse(ex)$IM]
      where? ex => [parse(ex)$SW]
      lambda? ex => [parse(ex)$LAM]
      functor? ex => [parse(ex)$FT]
      function? ex => [parse(ex)$FN]
      macro? ex => [parse(ex)$SM]
      marker? ex => [parse(ex)$MR]
      noderef? ex => [parse(ex)$NR]
      typevar? ex => [parse(ex)$TV]
      signature? ex or var? ex => [parse(ex)$TD]
      case? ex => [parse(ex)$SC]
      has? ex => [parse(ex)$TEH]
      is? ex => [parse(ex)$TEI]
      pretend? ex => [parse(ex)$TEP]
      coerce? ex => [parse(ex)$TC]
      origin? ex => [parse(ex)$TO]
      select? ex => [parse(ex)$TS]

      let? ex => [parse(ex)$ASS]

      ifelse? ex => -- {if-then-else expression of if-then statement}
        [parse(ex)$CE]

      collect? ex or loop? ex or repeat? ex =>
        [parse(ex)$LP]

      mapping? ex => -- TODO: var? ex is missing after collapsing Node and Type
        [parse(ex)$MT]

      record? ex => [parse(ex)$RT]
      union? ex => [parse(ex)$UT]
      list? ex and #ex > 0 => [parse(ex)$APP]

      symbol? ex =>
        s := symbol ex
        -- BUG: this doesn't work and no warning is issued...
        -- if s = '$ then s := '%
        [if s = '$ then s := coerce "%" else s]

      string? ex => [string ex]
      integer? ex => [integer ex]
      float? ex => [float ex]
      null? ex => emptyNode()

      fail ["Could not parse s-expression:" :: PF, convert(ex) :: PF]
      error ""

    coerce (n : %) : PF ==
      apply? n => (n :: APP) :: PF
      assign? n => (n :: ASS) :: PF
      case? n => (n :: SC) :: PF
      condExpr? n => (n :: CE) :: PF
      float? n => (n :: DF) :: PF
      function? n => (n :: FN) :: PF
      functor? n => (n :: FT) :: PF
      import? n => (n :: IM) :: PF
      integer? n => (n :: Integer) :: PF
      iterator? n => (n :: IT) :: PF
      lambda? n => (n :: LAM) :: PF
      loop? n => (n :: LP) :: PF
      macro? n => (n :: SM) :: PF
      mappingType? n => (n :: MT) :: PF
      marker? n => (n :: MR) :: PF
      nodeRef? n => (n :: NR) :: PF
      recordType? n => (n :: RT) :: PF
      segment? n => (n :: SEG) :: PF
      sequence? n => (n :: SEQ) :: PF
      string? n => string((n :: String) :: PF)
      symbol? n => (n :: Symbol) :: PF
      subType? n => (n :: ST) :: PF
      typeCoerce? n => (n :: TC) :: PF
      typeDecl? n => (n :: TD) :: PF
      typeGuard? n => (n :: TG) :: PF
      typeHas? n => (n :: TEH) :: PF
      typeIs? n => (n :: TEI) :: PF
      typePretend? n => (n :: TEP) :: PF
      typeOrigin? n => (n :: TO) :: PF
      typeSelect? n => (n :: TS) :: PF
      typeVar? n => (n :: TV) :: PF
      unionType? n => (n :: UT) :: PF
      where? n => (n :: SW) :: PF
      emptyNode? n => "?" :: PF

      error "coerce $ SpadNode: variant not handled!"

    convert n ==
      apply? n => convert(n :: APP)
      assign? n => convert(n :: ASS)
      case? n => convert(n :: SC)
      condExpr? n => convert(n :: CE)
      float? n => convert(n :: DF)
      function? n => convert(n :: FN)
      functor? n => convert(n :: FT)
      import? n => convert(n :: IM)
      integer? n => convert(n :: Integer)
      iterator? n => convert(n :: IT)
      lambda? n => convert(n :: LAM)
      loop? n => convert(n :: LP)
      macro? n => convert(n :: SM)
      mappingType? n => convert(n :: MT)
      marker? n => convert(n :: MR)
      nodeRef? n => convert(n :: NR)
      recordType? n => convert(n :: RT)
      segment? n => convert(n :: SEG)
      sequence? n => convert(n :: SEQ)
      string? n => convert(n :: String)
      symbol? n => convert(n :: Symbol)
      -- subType is not recognized by original compiler
      typeCoerce? n => convert(n :: TC)
      typeDecl? n => convert(n :: TD)
      -- typeGuard is not recognized by original compiler
      typeHas? n => convert(n :: TEH)
      typeIs? n => convert(n :: TEI)
      typePretend? n => convert(n :: TEP)
      typeOrigin? n => convert(n :: TO)
      typeSelect? n => convert(n :: TS)
      typeVar? n => convert(n :: TV)
      unionType? n => convert(n :: UT)
      where? n => convert(n :: SW)
      emptyNode? n => convert []

      error "convert $ SpadNode: variant not handled!"

    n = m ==
      -- defined only for nodes that can represent types
      apply? n and apply? m => (n :: APP) = (m :: APP)
      float? n and float? m => (n :: DF) = (m :: DF)
      function? n and function? m => (n :: FN) = (m :: FN)
      integer? n and integer? m => (n :: Integer) = (m :: Integer)
      iterator? n and iterator? m => (n :: IT) = (m :: IT)
      mappingType? n and mappingType? m => (n :: MT) = (m :: MT)
      marker? n and marker? m => (n :: MR) = (m :: MR)
      nodeRef? n and nodeRef? m => (n :: NR) = (m :: NR)
      recordType? n and recordType? m => (n :: RT) = (m :: RT)
      string? n and string? m => (n :: String) = (m :: String)
      symbol? n and symbol? m => (n :: Symbol) = (m :: Symbol)
      unionType? n and unionType? m => (n :: UT) = (m :: UT)
      typeDecl? n and typeDecl? m => (n :: TD) = (m :: TD)
      typeOrigin? n and typeOrigin? m => (n :: TO) = (m :: TO)
      typeSelect? n and typeSelect? m => (n :: TS) = (m :: TS)
      typeVar? n and typeVar? m => (n :: TV) = (m :: TV)
      marker? n and marker? m => (n :: MR) = (m :: MR)
      sequence? n and sequence? m => (n :: SEQ) = (m :: SEQ)
      emptyNode? n and emptyNode? m => true
      false

    nodeApp (fun, args) == [[fun, args]$APP]
    nodeAssign (lval, rval) == [[lval, rval]$ASS]
    nodeCase (expr, type) == [[expr, type]$SC]
    nodeCondExpr (cond, btrue, bfalse) == [[cond, btrue, bfalse]$CE]
    nodeFun (name, args, type, body) == [[name, args, type, body]$FN]
    nodeFtor (name, args, type, ext, caps) == [[name, args, type, ext, caps]$FT]
    nodeImport type == [[type]$IM]
    nodeIterator (var, seq) == [[var, seq]$IT]
    nodeLambda (args, type, body) == [[args, type, body]$LAM]
    nodeLoop (kind, itors, guards, body) == [[kind, itors, guards, body]$LP]
    nodeMacro (name, args, body) == [[name, args, body]$SM]
    nodeMappingType (args, type) == [[args, type]$MT]
    nodeRecordType fields ==
      rt := [fields]$RT
      rt case "failed" => emptyNode()
      [rt]
    nodeNodeRef (major, minor) == [[major, minor]$NR]
    nodeSeq (kind, list) == [[kind, list]$SEQ]
    nodeSeg (start, end, step) == [[start, end, step]$SEG]
    nodeTypeCoerce (expr : %, type : %) == [[expr, type]$TC]
    nodeTypeDecl (expr : %, type : %) == [[expr, type]$TD]
    nodeTypeGuard (expr, type) == [[expr, type]$TG]
    nodeTypeOrigin (expr, type) == [[expr, type]$TO]
    nodeTypeHas (expr, type) == [[expr, type]$TEH]
    nodeTypeIs (expr, type) == [[expr, type]$TEI]
    nodeTypeOrigin (expr, type) == [[expr, type]$TO]
    nodeTypeVar (major, minor) == [[major, minor]$TV]
    nodeTypeSelect (expr, type) == [[expr, type]$TS]
    nodeSubType (type1, type2) == [[type1, type2]$ST]
    nodeUnionType variants ==
      ut := [variants]$UT
      ut case "failed" => emptyNode()
      [ut]
    nodeWhere (body, env) == [[body, env]$SW]
