)abbrev category SPNODEC SpadNodeCategory
SpadNodeCategory() : Category == ParsableCategory with
  construct : SpadApply(%) -> %
  construct : SpadAssign(%) -> %
  construct : SpadConditional(%) -> %
  construct : SpadFunction(%) -> %
  construct : SpadFunctor(%) -> %
  construct : SpadImport(%) -> %
  construct : SpadLambda(%) -> %
  construct : SpadLoop(%) -> %
  construct : SpadMacro(%) -> %
  construct : SpadMappingType(%) -> %
  construct : SpadMarker(%) -> %
  construct : SpadNamedType(%) -> %
  construct : SpadRecordType(%) -> %
  construct : SpadSegment(%) -> %
  construct : SpadSequence(%) -> %
  construct : SpadSumType(%) -> %
  construct : SpadTypeExpr(%) -> %
  construct : SpadUnionType(%) -> %
  construct : SpadWhere(%) -> %

  construct : DoubleFloat -> %
  construct : Integer -> %
  construct : String -> %
  construct : Symbol -> %

  emptyNode : () -> %

  apply? : % -> Boolean
  assign? : % -> Boolean
  conditional? : % -> Boolean
  emptyNode? : % -> Boolean
  float? : % -> Boolean
  function? : % -> Boolean
  functor? : % -> Boolean
  import? : % -> Boolean
  integer? : % -> Boolean
  lambda? : % -> Boolean
  loop? : % -> Boolean
  macro? : % -> Boolean
  mappingType? : % -> Boolean
  marker? : % -> Boolean
  namedType? : % -> Boolean
  nodeRef? : % -> Boolean
  recordType? : % -> Boolean
  segment? : % -> Boolean
  sequence? : % -> Boolean
  string? : % -> Boolean
  sumType? : % -> Boolean
  symbol? : % -> Boolean
  typeExpr? : % -> Boolean
  unionType? : % -> Boolean
  where? : % -> Boolean
  typeVar? : % -> Boolean

  coerce : % -> DoubleFloat
  coerce : % -> Integer
  coerce : % -> SpadApply(%)
  coerce : % -> SpadAssign(%)
  coerce : % -> SpadConditional(%)
  coerce : % -> SpadFunction(%)
  coerce : % -> SpadFunctor(%)
  coerce : % -> SpadImport(%)
  coerce : % -> SpadLambda(%)
  coerce : % -> SpadLoop(%)
  coerce : % -> SpadMacro(%)
  coerce : % -> SpadMappingType(%)
  coerce : % -> SpadMarker(%)
  coerce : % -> SpadNamedType(%)
  coerce : % -> SpadRecordType(%)
  coerce : % -> SpadSegment(%)
  coerce : % -> SpadSequence(%)
  coerce : % -> SpadSumType(%)
  coerce : % -> SpadTypeExpr(%)
  coerce : % -> SpadUnionType(%)
  coerce : % -> SpadWhere(%)
  coerce : % -> String
  coerce : % -> Symbol

  convert : % -> SExpression

  value? : % -> Boolean
  constructor? : Symbol -> Boolean

  parseNonNull : SExpression -> %

)abbrev domain SPMARK SpadMarker
SpadMarker(N : SpadNodeCategory) : Exports == Implementation where
  NNI ==> NonNegativeInteger

  Exports ==> Join(ParsableCategory, CoercibleTo(Symbol)) with
    elt : (%, "id") -> NNI
    elt : (%, "kind") -> Symbol
    construct : (NNI, Symbol) -> %

  Implementation ==> add
    Rep := Record(m_id : NNI, m_kind : Symbol)

    import OutputForm
    import ParserTools

    elt(x, "id") == x.m_id
    elt(x, "kind") == x.m_kind

    construct(i, k) == [i, k]$Rep

    parse ex ==
      [(integer ex.2) :: NNI, symbol ex.3]

    convert x ==
      convert [convert("@Marker" :: Symbol), convert x.id, convert x.kind]

    n = m ==
      (n.id = m.id) and (n.kind = m.kind)

    coerce (m : %) : Symbol ==
      s : String :=
        m.kind = 'typevar => "%"
        m.kind = 'noderef => "#"
        "%"
      concat(s, string(m.id :: Integer)) :: Symbol

    coerce (m : %) : OutputForm ==
      (m :: Symbol) :: OutputForm

)abbrev domain SPTMAP SpadMappingType
SpadMappingType(N : SpadNodeCategory) : ParsableCategory with
    elt : (%, "args") -> List(N)
    elt : (%, "type") -> N
    construct : (List(N), N) -> %
  == add
    Rep := Record(m_args : List(N), m_type : N)

    import ParserTools
    import SExpression
    import OutputForm

    elt(x, "args") == x.m_args
    elt(x, "type") == x.m_type

    construct(al, t) == [al, t]$Rep

    parseFunType : SExpression -> N
    parseFunType s ==
      if firstSymbol? (s, ':) then parse s.3 else parse s
        
    parse ex ==
      sig : List(N) := [ parseFunType e for e in destruct cdr ex ]
      [ rest sig, first sig ]

    convert x ==
      ts := [convert t for t in [x.type, :x.args]]
      convert [convert ("Mapping" :: Symbol), :ts]

    coerce mpt ==
      coerce_type (t : N) : OutputForm ==
        (emptyNode? t => "?" :: OutputForm; t :: OutputForm)
      ts := [coerce_type t for t in mpt.args]
      src := if #ts ~= 1 then paren ts else first ts
      hconcat [src, " -> ", coerce_type mpt.type]

    n = m ==
      for n' in [n.type, :n.args]
        for m' in [m.type, :m.args] repeat
          n' ~= m' => return false
      true

)abbrev domain SPTSUM SpadSumType
SpadSumType(N : SpadNodeCategory) : Exports == Implementation where
  K ==> Union("Join", "Domain", "Package", "Body")

  Exports ==> ParsableCategory with
    elt : (%, "types") -> List(N)
    elt : (%, "kind") -> K
    construct : (K, List(N)) -> %

  Implementation ==> add
    Rep := Record(s_kind : K, s_types : List(N))

    import ParserTools
    import SExpression

    elt(x, "kind") == x.s_kind
    elt(x, "types") == x.s_types

    construct(k, tl) == [k, tl]$Rep

    parse ex ==
      lst :=
        domain? ex or package? ex =>
          -- (CATEGORY domain ...)
          -- (CATEGORY package ...)
          destruct cdr(cdr(ex))
        join? ex or progn? ex =>
          -- (Join ...)
          -- (PROGN ...)
          destruct cdr(ex)

      args : List(N) := [ parse e for e in lst ]

      domain? ex => ["Domain", args]
      package? ex => ["Package", args]
      join? ex => ["Join", args]
      progn? ex => ["Body", args]

    convert x ==
      ts := [convert t for t in x.types]
      ls :=
        x.kind case "Join" =>
          [convert ("Join" :: Symbol), :ts]
        x.kind case "Domain" =>
          [convert ("CATEGORY" :: Symbol), convert ("domain" :: Symbol), :ts]
        x.kind case "Package" =>
          [convert ("CATEGORY" :: Symbol), convert ("package" :: Symbol), :ts]
        x.kind case "Body" =>
          [convert ("PROGN" :: Symbol), :ts]
      convert ls

    coerce sum ==
      ts := [ t :: OutputForm for t in sum.types ]
      sum.kind case "Join" =>
        hconcat ["Join(", infix(", ", ts), ")"]
      -- hconcat [" with ", hconcat [hspace 2, pile ts]]
      brace ts

)abbrev domain SPTNAMED SpadNamedType
SpadNamedType(N : SpadNodeCategory) : ParsableCategory with
    elt : (%, "name") -> Symbol
    elt : (%, "type") -> N
    construct : (Symbol, N) -> %
      ++ construct(name,type)
    construct : Symbol -> %
      ++ construct(name)
  == add
    Rep := Record(n_name : Symbol, n_type : N)

    import ParserTools
    import SExpression

    elt(x, "name") == x.n_name
    elt(x, "type") == x.n_type

    construct(n, t) == [n, t]$Rep
    construct(n) == [n, emptyNode()]$Rep

    parse ex ==
      var? ex =>
        -- (: field Type)
        [symbol ex.2, parseNonNull ex.3]
      symbol? ex =>
        [symbol ex]
      signature? ex =>
        -- (SIGNATURE name (RetType Arg1Type Arg2Type ...))
        -- (SIGNATURE name Type constant)
        res : N := parse car ex.3
        targs : List(N) := if #ex = 3
          then [parse e for e in destruct cdr ex.3]
          else [parse ex.4 ]
        [symbol ex.2, [[targs, res] $ SpadMappingType(N)]]
      error "Cannot parse named type!"

    convert x ==
      if mappingType? x.type then
        convert [convert ("SIGNATURE" :: Symbol), convert x.name, cdr convert x.type]
      else
        convert [convert (":" :: Symbol), convert x.name, convert x.type]

    coerce t ==
      typename : OutputForm := 
        if emptyNode? t.type then "?" else coerce t.type
      hconcat [t.name :: OutputForm, " : ", typename]

)abbrev domain SPTREC SpadRecordType
SpadRecordType(T : SpadNodeCategory) : Exports == Implementation where
  F ==> SpadNamedType(T)

  Exports ==> ParsableCategory with
    elt : (%, "fields") -> List F
    construct : List F -> %

  Implementation ==> add
    Rep := Record(r_fields : List F)

    import SExpression

    elt(x, "fields") == x.r_fields

    construct fl == [fl]$Rep

    parse ex ==
      -- (Record (: field1 Type1) (: field2 Type2) ...)
      [[parse e for e in destruct cdr ex]]

    convert x ==
      fs := [convert f for f in x.fields]
      convert [convert ("Record" :: Symbol), :fs]

    coerce rt ==
      hconcat ["Record", paren [f :: OutputForm for f in rt.fields]]

)abbrev domain SPTUNION SpadUnionType
SpadUnionType(T : SpadNodeCategory) : Exports == Implementation where
  NT ==> SpadNamedType(T)

  Exports ==> ParsableCategory with
    elt : (%, "variants") -> List T
    construct : List T -> %

  Implementation ==> add
    Rep := Record(u_variants : List T)

    import ParserTools
    import SExpression

    elt(x, "variants") == x.u_variants

    construct vl == [vl]$Rep

    parse ex ==
      -- (Union (: field1 Type1) (: field2 Type2) ...)
      -- (Union Type1 Type2 ...)
      parseUnionField (s : SExpression) : T ==
        (var? s => [[symbol s.2, parse s.3] $ NT]; parse s)
      [[parseUnionField e for e in destruct cdr ex]]

    convert x ==
      vs := [convert v for v in x.variants]
      convert [convert ("Union" :: Symbol), :vs]

    coerce ut ==
      hconcat ["Union", paren [v :: OutputForm for v in ut.variants]]

)abbrev domain SPIMP SpadImport
++ SPAD domain / category / package import declaration
SpadImport(N : SpadNodeCategory) : ParsableCategory with
    elt : (%, "type") -> N
    construct : N -> %
  == add
    Rep := Record(i_type : N)

    import OutputForm
    import SExpression

    elt(x, "type") == x.i_type

    construct x == [x]$Rep

    parse ex ==
      [parse ex.2]

    convert x == convert [convert ("import" :: Symbol), convert x.type]

    coerce im ==
      hconcat ["import ", im.type :: OutputForm]

)abbrev domain SPASS SpadAssign
SpadAssign(N : SpadNodeCategory) : ParsableCategory with
    elt : (%, "lval") -> N
    elt : (%, "rval") -> N
    construct : (N, N) -> %
  == add
    Rep := Record(a_lval : N, a_rval : N)

    import SExpression

    elt(x, "lval") == x.a_lval
    elt(x, "rval") == x.a_rval

    construct(lv, rv) == [lv, rv]$Rep

    parse ex ==
      -- (LET expr value)
      [parse ex.2, parse ex.3]

    convert x ==
      convert [convert ("LET" :: Symbol), convert x.lval, convert x.rval]

    coerce a ==
      hconcat [a.lval :: OutputForm, " := ", a.rval :: OutputForm]

)abbrev domain SPAPP SpadApply
SpadApply(N : SpadNodeCategory) : ParsableCategory with
    elt : (%, "function") -> N
    elt : (%, "args") -> List(N)
    construct : (N, List(N)) -> %
  == add
    Rep := Record(a_fn : N, a_args : List(N))

    import String
    import SExpression

    elt(x, "function") == x.a_fn
    elt(x, "args") == x.a_args

    construct (fn, lst) == [fn, lst]$Rep

    parse ex ==
      lst : List(N) := [parse e for e in destruct ex]
      [first lst, rest lst]

    convert x ==
      convert [convert i for i in [x.function, :x.args]]

    binop : List(Symbol) :=
      ['_-, '_+, '_*, '_/, '_^, '_=, '_~_=, '_<, '_>, '_<_=, '_>_=, 'OR, 'AND, 'or, 'and]

    coerce apply ==
      fun := apply.function
      argl := [ a :: OutputForm for a in apply.args ]

      if marker? fun then
        fun := [(fun :: SpadMarker(N)) :: Symbol]

      not symbol? fun =>
        funof := fun :: OutputForm
        #argl = 0 => funof
        hconcat [paren funof, paren argl]

      funsym := fun :: Symbol

      funsym = 'QUOTE =>
        hconcat ["'", :argl]
      funsym = 'construct =>
        bracket argl
      member?(funsym, ['elt, 'Sel]) =>
        hconcat [first argl, ".", last argl]
      funsym = 'exit =>
        hconcat ["exit{", first argl, "}", "(", last argl, ")"]
      funsym = 'return =>
        hconcat ["return{", first argl, "}", "(", last argl, ")"]
      --#argl = 0 and funsym = 'Zero => "0"
      --#argl = 0 and funsym = 'One => "1"
      #argl = 2 and member?(funsym, binop) =>
        opstr := (lowerCase (string funsym)) :: Symbol
        paren infix(" ", [argl.1 :: OutputForm,
                          opstr :: OutputForm,
                          argl.2 :: OutputForm])

      -- handle attribute as functor
      funsym = 'ATTRIBUTE =>
        argl.1 :: OutputForm

      -- finally, process the application
      fname := funsym :: OutputForm
      (constructor? funsym) and (empty? argl) =>
        fname
      hconcat [fname, paren argl]

    n = m ==
      for n' in [n.function, :n.args]
        for m' in [m.function, :m.args] repeat
          n' ~= m' =>
            return false
      true

)abbrev domain SPSEG SpadSegment
SpadSegment(N : SpadNodeCategory) : ParsableCategory with
    elt : (%, "start") -> N
    elt : (%, "end") -> N
    elt : (%, "step") -> N
    construct : (N, N) -> %
    construct : (N, N, N) -> %
  == add
    Rep := Record(r_start : N, r_end : N, r_step : N)

    import SExpression

    elt(x, "start") == x.r_start
    elt(x, "end") == x.r_end
    elt(x, "step") == x.r_step

    construct(f, l, s) == [f, l, s]$Rep
    construct(f, s) == [f, emptyNode(), s]$Rep

    parse ex ==
      -- (SEGMENT first last)
      [parse ex.2, parse ex.3]

    convert x ==
      convert [convert x.start, convert x.step, convert x.end]

    coerce range ==
      (rstart, rend, rstep) := (range.start :: OutputForm,
                                range.end :: OutputForm,
                                range.step :: OutputForm)
      ofs : List OutputForm := [ rstart, ".." ]
      if not emptyNode? range.end then
        ofs := concat(ofs, [rend])
      if integer? range.step and (range.step :: Integer) ~= 1 then
        ofs := concat(ofs, ["by", rstep])
      infix(" ", ofs)

)abbrev package SPITOR SpadIterator
SpadIterator(N : SpadNodeCategory) : ParsableCategory with
    elt : (%, "var") -> Symbol
    elt : (%, "seq") -> N
    construct : (Symbol, N) -> %
  == add
    Rep := Record(i_var : Symbol, i_seq : N)

    elt(x, "var") == x.i_var
    elt(x, "seq") == x.i_seq

    construct(v, s) == [v, s]$Rep

    convert x ==
      if segment? x.seq 
        then convert [convert ("STEP" :: Symbol), convert x.var, :(destruct convert x.seq)]
        else convert [convert ("IN" :: Symbol), convert x.var, convert x.seq]

    coerce itor ==
      hconcat ["for ", itor.var :: OutputForm, " in ", itor.seq :: OutputForm]

)abbrev domain SPTEX SpadTypeExpr
SpadTypeExpr(N : SpadNodeCategory) : ParsableCategory with
    elt : (%, "kind") -> Symbol
    elt : (%, "expr") -> N
    elt : (%, "type") -> N
    construct : (Symbol, N, N) -> %
  == add
    Rep := Record(t_kind : Symbol, t_expr : N, t_type : N)

    import ParserTools
    import SExpression

    elt(x,"kind") == x.t_kind
    elt(x,"expr") == x.t_expr
    elt(x,"type") == x.t_type

    construct(k, e, t) ==
      operators : List Symbol :=
        ['case, 'has, 'is, 'pretend, ':, '::, '@, '_$]
      not member?(k, operators) =>
        error "Not a type expression operator!"
      [k, e, t]$Rep

    parse ex ==
      if domsel? ex
        then ['_$, parse ex.3, parse ex.2]
        else [symbol ex.1, parse ex.2, parse ex.3]

    convert x ==
      convert [convert x.kind, convert x.expr, convert x.type]

    coerce ex ==
      infix(" ", [ex.expr :: OutputForm,
                  ex.kind :: OutputForm,
                  ex.type :: OutputForm])

)abbrev domain SPLOOP SpadLoop
SpadLoop(N : SpadNodeCategory) : Exports == Implementation where
  K ==> Union("loop", "collect", "repeat")

  Exports ==> ParsableCategory with
    elt : (%, "kind") -> K
    elt : (%, "itors") -> List SpadIterator(N)
    elt : (%, "guards") -> List N
    elt : (%, "body") -> N
    construct : (K, List SpadIterator(N), List N, N) -> %

  Implementation ==> add
    Rep := Record(lp_kind : K,
                  lp_itors : List SpadIterator(N),
                  lp_guards : List N,
                  lp_body : N)

    import ParserTools
    import OutputForm

    elt(x, "kind") == x.lp_kind
    elt(x, "itors") == x.lp_itors
    elt(x, "guards") == x.lp_guards
    elt(x, "body") == x.lp_body

    construct(k, il, gl, b) == [k, il, gl, b]$Rep

    parse ex ==
      repeat? ex =>
        ["repeat", [], [], parse cdr ex]

      lst := destruct cdr ex
      l_body := parse(last lst) $ N
      lst := reverse(rest(reverse(lst)))

      -- print hconcat [(car ex) :: OutputForm, paren [e :: OutputForm for e in lst]]

      range : SpadSegment(N)
      l_itors : List SpadIterator(N) := []
      l_guards : List N := []

      for e in lst repeat
        -- upewnić się ze strażnikami, w collect też może być while
        itor? e =>
          -- (IN item sequence)
          l_itors := cons([symbol e.2, parse e.3], l_itors)
        step? e =>
          -- (STEP i m k n) -> i := m..n by k
          -- (STEP i m k) -> i := m.. by k
          range : SpadSegment(N) := if #e = 4
            then [parse e.3, parse e.4]
            else [parse e.3, parse e.5, parse e.4]
          l_itors := cons([symbol e.2, construct range], l_itors)
        guard? e or while? e =>
          -- should they be mixed together ?
          -- ('| cond)
          -- (WHILE cond)
          l_guards := cons(parse e.2, l_guards)
        print "------"
        print (e :: OutputForm)
        error "unrecognized loop construct"

      reverse!(l_itors)
      reverse!(l_guards)

      #l_guards > 1 => error "loop: more than one guard!"

      if collect? ex
        then ["collect", l_itors, l_guards, l_body]
        else ["loop", l_itors, l_guards, l_body]

    convert x ==
      s : String := (x.kind = "collect" => "COLLECT"; "REPEAT")
      lgs := [convert g for g in x.guards]
      lis := [convert i for i in x.itors]
      convert [convert (s :: Symbol), :lis, :lgs, convert x.body]

    coerce ex ==
      il := [ i :: OutputForm for i in ex.itors ]
      gl := [ infix(" ", ["if", g :: OutputForm]) for g in ex.guards]
      b := ex.body :: OutputForm
      ex.kind case "loop" =>
        if empty? il
          then
            loop_cond := infix(" and ", [g :: OutputForm for g in ex.guards])
            pile([hconcat ["while ", loop_cond],
                  hconcat [hspace 1, "repeat ", b]])
          else
            pile([infix(" ", concat(il, gl)),
                  hconcat [hspace 1, "repeat ", b]])
      ex.kind case "collect" =>
        infix(" ", ["[", b, :concat(il, gl), "]"])
      ex.kind case "repeat" =>
        hconcat ["repeat", b]

)abbrev domain SPLAM SpadLambda
SpadLambda(N : SpadNodeCategory) : ParsableCategory with
    elt : (%, "args") -> List(Symbol)
    elt : (%, "type") -> N
    elt : (%, "body") -> N
    construct : (List(Symbol), N, N) -> %
  == add
    Rep := Record(f_args : List(Symbol), f_type : N, f_body : N)

    import ParserTools
    import OutputForm

    elt(x, "args") == x.f_args
    elt(x, "type") == x.f_type
    elt(x, "body") == x.f_body

    construct(al, t, b) == [al, t, b]$Rep

    nameOf : SExpression -> Symbol
    nameOf s == if list? s then symbol s.2 else symbol s

    typeOf : SExpression -> SExpression
    typeOf s == if list? s then s.3 else convert []

    parse ex ==
      -- (+-> arg body)
      not list? ex.2 =>
        sig := convert [convert '_:, convert [], convert []]
        [[symbol ex.2], parse sig, parse ex.3]

      -- (+-> (: (: arg Type) RetType) body) 
      -- (+-> (: (@Tuple (: arg1 Type1) (: arg2 Type2)) RetType) body)
      (ltype, rtype) := destruct(cdr ex.2)

      largs := if tuple? ltype then destruct cdr(ltype) else [ltype]
      lsym := [nameOf arg for arg in largs]
      ltypes := [typeOf arg for arg in largs]

      sig := convert cons(convert '_:, concat(ltypes, [rtype]))

      [lsym, parse sig, parse ex.3]

    convert x == convert []

    coerce ex ==
      hconcat(["function ", paren [e :: OutputForm for e in ex.args],
               " : ", ex.type :: OutputForm, " == ", ex.body :: OutputForm])

)abbrev package SPSEQ SpadSequence
SpadSequence(N : SpadNodeCategory) : Exports == Implementation where
  K ==> Union("Capsule", "Sequence", "Tuple")

  Exports ==> ParsableCategory with
    elt : (%, "kind") -> K
    elt : (%, "list") -> List N
    construct : (K, List N) -> %

  Implementation ==> add
    Rep := Record(s_kind : K, s_list : List N)

    import OutputForm
    import ParserTools

    elt(x, "kind") == x.s_kind
    elt(x, "list") == x.s_list

    construct(k, l) == [k, l]$Rep

    parse ex ==
      content : List N := []

      for e in destruct cdr ex repeat
        var? e =>
          if listof? e.2
            then
              -- (: (LISTOF x y z ...) Type)
              varlst := destruct(cdr e.2)
              for var in varlst repeat
                sexp : N := parse (convert [convert '_:, var, e.3])
                content := [sexp, :content]
            else
              content := [(parse e) $ N, :content]

        content := [(parse e) $ N, :content]

      k : K :=
        capsule? ex => "Capsule"
        seq? ex => "Sequence"
        tuple? ex => "Tuple"

      [k, reverse content]

    convert x ==
      s : String :=
        x.kind case "Capsule" => "CAPSULE"
        x.kind case "Sequence" => "SEQ"
        x.kind case "Tuple" => "@Tuple"
      
      convert cons(convert (s :: Symbol), [convert i for i in x.list])

    coerce ex ==
      lst := [ e :: OutputForm for e in ex.list | not emptyNode? e ]
      ex.kind case "Sequence" or ex.kind case "Capsule" => pile lst
      ex.kind case "Tuple" => paren lst

)abbrev package SPCOND SpadConditional
SpadConditional(N : SpadNodeCategory) : ParsableCategory with
    elt : (%, "cond") -> N
    elt : (%, "truebr") -> N
    elt : (%, "falsebr") -> N
    construct : (N, N, N) -> %
  == add
    Rep := Record(c_cond : N, c_true : N, c_false : N)

    import ParserTools
    import OutputForm

    elt(x, "cond") == x.c_cond
    elt(x, "truebr") == x.c_true
    elt(x, "falsebr") == x.c_false

    convert x ==
      convert [convert ("IF" :: Symbol), convert x.cond, convert x.truebr, convert x.falsebr]

    construct(c, tb, fb) == [c, tb, fb]$Rep

    parse ex ==
      -- (IF condition expr1 expr2)
      -- (IF condition expr 'noBranch)
      -- (IF condition 'noBranch expr)
      (c, l, r) := (ex.2, ex.3, ex.4)
      nobranch? l =>
        pc : N := parse (convert [convert '_not, c])
        [pc, parse r, emptyNode()]
      nobranch? r =>
        [parse c, parse l, emptyNode()]
      [parse c, parse l, parse r]

    coerce c ==
      emptyNode? c.falsebr =>
        pile([hconcat ["if ", c.cond :: OutputForm],
              hconcat [hspace 1, "then ", c.truebr :: OutputForm]])
      pile([hconcat ["if ", c.cond :: OutputForm],
            hconcat [hspace 1, "then ", c.truebr :: OutputForm],
            hconcat [hspace 1, "else ", c.falsebr :: OutputForm]])

)abbrev package SPFN SpadFunction
++ SPAD function
SpadFunction(N : SpadNodeCategory) : Exports == Implementation where
  NT ==> SpadNamedType(N)
  MT ==> SpadMappingType(N)
  ARG ==> Union(String, NT)

  Exports ==> ParsableCategory with
    elt : (%, "name") -> Symbol
    elt : (%, "args") -> List(ARG)
    elt : (%, "type") -> N
    elt : (%, "body") -> N
    construct : (Symbol, List(ARG), N, N) -> %
      ++ construct(name,varlist,type,exp)
    signature : % -> NT

  Implementation ==> add
    Rep := Record(fn_name : Symbol,
                  fn_args : List(ARG),
                  fn_type : N,
                  fn_body : N)

    import OutputForm
    import ParserTools
    import SExpression
    import NT

    elt(x, "name") == x.fn_name
    elt(x, "args") == x.fn_args
    elt(x, "type") == x.fn_type
    elt(x, "body") == x.fn_body

    construct(fname, fargs, ftype, fbody) == 
      [fname, fargs, ftype, fbody]$Rep

    parse_arg : (SExpression, SExpression) -> ARG
    parse_arg(s, t) ==
      string? s =>
        string s
      [symbol s, parseNonNull t]

    parse ex ==
      fname := symbol car(ex.2)
      arg_names := destruct cdr(ex.2)
      arg_types := destruct cdr(ex.3)
      fargs := [parse_arg(s, t) for s in arg_names for t in arg_types]
      ftype := car ex.3
      fbody := ex.5 -- convert [ex.5]
      [fname, fargs, parseNonNull ftype, parse fbody]

    convert x ==
      arg_names := [convert (arg :: NT).name for arg in x.args]
      types := [convert (arg :: NT).type for arg in x.args]
      types' := [convert [] for i in 0..#x.args]
      fbody := destruct convert x.body
      convert([convert ("DEF" :: Symbol),
               convert [convert x.name, :arg_names],
               convert [convert x.type, :types],
               convert types',
               :fbody])

    signature fn ==
      types := [(if arg case String then emptyNode() else arg.type) for arg in fn.args]
      [fn.name, [[types, fn.type] $ MT]]

    coerce fn ==
      fargs := [ arg :: OutputForm for arg in fn.fn_args ]
      fbody := [ fn.fn_body :: OutputForm ]
      retType := if emptyNode? fn.fn_type
        then "" :: OutputForm
        else hconcat([" : ", fn.fn_type :: OutputForm])
      hconcat([fn.fn_name :: OutputForm,
               paren fargs, retType,
               " == ", pile fbody, ""])

)abbrev package SPMACRO SpadMacro
++ SPAD macro representation
SpadMacro(N : SpadNodeCategory) : ParsableCategory with
    elt : (%, "name") -> Symbol
    elt : (%, "args") -> List Symbol
    elt : (%, "body") -> N
    construct : (Symbol, List Symbol, N) -> %
      ++ construct(name,args,exp)
  == add
    Rep := Record(md_name : Symbol,
                  md_args : List Symbol,
                  md_body : N)

    import OutputForm
    import ParserTools

    elt(x, "name") == x.md_name
    elt(x, "args") == x.md_args
    elt(x, "body") == x.md_body

    construct(mname, margs, mbody) ==
      [mname, margs, mbody]$Rep

    parse ex ==
      mname := symbol car(ex.2)
      margs := [ symbol s for s in destruct(cdr(ex.2)) ]
      mbody : N := parse ex.5
      [mname, margs, mbody]

    convert x == convert []

    coerce m ==
      margs := 
        if null m.md_args
          then "" :: OutputForm
          else paren [ arg :: OutputForm for arg in m.md_args ]
      hconcat([m.md_name :: OutputForm,
               margs, " ==> ", pile [m.md_body :: OutputForm]])

)abbrev package SPWHERE SpadWhere
SpadWhere(N : SpadNodeCategory) : ParsableCategory with
    elt : (%, "body") -> N
    elt : (%, "env") -> N
    construct : (N, N) -> %
  == add
    Rep := Record(w_body : N, w_env : N)

    import OutputForm
    import ParserTools

    elt(x, "body") == x.w_body
    elt(x, "env") == x.w_env

    construct(d, e) == [d, e]$Rep

    parse ex ==
      [(parse ex.2) $ N, (parse ex.3) $ N]

    convert x == convert []

    coerce w ==
      hconcat [w.body :: OutputForm, " where ", w.env :: OutputForm]

)abbrev package SPFTOR SpadFunctor
++ SPAD functor representation
SpadFunctor(N : SpadNodeCategory) : Exports == Implementation where
  NT ==> SpadNamedType(N)
  MT ==> SpadMappingType(N)

  Exports ==> ParsableCategory with
    elt : (%, "name") -> Symbol
    elt : (%, "args") -> List NT
    elt : (%, "type") -> N
    elt : (%, "extends") -> N
    elt : (%, "capsule") -> N
    construct : (Symbol, List NT, N, N, N) -> %
    signature : % -> NT

  Implementation ==> add
    Rep := Record(f_name : Symbol,
                  f_args : List NT,
                  f_type : N,
                  f_extends : N,
                  f_capsule : N)

    import OutputForm
    import ParserTools
    import SExpression
    import SpadNode

    SEX ==> SExpression

    elt(x, "name") == x.f_name
    elt(x, "args") == x.f_args
    elt(x, "type") == x.f_type
    elt(x, "extends") == x.f_extends
    elt(x, "capsule") == x.f_capsule

    construct(n, al, t, e, c) == [n, al, t, e, c]$Rep

    parse ex ==
      arg_names := destruct cdr(ex.2)
      arg_types := destruct cdr(ex.3)
      fname := symbol car(ex.2)
      ftype := car ex.3
      fbody := ex.5
      fargs : List NT :=
        [[symbol s, parse t] for s in arg_names for t in arg_types]
      fcapsule := if symbol(car fbody) = 'add then fbody.3 else fbody
      fextends := if symbol(car fbody) = 'add then fbody.2 else convert []
      [fname, fargs, parse ftype, parseNonNull fextends, parse fcapsule]

    convert x ==
      arg_names := [convert arg.name for arg in x.args]
      arg_types := [convert arg.type for arg in x.args]
      convert([convert 'DEF,
               convert [convert x.name, :arg_names],
               convert [convert x.type, :arg_types],
               convert [convert [] for i in 0..#x.args],
               convert x.capsule])

    coerce f ==
      hconcat([f.name :: OutputForm,
               paren [arg :: OutputForm for arg in f.args], " : ", 
               f.type :: OutputForm, " == ",
               f.extends :: OutputForm, " add ",
               hconcat [hspace 2, f.capsule :: OutputForm]])

    signature ft ==
      [ft.name, [[[arg.type for arg in ft.args], ft.type] $ MT]]

)abbrev domain SPNODE SpadNode
++ SPAD generic expression
SpadNode() : SpadNodeCategory == add
    Rep := Union(empty : "$EmptyNode",
                 apply : SpadApply(%),
                 assign : SpadAssign(%),
                 cond : SpadConditional(%),
                 lambda : SpadLambda(%),
                 loop : SpadLoop(%),
                 mapping : SpadMappingType(%),
                 named : SpadNamedType(%),
                 record : SpadRecordType(%),
                 segment : SpadSegment(%),
                 seq : SpadSequence(%),
                 ftor : SpadFunctor(%),
                 func : SpadFunction(%),
                 simport : SpadImport(%),
                 smacro : SpadMacro(%),
                 sum : SpadSumType(%),
                 swhere : SpadWhere(%),
                 typeexpr : SpadTypeExpr(%),
                 union : SpadUnionType(%),
                 marker : SpadMarker(%),
                 dfloat : DoubleFloat,
                 integer : Integer,
                 string : String,
                 symbol : Symbol)

    import OutputForm
    import SExpression
    import ParserTools

    apply? n == n case apply
    assign? n == n case assign
    conditional? n == n case cond
    float? n == n case dfloat
    function? n == n case func
    functor? n == n case ftor
    import? n == n case simport
    integer? n == n case integer
    lambda? n == n case lambda
    loop? n == n case loop 
    macro? n == n case smacro 
    mappingType? n == n case mapping 
    marker? n == n case marker
    namedType? n == n case named
    nodeRef? n == n case marker and (n :: SpadMarker(%)).kind = 'noderef
    recordType? n == n case record
    segment? n == n case segment 
    sequence? n == n case seq
    string? n == n case string
    sumType? n == n case sum
    symbol? n == n case symbol
    typeExpr? n == n case typeexpr
    unionType? n == n case union
    where? n == n case swhere
    typeVar? n == n case marker and (n :: SpadMarker(%)).kind = 'typevar

    CoerceError(T) ==>
      error concat ["Cannot coerce SpadNode to ", T, "!"]

    coerce (n : %) : SpadApply(%) ==
      apply? n => n.apply
      CoerceError("SpadApply")

    coerce (n : %) : SpadAssign(%) ==
      assign? n => n.assign
      CoerceError("SpadAssign")

    coerce (n : %) : SpadConditional(%) ==
      conditional? n => n.cond
      CoerceError("SpadConditional")

    coerce (n : %) : SpadFunction(%) ==
      function? n => n.func
      CoerceError("SpadFunction")

    coerce (n : %) : SpadFunctor(%) ==
      functor? n => n.ftor
      CoerceError("SpadFunctor")

    coerce (n : %) : SpadImport(%) ==
      import? n => n.simport
      CoerceError("SpadImport")

    coerce (n : %) : SpadLambda(%) == 
      lambda? n => n.lambda
      CoerceError("SpadLambda")

    coerce (n : %) : SpadLoop(%) ==
      loop? n => n.loop
      CoerceError("SpadLoop")

    coerce (n : %) : SpadMacro(%) ==
      macro? n => n.smacro
      CoerceError("SpadMacro")

    coerce (n : %) : SpadMappingType(%) == 
      mappingType? n => n.mapping
      CoerceError("SpadMappingType")

    coerce (n : %) : SpadMarker(%) == 
      marker? n => n.marker
      CoerceError("SpadMarker")

    coerce (n : %) : SpadNamedType(%) ==
      namedType? n => n.named
      CoerceError("SpadNamedType")

    coerce (n : %) : SpadRecordType(%) ==
      recordType? n => n.record
      CoerceError("SpadRecordType")

    coerce (n : %) : SpadSegment(%) ==
      segment? n => n.segment
      CoerceError("SpadSegment")

    coerce (n : %) : SpadSequence(%) ==
      sequence? n => n.seq
      CoerceError("SpadSequence")

    coerce (n : %) : SpadSumType(%) ==
      sumType? n => n.sum
      CoerceError("SpadSumType")

    coerce (n : %) : SpadTypeExpr(%) ==
      typeExpr? n => n.typeexpr
      CoerceError("SpadTypeExpr")

    coerce (n : %) : SpadUnionType(%) ==
      unionType? n => n.union
      CoerceError("SpadUnionType")

    coerce (n : %) : SpadWhere(%) ==
      where? n => n.swhere
      CoerceError("SpadWhere")

    coerce (n : %) : DoubleFloat ==
      float? n => n.dfloat
      CoerceError("DoubleFloat")

    coerce (n : %) : Integer ==
      integer? n => n.integer
      CoerceError("Integer")

    coerce (n : %) : Symbol ==
      symbol? n => n.symbol
      CoerceError("Symbol")

    coerce (n : %) : String == 
      string? n => n.string
      CoerceError("String")

    emptyNode () == ["$EmptyNode"]$Rep
    emptyNode? n == n case empty

    value? n == float? n or integer? n or string? n or symbol? n

    constructor? s ==
      sex : SExpression := GETDATABASE(s, 'ABBREVIATION)$Lisp
      not null? sex

    construct (n : SpadApply(%)) : % == [n]$Rep
    construct (n : SpadAssign(%)) : % == [n]$Rep
    construct (n : SpadConditional(%)) : % == [n]$Rep
    construct (n : SpadFunction(%)) : % == [n]$Rep
    construct (n : SpadFunctor(%)) : % == [n]$Rep
    construct (n : SpadImport(%)) : % == [n]$Rep
    construct (n : SpadLambda(%)) : % == [n]$Rep
    construct (n : SpadLoop(%)) : % == [n]$Rep
    construct (n : SpadMacro(%)) : % == [n]$Rep
    construct (n : SpadMappingType(%)) : % == [n]$Rep
    construct (n : SpadMarker(%)) : % == [n]$Rep
    construct (n : SpadNamedType(%)) : % == [n]$Rep
    construct (n : SpadRecordType(%)) : % == [n]$Rep
    construct (n : SpadSegment(%)) : % == [n]$Rep
    construct (n : SpadSequence(%)) : % == [n]$Rep
    construct (n : SpadSumType(%)) : % == [n]$Rep
    construct (n : SpadTypeExpr(%)) : % == [n]$Rep
    construct (n : SpadUnionType(%)) : % == [n]$Rep
    construct (n : SpadWhere(%)) : % == [n]$Rep

    construct (n : DoubleFloat) : % == [n]$Rep
    construct (n : Integer) : % == [n]$Rep
    construct (n : String) : % == [n]$Rep
    construct (n : Symbol) : % == [n]$Rep

    parseNonNull ex ==
      null? ex => emptyNode()
      parse ex

    parse ex ==
      -- print (hconcat ["expression: ", ex :: OutputForm])

      import? ex =>
        [(parse ex) $ SpadImport(%)]

      capsule? ex or seq? ex or tuple? ex =>
        -- (SEQ expr1 expr2 ...)
        -- (CAPSULE expr1 expr2 ...)
        -- (@Tuple expr1 expr2 ...)
        [(parse ex) $ SpadSequence(%)]

      where? ex =>
        [(parse ex) $ SpadWhere(%)]

      lambda? ex =>
        [(parse ex) $ SpadLambda(%)]

      functor? ex =>
        [(parse ex) $ SpadFunctor(%)]

      function? ex =>
        [(parse ex) $ SpadFunction(%)]

      macro? ex =>
        [(parse ex) $ SpadMacro(%)]

      marker? ex =>
        [(parse ex) $ SpadMarker(%)]

      (var? ex or case? ex or has? ex or is? ex or pretend? ex or coerce? ex or
       domsel? ex or retsel? ex) => 
        -- {expression with type annotation}
        -- (: expr Type) 
        -- {expression with "case" operator}
        -- (case expr Type)
        -- {expression with "has" operator}
        -- (has expr Type)
        -- {expression with "is" operator}
        -- (is expr Type)
        -- {expression with "pretend" operator}
        -- (pretend expr Type)
        -- {expression with "::" coerce operator}
        -- (:: expr Type)
        -- {expression with "@" return type selection operator}
        -- (@ expr Type)
        -- {expression with "$" domain selection operator}
        -- (Sel expr Type)
        [(parse ex) $ SpadTypeExpr(%)]

      let? ex =>
        [(parse ex) $ SpadAssign(%)]

      ifelse? ex =>
        -- {if-then-else expression of if-then statement}
        [(parse ex) $ SpadConditional(%)]

      collect? ex or loop? ex or repeat? ex =>
        [(parse ex) $ SpadLoop(%)]

      mapping? ex => 
        -- TODO: var? ex is missing after collapsing Node and Type
        [(parse ex) $ SpadMappingType(%)]

      domain? ex or package? ex or join? ex or progn? ex =>
        [(parse ex) $ SpadSumType(%)]

      signature? ex =>
        [(parse ex) $ SpadNamedType(%)]

      record? ex =>
        [(parse ex) $ SpadRecordType(%)]

      union? ex => 
        [(parse ex) $ SpadUnionType(%)]

      list? ex and #ex > 0 =>
        [(parse ex) $ SpadApply(%)]

      string? ex =>
        [string ex]

      symbol? ex =>
        s := symbol ex
        -- BUG: this doesn't work and no warning is issued...
        -- if s = '$ then s := '%
        [if s = '$ then s := coerce "%" else s]

      integer? ex =>
        [integer ex]

      float? ex =>
        [float ex]

      null? ex =>
        emptyNode()

      print "parse $ SpadNode:"
      print (ex :: OutputForm)
      error "SExpression not handled!"

    coerce (n : %) : OutputForm ==
      apply? n => (n :: SpadApply(%)) :: OutputForm
      assign? n => (n :: SpadAssign(%)) :: OutputForm
      conditional? n => (n :: SpadConditional(%)) :: OutputForm
      float? n => (n :: DoubleFloat) :: OutputForm
      function? n => (n :: SpadFunction(%)) :: OutputForm
      functor? n => (n :: SpadFunctor(%)) :: OutputForm
      import? n => (n :: SpadImport(%)) :: OutputForm
      integer? n => (n :: Integer) :: OutputForm
      lambda? n => (n :: SpadLambda(%)) :: OutputForm
      loop? n => (n :: SpadLoop(%)) :: OutputForm
      macro? n => (n :: SpadMacro(%)) :: OutputForm
      mappingType? n => (n :: SpadMappingType(%)) :: OutputForm
      marker? n => (n :: SpadMarker(%)) :: OutputForm
      namedType? n => (n :: SpadNamedType(%)) :: OutputForm
      recordType? n => (n :: SpadRecordType(%)) :: OutputForm
      segment? n => (n :: SpadSegment(%)) :: OutputForm
      sequence? n => (n :: SpadSequence(%)) :: OutputForm
      string? n => (n :: String) :: OutputForm
      sumType? n => (n :: SpadSumType(%)) :: OutputForm
      symbol? n => (n :: Symbol) :: OutputForm
      typeExpr? n => (n :: SpadTypeExpr(%)) :: OutputForm
      unionType? n => (n :: SpadUnionType(%)) :: OutputForm
      where? n => (n :: SpadWhere(%)) :: OutputForm
      emptyNode? n => "?"

      error "coerce $ SpadNode: variant not handled!"

    convert n ==
      apply? n => convert(n :: SpadApply(%))
      assign? n => convert(n :: SpadAssign(%))
      conditional? n => convert(n :: SpadConditional(%))
      float? n => convert(n :: DoubleFloat)
      function? n => convert(n :: SpadFunction(%))
      functor? n => convert(n :: SpadFunctor(%))
      import? n => convert(n :: SpadImport(%))
      integer? n => convert(n :: Integer)
      lambda? n => convert(n :: SpadLambda(%))
      loop? n => convert(n :: SpadLoop(%))
      macro? n => convert(n :: SpadMacro(%))
      mappingType? n => convert(n :: SpadMappingType(%))
      marker? n => convert(n :: SpadMarker(%))
      namedType? n => convert(n :: SpadNamedType(%))
      recordType? n => convert(n :: SpadRecordType(%))
      segment? n => convert(n :: SpadSegment(%))
      sequence? n => convert(n :: SpadSequence(%))
      string? n => convert(n :: String)
      sumType? n => convert(n :: SpadSumType(%))
      symbol? n => convert(n :: Symbol)
      typeExpr? n => convert(n :: SpadTypeExpr(%))
      unionType? n => convert(n :: SpadUnionType(%))
      where? n => convert(n :: SpadWhere(%))
      emptyNode? n => convert []

      error "convert $ SpadNode: variant not handled!"

    n = m ==
      -- defined only for nodes that can represent types
      apply? n and apply? m =>
        (n :: SpadApply(%)) = (m :: SpadApply(%))
      float? n and float? m =>
        (n :: DoubleFloat) = (m :: DoubleFloat)
      function? n and function? m =>
        (n :: SpadFunction(%)) = (m :: SpadFunction(%))
      integer? n and integer? m =>
        (n :: Integer) = (m :: Integer)
      mappingType? n and mappingType? m =>
        (n :: SpadMappingType(%)) = (m :: SpadMappingType(%))
      marker? n and marker? m =>
        (n :: SpadMarker(%)) = (m :: SpadMarker(%))
      namedType? n and namedType? m =>
        (n :: SpadNamedType(%)) = (m :: SpadNamedType(%))
      recordType? n and recordType? m =>
        (n :: SpadRecordType(%)) = (m :: SpadRecordType(%))
      string? n and string? m =>
        (n :: String) = (m :: String)
      sumType? n and sumType? m =>
        (n :: SpadSumType(%)) = (m :: SpadSumType(%))
      symbol? n and symbol? m =>
        (n :: Symbol) = (m :: Symbol)
      unionType? n and unionType? m =>
        (n :: SpadUnionType(%)) = (m :: SpadUnionType(%))
      emptyNode? n and emptyNode? m =>
        true
      false
