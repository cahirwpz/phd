)abbrev category SPNODEC SpadNodeCategory
SpadNodeCategory() : Category == ParsableCategory with
  construct : SpadApply(%) -> %
  construct : SpadAssign(%) -> %
  construct : SpadCondExpr(%) -> %
  construct : SpadFunction(%) -> %
  construct : SpadFunctor(%) -> %
  construct : SpadImport(%) -> %
  construct : SpadLambda(%) -> %
  construct : SpadLoop(%) -> %
  construct : SpadMacro(%) -> %
  construct : SpadMappingType(%) -> %
  construct : SpadMarker(%) -> %
  construct : SpadNamedType(%) -> %
  construct : SpadRecordType(%) -> %
  construct : SpadSegment(%) -> %
  construct : SpadSequence(%) -> %
  construct : SpadSumType(%) -> %
  construct : SpadTypeExpr(%) -> %
  construct : SpadUnionType(%) -> %
  construct : SpadWhere(%) -> %

  construct : DoubleFloat -> %
  construct : Integer -> %
  construct : String -> %
  construct : Symbol -> %

  emptyNode : () -> %

  apply? : % -> Boolean
  assign? : % -> Boolean
  condExpr? : % -> Boolean
  emptyNode? : % -> Boolean
  float? : % -> Boolean
  function? : % -> Boolean
  functor? : % -> Boolean
  import? : % -> Boolean
  integer? : % -> Boolean
  lambda? : % -> Boolean
  loop? : % -> Boolean
  macro? : % -> Boolean
  mappingType? : % -> Boolean
  marker? : % -> Boolean
  namedType? : % -> Boolean
  nodeRef? : % -> Boolean
  recordType? : % -> Boolean
  segment? : % -> Boolean
  sequence? : % -> Boolean
  string? : % -> Boolean
  sumType? : % -> Boolean
  symbol? : % -> Boolean
  typeExpr? : % -> Boolean
  typeOrigin? : % -> Boolean
  unionType? : % -> Boolean
  where? : % -> Boolean
  typeAny? : % -> Boolean
  typeVar? : % -> Boolean

  coerce : % -> DoubleFloat
  coerce : % -> Integer
  coerce : % -> SpadApply(%)
  coerce : % -> SpadAssign(%)
  coerce : % -> SpadCondExpr(%)
  coerce : % -> SpadFunction(%)
  coerce : % -> SpadFunctor(%)
  coerce : % -> SpadImport(%)
  coerce : % -> SpadLambda(%)
  coerce : % -> SpadLoop(%)
  coerce : % -> SpadMacro(%)
  coerce : % -> SpadMappingType(%)
  coerce : % -> SpadMarker(%)
  coerce : % -> SpadNamedType(%)
  coerce : % -> SpadRecordType(%)
  coerce : % -> SpadSegment(%)
  coerce : % -> SpadSequence(%)
  coerce : % -> SpadSumType(%)
  coerce : % -> SpadTypeExpr(%)
  coerce : % -> SpadUnionType(%)
  coerce : % -> SpadWhere(%)
  coerce : % -> String
  coerce : % -> Symbol

  convert : % -> SExpression

  constructor? : Symbol -> Boolean

  parseNonNull : SExpression -> %

)abbrev domain SPMARK SpadMarker
SpadMarker(N : SpadNodeCategory) : Exports == Implementation where
  NNI ==> NonNegativeInteger
  PF ==> PrintableForm

  Exports ==> Join(ParsableCategory, CoercibleTo(Symbol)) with
    elt : (%, "id") -> NNI
    elt : (%, "kind") -> Symbol
    construct : (NNI, Symbol) -> %

  Implementation ==> add
    Rep := Record(m_id : NNI, m_kind : Symbol)

    import ParserTools

    elt(x, "id") == x.m_id
    elt(x, "kind") == x.m_kind

    construct(i, k) == [i, k]$Rep

    parse ex ==
      [(integer ex.2) :: NNI, symbol ex.3]

    convert x ==
      convert [convert("@Marker" :: Symbol), convert x.id, convert x.kind]

    n = m ==
      (n.id = m.id) and (n.kind = m.kind)

    coerce (m : %) : Symbol ==
      s : String :=
        m.kind = 'typevar => "%"
        m.kind = 'noderef => "#"
        "%"
      n : String :=
        m.id > 0 => string(m.id :: Integer)
        "?"
      concat(s, n) :: Symbol

    coerce (n : %) : PF ==
      (n :: Symbol) :: PF

)abbrev domain SPTMAP SpadMappingType
SpadMappingType(N : SpadNodeCategory) : Exports == Implementation where
  PF ==> PrintableForm

  Exports ==> ParsableCategory with
    elt : (%, "args") -> List(N)
    elt : (%, "type") -> N
    construct : (List(N), N) -> %

  Implementation ==> add
    Rep := Record(m_args : List(N), m_type : N)

    import ParserTools
    import SExpression

    elt(x, "args") == x.m_args
    elt(x, "type") == x.m_type

    construct(al, t) == [al, t]$Rep

    parseFunType : SExpression -> N
    parseFunType s ==
      if firstSymbol? (s, ':) then parse s.3 else parse s
        
    parse ex ==
      sig : List(N) := [ parseFunType e for e in destruct cdr ex ]
      [ rest sig, first sig ]

    convert x ==
      ts := [convert t for t in [x.type, :x.args]]
      convert [convert ("Mapping" :: Symbol), :ts]

    coerce n ==
      coerceType (t : N) : PF ==
        if emptyNode? t then "?" :: PF else t :: PF
      ts := [coerceType t for t in n.args]
      src := if #ts ~= 1 then paren ts else first ts
      spaces [src, "->" :: PF, coerceType n.type]

    n = m ==
      for n' in [n.type, :n.args]
        for m' in [m.type, :m.args] repeat
          n' ~= m' => return false
      true

)abbrev domain SPTSUM SpadSumType
SpadSumType(N : SpadNodeCategory) : Exports == Implementation where
  K ==> Union("Join", "Domain", "Package", "Body")
  PF ==> PrintableForm

  Exports ==> ParsableCategory with
    elt : (%, "types") -> List(N)
    elt : (%, "kind") -> K
    construct : (K, List(N)) -> %

  Implementation ==> add
    Rep := Record(s_kind : K, s_types : List(N))

    import ParserTools
    import SExpression

    elt(x, "kind") == x.s_kind
    elt(x, "types") == x.s_types

    construct(k, tl) == [k, tl]$Rep

    parse ex ==
      lst :=
        domain? ex or package? ex =>
          -- (CATEGORY domain ...)
          -- (CATEGORY package ...)
          destruct cdr(cdr(ex))
        join? ex or progn? ex =>
          -- (Join ...)
          -- (PROGN ...)
          destruct cdr(ex)

      args : List(N) := [ parse e for e in lst ]

      domain? ex => ["Domain", args]
      package? ex => ["Package", args]
      join? ex => ["Join", args]
      progn? ex => ["Body", args]

    convert x ==
      ts := [convert t for t in x.types]
      ls :=
        x.kind case "Join" =>
          [convert ("Join" :: Symbol), :ts]
        x.kind case "Domain" =>
          [convert ("CATEGORY" :: Symbol), convert ("domain" :: Symbol), :ts]
        x.kind case "Package" =>
          [convert ("CATEGORY" :: Symbol), convert ("package" :: Symbol), :ts]
        x.kind case "Body" =>
          [convert ("PROGN" :: Symbol), :ts]
      convert ls

    coerce n ==
      ts := [ t :: PF for t in n.types ]
      n.kind case "Join" =>
        hconcat ["Join" :: PF, paren ts]
      -- indent(2, pile ["with", :ts])
      brace ts

)abbrev domain SPTNAMED SpadNamedType
SpadNamedType(N : SpadNodeCategory) : Exports == Implementation where
  PF ==> PrintableForm

  Exports ==> ParsableCategory with
    elt : (%, "name") -> Symbol
    elt : (%, "type") -> N
    construct : (Symbol, N) -> %
      ++ construct(name,type)
    construct : Symbol -> %
      ++ construct(name)

  Implementation ==> add
    Rep := Record(n_name : Symbol, n_type : N)

    import ParserTools
    import SExpression

    elt(x, "name") == x.n_name
    elt(x, "type") == x.n_type

    construct(n, t) == [n, t]$Rep
    construct(n) == [n, emptyNode()]$Rep

    parse ex ==
      var? ex =>
        -- (: field Type)
        [symbol ex.2, parseNonNull ex.3]
      symbol? ex =>
        [symbol ex]
      signature? ex =>
        -- (SIGNATURE name (RetType Arg1Type Arg2Type ...))
        -- (SIGNATURE name Type constant)
        res : N := parse car ex.3
        targs : List(N) := if #ex = 3
          then [parse e for e in destruct cdr ex.3]
          else [parse ex.4 ]
        [symbol ex.2, [[targs, res] $ SpadMappingType(N)]]
      error "Cannot parse named type!"

    convert x ==
      if mappingType? x.type then
        convert [convert ("SIGNATURE" :: Symbol), convert x.name, cdr convert x.type]
      else
        convert [convert (":" :: Symbol), convert x.name, convert x.type]

    coerce n ==
      typeName : PF := if emptyNode? n.type then "?" :: PF else n.type :: PF
      spaces [n.name :: PF, ":" :: PF, typeName]

)abbrev domain SPTREC SpadRecordType
SpadRecordType(N : SpadNodeCategory) : Exports == Implementation where
  PF ==> PrintableForm
  NT ==> SpadNamedType(N)

  Exports ==> ParsableCategory with
    elt : (%, "fields") -> List(NT)
    construct : List(NT) -> %
    wellFormed : % -> Boolean

  Implementation ==> add
    Rep := Record(r_fields : List(NT))

    import ParserTools
    import SExpression
    import Logger('Parser)

    elt(x, "fields") == x.r_fields

    construct fl ==
      r := [fl]$Rep
      not wellFormed r =>
        fail ["Malformed type" :: PF, bold(r :: PF), "!" :: PF]
        error ""
      r

    wellFormed x ==
      names : List(Symbol) := []
      for f in x.r_fields repeat ++ BUG? runtime crashes when using "x.fields"
        not (recordType? f.type or unionType? f.type or mappingType? f.type or
             apply? f.type or string? f.type or symbol? f.type) =>
          warn ["Record has a field with wrong type:" :: PF, bold(f :: PF)]
          return false
        member?(f.name, names) =>
          warn (["Record has two fields with the same identifier" :: PF,
                 string bold(f.name :: PF), "!" :: PF])
          return false
        names := [f.name, :names]
      true

    parse ex ==
      -- (Record (: field1 Type1) (: field2 Type2) ...)
      fields : List(NT) := []
      for field in destruct cdr ex repeat
        not var? field =>
          fail (["Cannot parse a record type" :: PF, bold convert(ex),
                 "- malformed field" :: PF, bold convert(field), "!":: PF])
          error ""
        fields := [[symbol field.2, parse field.3], :fields]
      [reverse fields]

    convert x ==
      fs := [convert f for f in x.fields]
      convert [convert ("Record" :: Symbol), :fs]

    coerce n ==
      hconcat ["Record" :: PF, paren [f :: PF for f in n.fields]]

)abbrev domain SPTUNION SpadUnionType
SpadUnionType(N : SpadNodeCategory) : Exports == Implementation where
  NT ==> SpadNamedType(N)
  PF ==> PrintableForm

  Exports ==> ParsableCategory with
    elt : (%, "variants") -> List(N)
    wellFormed : % -> Boolean
    construct : List(N) -> %

  Implementation ==> add
    Rep := Record(u_variants : List(N))

    import ParserTools
    import SExpression
    import Logger('Parser)

    elt(x, "variants") == x.u_variants

    wellFormed x ==
      ++ tagged union
      namedType? (first x.variants) =>
        names : List(Symbol) := []
        for v in x.variants repeat
          not namedType? v =>
            warn ("Mixing tagged and untagged variants is not allowed." :: PF)
            return false
          n := v :: NT 
          not (recordType? n.type or unionType? n.type or mappingType? n.type or
               apply? n.type or string? n.type or symbol? n.type) =>
            warn (["Unions has a variant" :: PF, string(n.name :: PF),
                   "with wrong type:" :: PF, n.type :: PF])
            return false
          member?(n.name, names) =>
            warn (["Union has two variants with the same identifier:" :: PF,
                   string(n.name :: PF)])
            return false
          names := [n.name, :names]
        true

      ++ untagged union
      types : List(N) := []
      for t in x.variants repeat
        namedType? t =>
          warn ("Mixing tagged and untagged variants is not allowed." :: PF)
          return false
        not (recordType? t or unionType? t or mappingType? t or
             apply? t or string? t or symbol? t) =>
          warn ["Union has a variant with wrong type:" :: PF, t :: PF]
          return false
        member?(t, types) =>
          warn ["Union has two variants with the same type:" :: PF, t :: PF]
          return false
        types := [t, :types]
      true

    construct vl ==
      union := [vl]$Rep
      not wellFormed union =>
        fail ["Malformed union:" :: PF, union :: PF]
        error ""
      union

    parse ex ==
      -- (Union (: field1 Type1) (: field2 Type2) ...)
      -- (Union Type1 Type2 ...)
      parseUnionField (s : SExpression) : N ==
        if var? s then [[symbol s.2, parse s.3]$NT] else parse s
      [[parseUnionField e for e in destruct cdr ex]]

    convert x ==
      vs := [convert v for v in x.variants]
      convert [convert ("Union" :: Symbol), :vs]

    coerce n ==
      hconcat ["Union" :: PF, paren [v :: PF for v in n.variants]]

)abbrev domain SPIMP SpadImport
++ SPAD domain / category / package import declaration
SpadImport(N : SpadNodeCategory) : Exports == Implementation where
  PF ==> PrintableForm

  Exports ==> ParsableCategory with
    elt : (%, "type") -> N
    construct : N -> %

  Implementation ==> add
    Rep := Record(i_type : N)

    import SExpression

    elt(x, "type") == x.i_type

    construct x == [x]$Rep

    parse ex ==
      [parse ex.2]

    convert x == convert [convert ("import" :: Symbol), convert x.type]

    coerce n ==
      spaces ["import" :: PF, n.type :: PF]

)abbrev domain SPASS SpadAssign
SpadAssign(N : SpadNodeCategory) : Exports == Implementation where
  PF ==> PrintableForm

  Exports ==> ParsableCategory with
    elt : (%, "lval") -> N
    elt : (%, "rval") -> N
    construct : (N, N) -> %

  Implementation ==> add
    Rep := Record(a_lval : N, a_rval : N)

    import SExpression

    elt(x, "lval") == x.a_lval
    elt(x, "rval") == x.a_rval

    construct(lv, rv) == [lv, rv]$Rep

    parse ex ==
      -- (LET expr value)
      [parse ex.2, parse ex.3]

    convert x ==
      convert [convert ("LET" :: Symbol), convert x.lval, convert x.rval]

    coerce n ==
      spaces [n.lval :: PF, ":=" :: PF, n.rval :: PF]

)abbrev domain SPAPP SpadApply
SpadApply(N : SpadNodeCategory) : Exports == Implementation where
  PF ==> PrintableForm

  Exports ==> ParsableCategory with
    elt : (%, "function") -> N
    elt : (%, "args") -> List(N)
    construct : (N, List(N)) -> %

  Implementation ==> add
    Rep := Record(a_fn : N, a_args : List(N))

    import String
    import SExpression

    elt(x, "function") == x.a_fn
    elt(x, "args") == x.a_args

    construct (fn, lst) == [fn, lst]$Rep

    parse ex ==
      lst : List(N) := [parse e for e in destruct ex]
      [first lst, rest lst]

    convert x ==
      convert [convert i for i in [x.function, :x.args]]

    binop : List(Symbol) :=
      ['_-, '_+, '_*, '_/, '_^, '_=, '_~_=, '_<, '_>, '_<_=, '_>_=, 'OR, 'AND, 'or, 'and]

    coerce(n : %) : PF ==
      fun := n.function
      argl : List(PF) := [arg :: PF for arg in n.args]

      not (symbol? fun or marker? fun) =>
        #argl = 0 => fun :: PF
        hconcat [paren(fun :: PF), paren argl]

      funSym :=
        marker? fun =>
          (fun :: SpadMarker(N)) :: Symbol
        fun :: Symbol

      funSym = 'QUOTE =>
        #argl = 1 => symbol(first argl)
        symbol paren(argl)
      funSym = 'construct =>
        bracket argl
      funSym = 'exit =>
        hconcat ["exit" :: PF, brace(first argl), paren(rest argl)]
      funSym = 'return =>
        hconcat ["return" :: PF, brace(first argl), paren(rest argl)]
      #argl = 0 and funSym = 'Zero => "0" :: PF
      #argl = 0 and funSym = 'One => "1" :: PF
      #argl = 2 and member?(funSym, binop) =>
        paren spaces [argl.1, (lowerCase string funSym) :: PF, argl.2]

      -- handle attribute as functor
      funSym = 'ATTRIBUTE => argl.1

      -- finally, process the application
      (constructor? funSym) and (empty? argl) => funSym :: PF
      hconcat [funSym :: PF, paren argl]

    n = m ==
      for n' in [n.function, :n.args]
        for m' in [m.function, :m.args] repeat
          n' ~= m' =>
            return false
      true

)abbrev domain SPSEG SpadSegment
SpadSegment(N : SpadNodeCategory) : Exports == Implementation where
  PF ==> PrintableForm

  Exports ==> ParsableCategory with
    elt : (%, "start") -> N
    elt : (%, "end") -> N
    elt : (%, "step") -> N
    construct : (N, N) -> %
    construct : (N, N, N) -> %

  Implementation ==> add
    Rep := Record(r_start : N, r_end : N, r_step : N)

    import SExpression

    elt(x, "start") == x.r_start
    elt(x, "end") == x.r_end
    elt(x, "step") == x.r_step

    construct(f, l, s) == [f, l, s]$Rep
    construct(f, s) == [f, emptyNode(), s]$Rep

    parse ex ==
      -- (SEGMENT first last)
      [parse ex.2, parse ex.3]

    convert x ==
      convert [convert x.start, convert x.step, convert x.end]

    coerce n ==
      form : List(PF) := [".." :: PF, n.start :: PF]
      if not emptyNode? n.end then
        form := [n.end :: PF, :form]
      if integer? n.step and (n.step :: Integer) ~= 1 then
        form := [n.step :: PF, "by" :: PF, :form]
      spaces reverse form

)abbrev package SPITOR SpadIterator
SpadIterator(N : SpadNodeCategory) : Exports == Implementation where
  PF ==> PrintableForm

  Exports ==> ParsableCategory with
    elt : (%, "var") -> Symbol
    elt : (%, "seq") -> N
    construct : (Symbol, N) -> %

  Implementation ==> add
    Rep := Record(i_var : Symbol, i_seq : N)

    elt(x, "var") == x.i_var
    elt(x, "seq") == x.i_seq

    construct(v, s) == [v, s]$Rep

    convert x ==
      if segment? x.seq 
        then convert [convert ("STEP" :: Symbol), convert x.var, :(destruct convert x.seq)]
        else convert [convert ("IN" :: Symbol), convert x.var, convert x.seq]

    coerce itor ==
      spaces ["for" :: PF, itor.var :: PF, "in" :: PF, itor.seq :: PF]

)abbrev domain SPTEX SpadTypeExpr
SpadTypeExpr(N : SpadNodeCategory) : Exports == Implementation where
  PF ==> PrintableForm

  Exports ==> ParsableCategory with
    elt : (%, "kind") -> Symbol
    elt : (%, "expr") -> N
    elt : (%, "type") -> N
    construct : (Symbol, N, N) -> %

  Implementation ==> add
    Rep := Record(t_kind : Symbol, t_expr : N, t_type : N)

    import ParserTools
    import SExpression

    elt(x,"kind") == x.t_kind
    elt(x,"expr") == x.t_expr
    elt(x,"type") == x.t_type

    construct(k, e, t) ==
      operators : List Symbol :=
        ['case, 'has, 'is, 'pretend, ':, '::, '@, '_$]
      not member?(k, operators) =>
        error "Not a type expression operator!"
      [k, e, t]$Rep

    parse ex ==
      if domsel? ex
        then ['_$, parse ex.3, parse ex.2]
        else [symbol ex.1, parse ex.2, parse ex.3]

    convert x ==
      k := if x.kind = '_$ then 'Sel else x.kind
      convert [convert k, convert x.expr, convert x.type]

    coerce ex ==
      spaces [ex.expr :: PF, ex.kind :: PF, ex.type :: PF]

)abbrev domain SPLOOP SpadLoop
SpadLoop(N : SpadNodeCategory) : Exports == Implementation where
  K ==> Union("loop", "collect", "repeat")
  IT ==> SpadIterator(N)
  PF ==> PrintableForm

  Exports ==> ParsableCategory with
    elt : (%, "kind") -> K
    elt : (%, "itors") -> List(IT)
    elt : (%, "guards") -> List(N)
    elt : (%, "body") -> N
    construct : (K, List(IT), List(N), N) -> %

  Implementation ==> add
    Rep := Record(lp_kind : K,
                  lp_itors : List(IT),
                  lp_guards : List(N),
                  lp_body : N)

    import Printer
    import ParserTools

    elt(x, "kind") == x.lp_kind
    elt(x, "itors") == x.lp_itors
    elt(x, "guards") == x.lp_guards
    elt(x, "body") == x.lp_body

    construct(k, il, gl, b) == [k, il, gl, b]$Rep

    parse ex ==
      repeat? ex =>
        ["repeat", [], [], parse cdr ex]

      lst := destruct cdr ex
      l_body := parse(last lst) $ N
      lst := reverse(rest(reverse(lst)))

      -- println [convert(car ex), paren [convert e for e in lst]]

      range : SpadSegment(N)
      l_itors : List(IT) := []
      l_guards : List(N) := []

      for e in lst repeat
        -- TODO:
        -- 1) make sure guards are handled well
        -- 2) a while statement can occur inside collect statement
        itor? e =>
          -- (IN item sequence)
          l_itors := cons([symbol e.2, parse e.3], l_itors)
        step? e =>
          -- (STEP i m k n) -> i := m..n by k
          -- (STEP i m k) -> i := m.. by k
          range : SpadSegment(N) := if #e = 4
            then [parse e.3, parse e.4]
            else [parse e.3, parse e.5, parse e.4]
          l_itors := cons([symbol e.2, construct range], l_itors)
        guard? e or while? e =>
          -- should they be mixed together ?
          -- ('| cond)
          -- (WHILE cond)
          l_guards := cons(parse e.2, l_guards)
        println "------"
        println convert(e)
        error "unrecognized loop construct"

      reverse!(l_itors)
      reverse!(l_guards)

      #l_guards > 1 => error "loop: more than one guard!"

      if collect? ex
        then ["collect", l_itors, l_guards, l_body]
        else ["loop", l_itors, l_guards, l_body]

    convert x ==
      s : String := (x.kind = "collect" => "COLLECT"; "REPEAT")
      lis := [convert i for i in x.itors]
      lgs := [convert g for g in x.guards]
      lgs :=
        if empty? lis
          then [convert [convert 'WHILE, g] for g in lgs]
          else [convert [convert '_|, g] for g in lgs]
      convert [convert (s :: Symbol), :lis, :lgs, convert x.body]

    coerce n ==
      il := [i :: PF for i in n.itors]
      gl := [spaces ["if" :: PF, g :: PF] for g in n.guards]
      loopBody := n.body :: PF
      n.kind case "loop" =>
        loopExpr : List(PF) :=
          if empty? il then
            loopCond := sepBy(" and " :: PF, [g :: PF for g in n.guards])
            ["while" :: PF, loopCond]
          else
            [:il, :gl]
        vconcat [pile loopExpr, vconcat ["repeat" :: PF, indent(2, loopBody)]]
      n.kind case "collect" =>
        bracket spaces [loopBody, :concat(il, gl)]
      n.kind case "repeat" =>
        spaces ["repeat" :: PF, loopBody]

)abbrev domain SPLAM SpadLambda
SpadLambda(N : SpadNodeCategory) : Exports == Implementation where
  PF ==> PrintableForm

  Exports ==> ParsableCategory with
    elt : (%, "args") -> List(Symbol)
    elt : (%, "type") -> N
    elt : (%, "body") -> N
    construct : (List(Symbol), N, N) -> %

  Implementation ==> add
    Rep := Record(f_args : List(Symbol), f_type : N, f_body : N)

    import ParserTools

    elt(x, "args") == x.f_args
    elt(x, "type") == x.f_type
    elt(x, "body") == x.f_body

    construct(al, t, b) == [al, t, b]$Rep

    nameOf : SExpression -> Symbol
    nameOf s == if list? s then symbol s.2 else symbol s

    typeOf : SExpression -> SExpression
    typeOf s == if list? s then s.3 else convert []

    parse ex ==
      -- (+-> arg body)
      not list? ex.2 =>
        sig := convert [convert '_:, convert [], convert []]
        [[symbol ex.2], parse sig, parse ex.3]

      -- (+-> (: (: arg Type) RetType) body) 
      -- (+-> (: (@Tuple (: arg1 Type1) (: arg2 Type2)) RetType) body)
      (ltype, rtype) := destruct(cdr ex.2)

      largs := if tuple? ltype then destruct cdr(ltype) else [ltype]
      lsym := [nameOf arg for arg in largs]
      ltypes := [typeOf arg for arg in largs]

      sig := convert cons(convert '_:, concat(ltypes, [rtype]))

      [lsym, parse sig, parse ex.3]

    convert x == convert []

    coerce n ==
      spaces(["function" :: PF, paren [arg :: PF for arg in n.args],
              ":" :: PF, n.type :: PF, "==" :: PF, n.body :: PF])

)abbrev package SPSEQ SpadSequence
SpadSequence(N : SpadNodeCategory) : Exports == Implementation where
  K ==> Union("Capsule", "Sequence", "Tuple")
  PF ==> PrintableForm

  Exports ==> ParsableCategory with
    elt : (%, "kind") -> K
    elt : (%, "list") -> List(N)
    construct : (K, List(N)) -> %

  Implementation ==> add
    Rep := Record(s_kind : K, s_list : List(N))

    import ParserTools

    elt(x, "kind") == x.s_kind
    elt(x, "list") == x.s_list

    construct(k, l) == [k, l]$Rep

    parse ex ==
      content : List N := []

      for e in destruct cdr ex repeat
        var? e =>
          if listof? e.2
            then
              -- (: (LISTOF x y z ...) Type)
              varlst := destruct(cdr e.2)
              for var in varlst repeat
                sexp : N := parse (convert [convert '_:, var, e.3])
                content := [sexp, :content]
            else
              content := [(parse e) $ N, :content]

        content := [(parse e) $ N, :content]

      k : K :=
        capsule? ex => "Capsule"
        seq? ex => "Sequence"
        tuple? ex => "Tuple"

      [k, reverse content]

    convert x ==
      s : String :=
        x.kind case "Capsule" => "CAPSULE"
        x.kind case "Sequence" => "SEQ"
        x.kind case "Tuple" => "@Tuple"
      
      convert cons(convert (s :: Symbol), [convert i for i in x.list])

    coerce n ==
      exps := [e :: PF for e in n.list | not emptyNode? e]
      n.kind case "Sequence" or n.kind case "Capsule" => vconcat exps
      n.kind case "Tuple" => paren exps

)abbrev package SPCOND SpadCondExpr
SpadCondExpr(N : SpadNodeCategory) : Exports == Implementation where
  PF ==> PrintableForm

  Exports ==> ParsableCategory with
    elt : (%, "cond") -> N
    elt : (%, "truebr") -> N
    elt : (%, "falsebr") -> N
    construct : (N, N, N) -> %

  Implementation ==> add
    Rep := Record(c_cond : N, c_true : N, c_false : N)

    import ParserTools

    elt(x, "cond") == x.c_cond
    elt(x, "truebr") == x.c_true
    elt(x, "falsebr") == x.c_false

    convert x ==
      convert [convert ("IF" :: Symbol), convert x.cond, convert x.truebr, convert x.falsebr]

    construct(c, tb, fb) == [c, tb, fb]$Rep

    parse ex ==
      -- (IF condition expr1 expr2)
      -- (IF condition expr 'noBranch)
      -- (IF condition 'noBranch expr)
      (c, l, r) := (ex.2, ex.3, ex.4)
      nobranch? l =>
        pc : N := parse (convert [convert '_not, c])
        [pc, parse r, emptyNode()]
      nobranch? r =>
        [parse c, parse l, emptyNode()]
      [parse c, parse l, parse r]

    coerce c ==
      fs : List(PF) :=
        [spaces ["if" :: PF, c.cond :: PF],
         pile ["then" :: PF, c.truebr :: PF]]
      if not emptyNode? c.falsebr then
        fs := [:fs, pile ["else" :: PF, c.falsebr :: PF]]
      vconcat fs

)abbrev package SPFN SpadFunction
++ SPAD function
SpadFunction(N : SpadNodeCategory) : Exports == Implementation where
  NT ==> SpadNamedType(N)
  MT ==> SpadMappingType(N)
  PF ==> PrintableForm

  Exports ==> ParsableCategory with
    elt : (%, "name") -> Symbol
    elt : (%, "args") -> List(N)
    elt : (%, "type") -> N
    elt : (%, "body") -> N
    construct : (Symbol, List(N), N, N) -> %
      ++ construct(name,varlist,type,exp)
    signature : % -> NT

  Implementation ==> add
    Rep := Record(fn_name : Symbol,
                  fn_args : List(N),
                  fn_type : N,
                  fn_body : N)

    import ParserTools
    import SExpression
    import NT

    elt(x, "name") == x.fn_name
    elt(x, "args") == x.fn_args
    elt(x, "type") == x.fn_type
    elt(x, "body") == x.fn_body

    construct(fname, fargs, ftype, fbody) == 
      [fname, fargs, ftype, fbody]$Rep

    parse_arg : (SExpression, SExpression) -> N
    parse_arg(s, t) ==
      string? s => [string s]
      [[symbol s, parseNonNull t]$NT]

    parse ex ==
      fname := symbol car(ex.2)
      arg_names := destruct cdr(ex.2)
      arg_types := destruct cdr(ex.3)
      fargs := [parse_arg(s, t) for s in arg_names for t in arg_types]
      ftype := car ex.3
      fbody := ex.5
      [fname, fargs, parseNonNull ftype, parse fbody]

    convert x ==
      arg_names := [convert (arg :: NT).name for arg in x.args]
      types := [convert (arg :: NT).type for arg in x.args]
      types' := [convert [] for i in 0..#x.args]
      fbody := convert x.body
      convert([convert ("DEF" :: Symbol),
               convert [convert x.name, :arg_names],
               convert [convert x.type, :types],
               convert types',
               fbody])

    signature fn ==
      types := [(namedType? arg => (arg :: NT).type; emptyNode())
                for arg in fn.args]
      [fn.name, [[types, fn.type] $ MT]]

    coerce n ==
      fargs := [arg :: PF for arg in n.args]
      retType : List(PF) :=
        emptyNode? n.type => []
        [":" :: PF, n.type :: PF]
      pile ([spaces [n.name :: PF, paren fargs, :retType, "==" :: PF],
             n.body :: PF])

)abbrev package SPMACRO SpadMacro
++ SPAD macro representation
SpadMacro(N : SpadNodeCategory) : Exports == Implementation where
  PF ==> PrintableForm

  Exports ==> ParsableCategory with
    elt : (%, "name") -> Symbol
    elt : (%, "args") -> List Symbol
    elt : (%, "body") -> N
    construct : (Symbol, List Symbol, N) -> %
      ++ construct(name,args,exp)
  
  Implementation ==> add
    Rep := Record(md_name : Symbol,
                  md_args : List Symbol,
                  md_body : N)

    import ParserTools

    elt(x, "name") == x.md_name
    elt(x, "args") == x.md_args
    elt(x, "body") == x.md_body

    construct(mname, margs, mbody) ==
      [mname, margs, mbody]$Rep

    parse ex ==
      mname := symbol car(ex.2)
      margs := [ symbol s for s in destruct(cdr(ex.2)) ]
      mbody : N := parse ex.5
      [mname, margs, mbody]

    convert x == convert []

    coerce m ==
      margs := paren [arg :: PF for arg in m.args]
      spaces [m.name :: PF, margs, "==>" :: PF, m.body :: PF]

)abbrev package SPWHERE SpadWhere
SpadWhere(N : SpadNodeCategory) : Exports == Implementation where
  PF ==> PrintableForm

  Exports ==> ParsableCategory with
    elt : (%, "body") -> N
    elt : (%, "env") -> N
    construct : (N, N) -> %

  Implementation ==> add
    Rep := Record(w_body : N, w_env : N)

    import ParserTools

    elt(x, "body") == x.w_body
    elt(x, "env") == x.w_env

    construct(d, e) == [d, e]$Rep

    parse ex ==
      [(parse ex.2) $ N, (parse ex.3) $ N]

    convert x == convert []

    coerce w ==
      spaces [w.body :: PF, "where" :: PF, w.env :: PF]

)abbrev package SPFTOR SpadFunctor
++ SPAD functor representation
SpadFunctor(N : SpadNodeCategory) : Exports == Implementation where
  NT ==> SpadNamedType(N)
  MT ==> SpadMappingType(N)
  PF ==> PrintableForm

  Exports ==> ParsableCategory with
    elt : (%, "name") -> Symbol
    elt : (%, "args") -> List NT
    elt : (%, "type") -> N
    elt : (%, "extends") -> N
    elt : (%, "capsule") -> N
    construct : (Symbol, List NT, N, N, N) -> %
    signature : % -> NT

  Implementation ==> add
    Rep := Record(f_name : Symbol,
                  f_args : List NT,
                  f_type : N,
                  f_extends : N,
                  f_capsule : N)

    import ParserTools
    import SExpression
    import SpadNode

    SEX ==> SExpression

    elt(x, "name") == x.f_name
    elt(x, "args") == x.f_args
    elt(x, "type") == x.f_type
    elt(x, "extends") == x.f_extends
    elt(x, "capsule") == x.f_capsule

    construct(n, al, t, e, c) == [n, al, t, e, c]$Rep

    parse ex ==
      arg_names := destruct cdr(ex.2)
      arg_types := destruct cdr(ex.3)
      fname := symbol car(ex.2)
      ftype := car ex.3
      fbody := ex.5
      fargs : List NT :=
        [[symbol s, parse t] for s in arg_names for t in arg_types]
      fcapsule := if symbol(car fbody) = 'add then fbody.3 else fbody
      fextends := if symbol(car fbody) = 'add then fbody.2 else convert []
      [fname, fargs, parse ftype, parseNonNull fextends, parse fcapsule]

    convert x ==
      arg_names := [convert arg.name for arg in x.args]
      arg_types := [convert arg.type for arg in x.args]
      convert([convert 'DEF,
               convert [convert x.name, :arg_names],
               convert [convert x.type, :arg_types],
               convert [convert [] for i in 0..#x.args],
               convert x.capsule])

    coerce n ==
      def := spaces [n.name :: PF, paren [arg :: PF for arg in n.args], ":" :: PF]
      impl := pile [spaces ["==" :: PF, n.extends :: PF, "add" :: PF], n.capsule :: PF]
      pile [def, indent(2, n.type :: PF), impl]

    signature ft ==
      [ft.name, [[[arg.type for arg in ft.args], ft.type] $ MT]]

)abbrev domain SPNODE SpadNode
++ SPAD generic expression
SpadNode() : Exports == Implementation where
  DF ==> DoubleFloat
  NNI ==> NonNegativeInteger
  PF ==> PrintableForm

  APP ==> SpadApply(%)
  ASS ==> SpadAssign(%)
  CE ==> SpadCondExpr(%)
  FN ==> SpadFunction(%)
  FT ==> SpadFunctor(%)
  IM ==> SpadImport(%)
  IT ==> SpadIterator(%)
  LAM ==> SpadLambda(%)
  LP ==> SpadLoop(%)
  M ==> SpadMacro(%)
  MR ==> SpadMarker(%)
  MT ==> SpadMappingType(%)
  NT ==> SpadNamedType(%)
  RT ==> SpadRecordType(%)
  SEG ==> SpadSegment(%)
  SEQ ==> SpadSequence(%)
  ST ==> SpadSumType(%)
  TE ==> SpadTypeExpr(%)
  UT ==> SpadUnionType(%)
  W ==> SpadWhere(%)
  
  Exports ==> SpadNodeCategory with
    nodeApp : (%, List(%)) -> %
    nodeAssign : (%, %) -> %
    nodeCondExpr : (%, %, %) -> %
    nodeFtor : (Symbol, List(NT), %, %, %) -> %
    nodeFun : (Symbol, List(%), %, %) -> %
    nodeImport : % -> %
    nodeLambda : (List(Symbol), %, %) -> %
    nodeLoop : (Union("loop", "collect", "repeat"), List(IT), List(%), %) -> %
    nodeMacro : (Symbol, List(Symbol), %) -> %
    nodeMappingType : (List(%), %) -> %
    nodeNamedType : (Symbol, %) -> %
    nodeRecordType : List(NT) -> %
    nodeRef : NNI -> %
    nodeSeg : (%, %, %) -> %
    nodeSeq : (Union("Capsule", "Sequence", "Tuple"), List(%)) -> %
    nodeSumType : (Union("Join", "Domain", "Package", "Body"), List(%)) -> %
    nodeTypeExpr : (Symbol, %, %) -> %
    nodeUnionType : List(%) -> %
    nodeWhere : (%, %) -> %

  Implementation ==> add
    Rep := Union(empty : "$EmptyNode",
                 apply : APP, assign : ASS, cond : CE, lambda : LAM, loop : LP,
                 mapping : MT, named : NT, record : RT, segment : SEG,
                 seq : SEQ, ftor : FT, func : FN, simport : IM, smacro : M,
                 sum : ST, swhere : W, typeexpr : TE, union : UT, marker : MR,
                 dfloat : DF, int : Integer, str : String, sym : Symbol)

    import SExpression
    import Printer
    import ParserTools
    import Logger('Parser)

    apply? n == n case apply
    assign? n == n case assign
    condExpr? n == n case cond
    float? n == n case dfloat
    function? n == n case func
    functor? n == n case ftor
    import? n == n case simport
    integer? n == n case int
    lambda? n == n case lambda
    loop? n == n case loop 
    macro? n == n case smacro 
    mappingType? n == n case mapping 
    marker? n == n case marker
    namedType? n == n case named
    nodeRef? n ==
      not n case marker => false
      n.marker.kind = 'noderef
    recordType? n == n case record
    segment? n == n case segment 
    sequence? n == n case seq
    string? n == n case str
    sumType? n == n case sum
    symbol? n == n case sym
    typeExpr? n == n case typeexpr
    typeOrigin? n ==
      not n case typeexpr => false
      n.typeexpr.kind = '_$
    unionType? n == n case union
    where? n == n case swhere
    typeAny? n ==
      not n case marker => false
      n.marker.kind = 'typevar and n.marker.id = 0
    typeVar? n ==
      not n case marker => false
      n.marker.kind = 'typevar and n.marker.id > 0

    CoerceError(T) ==>
      error concat ["Cannot coerce SpadNode to ", T, "!"]

    coerce (n : %) : APP ==
      apply? n => n.apply
      CoerceError("SpadApply")

    coerce (n : %) : ASS ==
      assign? n => n.assign
      CoerceError("SpadAssign")

    coerce (n : %) : CE ==
      condExpr? n => n.cond
      CoerceError("SpadCondExpr")

    coerce (n : %) : FN ==
      function? n => n.func
      CoerceError("SpadFunction")

    coerce (n : %) : FT ==
      functor? n => n.ftor
      CoerceError("SpadFunctor")

    coerce (n : %) : IM ==
      import? n => n.simport
      CoerceError("SpadImport")

    coerce (n : %) : LAM == 
      lambda? n => n.lambda
      CoerceError("SpadLambda")

    coerce (n : %) : LP ==
      loop? n => n.loop
      CoerceError("SpadLoop")

    coerce (n : %) : M ==
      macro? n => n.smacro
      CoerceError("SpadMacro")

    coerce (n : %) : MT == 
      mappingType? n => n.mapping
      CoerceError("SpadMappingType")

    coerce (n : %) : MR == 
      marker? n => n.marker
      CoerceError("SpadMarker")

    coerce (n : %) : NT ==
      namedType? n => n.named
      CoerceError("SpadNamedType")

    coerce (n : %) : RT ==
      recordType? n => n.record
      CoerceError("SpadRecordType")

    coerce (n : %) : SEG ==
      segment? n => n.segment
      CoerceError("SpadSegment")

    coerce (n : %) : SEQ ==
      sequence? n => n.seq
      CoerceError("SpadSequence")

    coerce (n : %) : ST ==
      sumType? n => n.sum
      CoerceError("SpadSumType")

    coerce (n : %) : TE ==
      typeExpr? n => n.typeexpr
      CoerceError("SpadTypeExpr")

    coerce (n : %) : UT ==
      unionType? n => n.union
      CoerceError("SpadUnionType")

    coerce (n : %) : W ==
      where? n => n.swhere
      CoerceError("SpadWhere")

    coerce (n : %) : DF ==
      float? n => n.dfloat
      CoerceError("DoubleFloat")

    coerce (n : %) : Integer ==
      integer? n => n.int
      CoerceError("Integer")

    coerce (n : %) : Symbol ==
      symbol? n => n.sym
      CoerceError("Symbol")

    coerce (n : %) : String == 
      string? n => n.str
      CoerceError("String")

    emptyNode () == ["$EmptyNode"]$Rep
    emptyNode? n == n case empty

    constructor? s ==
      sex : SExpression := GETDATABASE(s, 'ABBREVIATION)$Lisp
      not null? sex

    construct (n : APP) : % == [n]$Rep
    construct (n : ASS) : % == [n]$Rep
    construct (n : CE) : % == [n]$Rep
    construct (n : FN) : % == [n]$Rep
    construct (n : FT) : % == [n]$Rep
    construct (n : IM) : % == [n]$Rep
    construct (n : LAM) : % == [n]$Rep
    construct (n : LP) : % == [n]$Rep
    construct (n : M) : % == [n]$Rep
    construct (n : MT) : % == [n]$Rep
    construct (n : MR) : % == [n]$Rep
    construct (n : NT) : % == [n]$Rep
    construct (n : RT) : % == [n]$Rep
    construct (n : SEG) : % == [n]$Rep
    construct (n : SEQ) : % == [n]$Rep
    construct (n : ST) : % == [n]$Rep
    construct (n : TE) : % == [n]$Rep
    construct (n : UT) : % == [n]$Rep
    construct (n : W) : % == [n]$Rep

    construct (n : DF) : % == [n]$Rep
    construct (n : Integer) : % == [n]$Rep
    construct (n : String) : % == [n]$Rep
    construct (n : Symbol) : % == [n]$Rep

    parseNonNull ex ==
      null? ex => emptyNode()
      parse ex

    parse ex ==
      debug ["Parsing expression:" :: PF, convert(ex) :: PF]

      capsule? ex or seq? ex or tuple? ex =>
        -- (SEQ expr1 expr2 ...)
        -- (CAPSULE expr1 expr2 ...)
        -- (@Tuple expr1 expr2 ...)
        [parse(ex)$SEQ]

      import? ex => [parse(ex)$IM]
      where? ex => [parse(ex)$W]
      lambda? ex => [parse(ex)$LAM]
      functor? ex => [parse(ex)$FT]
      function? ex => [parse(ex)$FN]
      macro? ex => [parse(ex)$M]
      marker? ex => [parse(ex)$MR]

      (var? ex or case? ex or has? ex or is? ex or pretend? ex or coerce? ex or
       domsel? ex or retsel? ex) => 
        -- {expression with type annotation}
        -- (: expr Type) 
        -- {expression with "case" operator}
        -- (case expr Type)
        -- {expression with "has" operator}
        -- (has expr Type)
        -- {expression with "is" operator}
        -- (is expr Type)
        -- {expression with "pretend" operator}
        -- (pretend expr Type)
        -- {expression with "::" coerce operator}
        -- (:: expr Type)
        -- {expression with "@" return type selection operator}
        -- (@ expr Type)
        -- {expression with "$" domain selection operator}
        -- (Sel expr Type)
        [parse(ex)$TE]

      let? ex => [parse(ex)$ASS]

      ifelse? ex => -- {if-then-else expression of if-then statement}
        [parse(ex)$CE]

      collect? ex or loop? ex or repeat? ex =>
        [parse(ex)$LP]

      mapping? ex => -- TODO: var? ex is missing after collapsing Node and Type
        [parse(ex)$MT]

      domain? ex or package? ex or join? ex or progn? ex =>
        [parse(ex)$ST]

      signature? ex => [parse(ex)$NT]
      record? ex => [parse(ex)$RT]
      union? ex => [parse(ex)$UT]
      list? ex and #ex > 0 => [parse(ex)$APP]

      symbol? ex =>
        s := symbol ex
        -- BUG: this doesn't work and no warning is issued...
        -- if s = '$ then s := '%
        [if s = '$ then s := coerce "%" else s]

      string? ex => [string ex]
      integer? ex => [integer ex]
      float? ex => [float ex]
      null? ex => emptyNode()

      fail ["Could not parse s-expression:" :: PF, convert(ex) :: PF]
      error ""

    coerce (n : %) : PF ==
      apply? n => (n :: APP) :: PF
      assign? n => (n :: ASS) :: PF
      condExpr? n => (n :: CE) :: PF
      float? n => (n :: DF) :: PF
      function? n => (n :: FN) :: PF
      functor? n => (n :: FT) :: PF
      import? n => (n :: IM) :: PF
      integer? n => (n :: Integer) :: PF
      lambda? n => (n :: LAM) :: PF
      loop? n => (n :: LP) :: PF
      macro? n => (n :: M) :: PF
      mappingType? n => (n :: MT) :: PF
      marker? n => (n :: MR) :: PF
      namedType? n => (n :: NT) :: PF
      recordType? n => (n :: RT) :: PF
      segment? n => (n :: SEG) :: PF
      sequence? n => (n :: SEQ) :: PF
      string? n => string((n :: String) :: PF)
      sumType? n => (n :: ST) :: PF
      symbol? n => (n :: Symbol) :: PF
      typeExpr? n => (n :: TE) :: PF
      unionType? n => (n :: UT) :: PF
      where? n => (n :: W) :: PF
      emptyNode? n => "?" :: PF

      error "coerce $ SpadNode: variant not handled!"

    convert n ==
      apply? n => convert(n :: APP)
      assign? n => convert(n :: ASS)
      condExpr? n => convert(n :: CE)
      float? n => convert(n :: DF)
      function? n => convert(n :: FN)
      functor? n => convert(n :: FT)
      import? n => convert(n :: IM)
      integer? n => convert(n :: Integer)
      lambda? n => convert(n :: LAM)
      loop? n => convert(n :: LP)
      macro? n => convert(n :: M)
      mappingType? n => convert(n :: MT)
      marker? n => convert(n :: MR)
      namedType? n => convert(n :: NT)
      recordType? n => convert(n :: RT)
      segment? n => convert(n :: SEG)
      sequence? n => convert(n :: SEQ)
      string? n => convert(n :: String)
      sumType? n => convert(n :: ST)
      symbol? n => convert(n :: Symbol)
      typeExpr? n => convert(n :: TE)
      unionType? n => convert(n :: UT)
      where? n => convert(n :: W)
      emptyNode? n => convert []

      error "convert $ SpadNode: variant not handled!"

    n = m ==
      -- defined only for nodes that can represent types
      apply? n and apply? m => (n :: APP) = (m :: APP)
      float? n and float? m => (n :: DF) = (m :: DF)
      function? n and function? m => (n :: FN) = (m :: FN)
      integer? n and integer? m => (n :: Integer) = (m :: Integer)
      mappingType? n and mappingType? m => (n :: MT) = (m :: MT)
      marker? n and marker? m => (n :: MR) = (m :: MR)
      namedType? n and namedType? m => (n :: NT) = (m :: NT)
      recordType? n and recordType? m => (n :: RT) = (m :: RT)
      string? n and string? m => (n :: String) = (m :: String)
      sumType? n and sumType? m => (n :: ST) = (m :: ST)
      symbol? n and symbol? m => (n :: Symbol) = (m :: Symbol)
      unionType? n and unionType? m => (n :: UT) = (m :: UT)
      emptyNode? n and emptyNode? m => true
      false

    nodeApp (fun, args) == [[fun, args]$APP]
    nodeAssign (lval, rval) == [[lval, rval]$ASS]
    nodeCondExpr (cond, btrue, bfalse) == [[cond, btrue, bfalse]$CE]
    nodeFun (name, args, type, body) == [[name, args, type, body]$FN]
    nodeFtor (name, args, type, ext, caps) == [[name, args, type, ext, caps]$FT]
    nodeImport type == [[type]$IM]
    nodeLambda (args, type, body) == [[args, type, body]$LAM]
    nodeLoop (kind, itors, guards, body) == [[kind, itors, guards, body]$LP]
    nodeMacro (name, args, body) == [[name, args, body]$M]
    nodeMappingType (args, type) == [[args, type]$MT]
    nodeNamedType (name, type) == [[name, type]$NT]
    nodeRecordType fields == [[fields]$RT]
    nodeRef (i) == [[i, 'noderef]$MR]
    nodeSeq (kind, list) == [[kind, list]$SEQ]
    nodeSeg (start, end, step) == [[start, end, step]$SEG]
    nodeTypeExpr (kind, expr, type) == [[kind, expr, type]$TE]
    nodeSumType (kind, types) == [[kind, types]$ST]
    nodeUnionType variants == [[variants]$UT]
    nodeWhere (body, env) == [[body, env]$W]
