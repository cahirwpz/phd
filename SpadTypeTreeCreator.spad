)abbrev package STRFAC SpadTypeRuleFactory
SpadTypeRuleFactory() : Exports == Implementation where
  N ==> SpadNode
  FN ==> SpadFunction(N)
  FT ==> SpadFunctor(N)
  TR ==> SpadTypeRule
  TN ==> SpadTypeNode
  OTN ==> Union(TN, "none")

  Exports ==> with
    ruleAssign : (TN, TN) -> TR
    ruleApply : (TN, List(TN)) -> TR
    ruleApply : (TN, List(TN), List(TN)) -> TR
    ruleCondExpr : (TN, TN, TN) -> TR
    ruleFun : (FN, List(TN), TN, TN) -> TR
    ruleFtor : (FT, List(TN), TN, TN) -> TR
    ruleLoopIter : (TN, TN, TN) -> TR
    ruleLoop : (Union("loop", "collect", "repeat"), 
                List(TN), List(TN), TN) -> TR
    ruleRef : (List(TN), TN) -> TR
    ruleTypeIs : (TN, TN) -> TR
    ruleTypeIs : (List(TN), TN, TN) -> TR
    ruleSeg : (TN, OTN, OTN) -> TR
    ruleSeq : (Union("Domain", "Package", "Join", "Capsule", "Sequence",
                     "Tuple", "Body"), TN, List(TN)) -> TR
    ruleTypeOrigin : (TN, N) -> TR
    ruleSubType : (TN, TN) -> TR
    ruleSubType : (List(TN), TN, TN) -> TR
    ruleSuperType : (TN, TN) -> TR

  Implementation ==> add
    -- for assignment "L := R" do:
    -- compute "L, R"; if "L := R" then solution is "L := R"
    ruleAssign (L', R') ==
      (L, R) := (nodeRef(L'), nodeRef(R'))
      [[L, R, nodeAssign(L, R)], nodeAssign(L, R)]

    ruleApply (fun, args) ==
      (funRef, argRefs) := (nodeRef(fun), [nodeRef(arg) for arg in args])
      [[funRef, :argRefs, nodeApp(funRef, argRefs)],
       nodeApp(funRef, argRefs)]

    ruleApply (fun, args, extras) ==
      (funRef, argRefs) := (nodeRef(fun), [nodeRef(arg) for arg in args])
      extraRefs := [nodeRef(extra) for extra in extras]
      [[:extraRefs, funRef, :argRefs, nodeApp(funRef, argRefs)],
       nodeApp(funRef, argRefs)]

    ruleCondExpr (C', T', F') ==
      (C, T, F) := (nodeRef(C'), nodeRef(T'), nodeRef(F'))
      [[C, T, F, nodeCondExpr(C, T, F)], nodeCondExpr(C, T, F)]

    -- for function "fn (a1 : A1, ..., an : An) : T == B" do:
    -- compute "A1, ..., An, T, B"; if "T is B" then solution is "fn"
    ruleFun (fn, As', T', B') ==
      (As, T, B) := ([nodeRef(a) for a in As'], nodeRef(T'), nodeRef(B'))
      [[:As, T, B, nodeTypeIs(T, B)], nodeFun(fn.name, As, T, B)]

    -- for functor "ft (a1 : A1, ..., an : An) : T == E add B" do:
    -- compute "A1, ..., An, T, B"; if "B <: T" then solution is "ft"
    ruleFtor (ft, As', T', B') ==
      (As, T, B) := ([nodeRef(a) for a in As'], nodeRef(T'), nodeRef(B'))
      E := (emptyNode? ft.extends => ['Type]; ft.extends)
      [[:As, T, B, nodeSubType(B, T)], nodeFtor(ft.name, ft.args, ft.type, E, B)]

    ruleLoopIter (var, seq, iter) == 
      (varRef, seqRef, iterRef) := (nodeRef(var), nodeRef(seq), nodeRef(iter))
      [[varRef, seqRef], nodeIterator(var.node :: Symbol, seqRef)]

    ruleLoop (kind, itors, guards, body) ==
      itorRefs := [nodeRef(itor) for itor in itors]
      guardRefs := [nodeRef(guard) for guard in guards]
      bodyRef := nodeRef(body)
      [[:itorRefs, :guardRefs, bodyRef],
       nodeLoop(kind, itorRefs, guardRefs, bodyRef)]

    ruleRef (deps, body) ==
      depRefs := [nodeRef(dep) for dep in deps]
      bodyRef := nodeRef(body)
      [[:depRefs, bodyRef], bodyRef]

    ruleSeg (start, end, step) ==
      startRef := nodeRef(start)
      formulas := [startRef]$List(N)
      if end case TN then
        endRef := nodeRef(end)
        concat!(formulas, endRef)
      else
        endRef := emptyNode()
      if step case TN then
        stepRef := nodeRef(step)
        concat!(formulas, stepRef)
      else
        stepRef := emptyNode()
      [formulas, nodeSeg(startRef, endRef, stepRef)]

    ruleSeq (kind, seq, exprs) ==
      (seqRef, exprRefs) := (nodeRef(seq), [nodeRef(expr) for expr in exprs])
      formula := 
        kind case "Capsule" => nodeSeq(kind, exprRefs)
        nodeTypeIs(seqRef, last exprRefs)
      [[:exprRefs, formula], nodeSeq(kind, exprRefs)]

    ruleTypeOrigin (expr, origin) ==
      exprRef := nodeRef(expr)
      [[exprRef, nodeTypeOrigin(exprRef, origin)],
       nodeTypeOrigin(exprRef, origin)]

    ruleSuperType (superType, type) ==
      (superTypeRef, typeRef) := (nodeRef(superType), nodeRef(type))
      [[typeRef, nodeSubType(superTypeRef, typeRef)], nodeRef(type)]

    -- compute "S"; if "S is T" then solution is "S"
    ruleTypeIs (S', T') ==
      ruleTypeIs ([], S', T')

    -- compute "P1, ..., Pn, S"; if "S is T" then solution is "S"
    ruleTypeIs (Ps', S', T') ==
      (Ps, S, T) := ([nodeRef(p) for p in Ps'], nodeRef(S'), nodeRef(T'))
      [[:Ps, S, nodeTypeIs(S, T)], S]

    -- compute "S"; if "S <: T" then solution is "S"
    ruleSubType (S', T') ==
      ruleSubType ([], S', T')

    -- compute "P1, ..., Pn, S"; if "S <: T" then solution is "S"
    ruleSubType (Ps', S', T') ==
      (Ps, S, T) := ([nodeRef(p) for p in Ps'], nodeRef(S'), nodeRef(T'))
      [[:Ps, S, nodeSubType(S, T)], S]

)abbrev package STTCREAT SpadTypeTreeCreator
SpadTypeTreeCreator() : Exports == Implementation where
  PF ==> PrintableForm

  N ==> SpadNode
  APP ==> SpadApply(N)
  ASS ==> SpadAssign(N)
  CE ==> SpadCondExpr(N)
  FN ==> SpadFunction(N)
  FT ==> SpadFunctor(N)
  IM ==> SpadImport(N)
  IT ==> SpadIterator(N)
  LAM ==> SpadLambda(N)
  LP ==> SpadLoop(N)
  MT ==> SpadMappingType(N)
  NR ==> SpadNodeRef(N)
  RT ==> SpadRecordType(N)
  SC ==> SpadCase(N)
  SEG ==> SpadSegment(N)
  SEQ ==> SpadSequence(N)
  SM ==> SpadMacro(N)
  TC ==> SpadTypeCoerce(N)
  TD ==> SpadTypeDecl(N)
  TG ==> SpadTypeGuard(N)
  TO ==> SpadTypeOrigin(N)
  TS ==> SpadTypeSelect(N)
  TV ==> SpadTypeVar(N)
  UT ==> SpadUnionType(N)
  SW ==> SpadWhere(N)

  SUBST ==> AssociationList(TV, List(N))

  ENV ==> SpadEnvironment
  TN ==> SpadTypeNode
  TR ==> SpadTypeRule
  CTX ==> SpadTypeTree

  Exports ==> with
    walk : (N, CTX, ENV) -> TN

  Implementation ==> add
    import SpadNode
    import SpadNodeFactory
    import SpadDatabase
    import SpadEnvironment
    import SpadTypeInfo
    import SpadTypeRuleFactory
    import SpadTypeNodeArray
    import TypeUnifier
    import Printer
    import Logger('Create)

    envAddType (t : N, env : ENV) : ENV ==
      if apply? t then
        app := t :: APP
        env := addDomain(env, app)
        for k in app.args repeat
          env := envAddType(k, env)
      if mappingType? t then
        mt := t :: MT
        for k in [mt.result, :mt.args] repeat
          env := envAddType(k, env)
      if recordType? t then
        rt := t :: RT
        for f in fields rt repeat
          env := envAddType(f.type, env)
        for f in makeRecordFunList t repeat
          env(f.expr :: Symbol) := nodeTypeOrigin(f.type, t)
      if unionType? t then
        ut := t :: UT
        for v in variants ut repeat
          env := envAddType(v, env)
        for f in makeUnionFunList t repeat
          env(f.expr :: Symbol) := nodeTypeOrigin(f.type, t)
      env

    envAddTypeAs (t : N, alias : Symbol, env : ENV) : ENV ==
      env

    walkApp (a : APP, ctx : CTX, env : ENV) : TN ==
      -- rewrite QUOTE(symbol) to value 'symbol
      a.function = ['QUOTE] and #a.args = 1 =>
        this := addNode!(ctx, first a.args, env)
        setTypeOf!(ctx, this, [symbolType])
        this

      debug ["Processing function application." :: PF]

      this := addNode!(ctx, [a], env)

      -- First case: just a function call.
      funExpr := walk(a.function, ctx, env)
      argExprList := [walk(arg, ctx, env) for arg in a.args]

      -- Second case: element indexing or record field access.
      eltFunList : List(N) := []
      if not unify?(a.function, ['elt]) then
        for n in env('elt) | typeOrigin? n repeat
          eltFun := (n :: TO).expr :: MT
          if #eltFun.args = #a.args + 1 then
            eltFunList := [n, :eltFunList]

      if not empty? eltFunList then
        argExprList' := [funExpr, :argExprList]
        eltFunExpr := addNode!(ctx, ['elt], env)
        eltFunExpr.node := nodeTypeOrigin(eltFunExpr.node, typeRef(eltFunExpr))
        setTypeOf!(ctx, eltFunExpr, eltFunList)
        this.rules := [ruleApply(eltFunExpr, argExprList'), :this.rules]

      -- Add origin to function expression.
      if not(funExpr.node = ['return] or funExpr.node = ['error]) then
        funExpr.node := nodeTypeOrigin(funExpr.node, typeRef(funExpr))

      -- First case with a twist: arbitrary list construction.
      if unify?(a.function, ['construct]) then
        item := addNode!(ctx, ['construct], env)
        setTypeOf!(ctx, item, [argExpr.type for argExpr in argExprList])
        constructArgs := [item.type for i in 1..#a.args]
        constructRes := nodeApp(['List], [item.type])
        extendTypeOf!(ctx, funExpr, [nodeMappingType(constructArgs, constructRes)])
        this.rules := [ruleApply(funExpr, argExprList, [item]), :this.rules]
      else
        this.rules := [ruleApply(funExpr, argExprList), :this.rules]
      this

    walkAssign (a : ASS, ctx : CTX, env : ENV) : TN ==
      apply? a.lval =>
        app := a.lval :: APP
        this := walk(nodeApp(['setelt!], [app.function, :app.args, a.rval]), ctx, env)
        this.node := [a]
        this

      this := addNode!(ctx, [a])

      introduced? := false
      if symbol? a.lval then
        s := a.lval :: Symbol
        if empty? env(s) then
          debug ["Processing fresh assignment" :: PF, string(s :: PF)]
          env(s) := this.type
          introduced? := true

      left := walk(a.lval, ctx, env)
      -- we know the type of left-value while checking right-value (!?)
      right := walk(a.rval, ctx, env)

      if introduced? then
        left.node := nodeTypeDecl(left.node, typeRef(left))

      -- Only left-value environment is propagated!
      this.env := left.env
      this.rules := [ruleAssign(left, right)]
      this

    walkCondExpr (ce : CE, ctx : CTX, env : ENV) : TN ==
      debug ["Processing conditional expression." :: PF]
      this := addNode!(ctx, [ce])

      cond := walk(ce.cond, ctx, env)
      truebr := walk(ce.truebr, ctx, cond.env)
      falsebr := walk(ce.falsebr, ctx, (case? ce.cond => env; cond.env))

      setTypeOf!(ctx, this,
                 [truebr.type, falsebr.type,
                  nodeUnionType [truebr.type, falsebr.type],
                  nodeUnionType [falsebr.type, truebr.type]])

      -- TODO: "truebr.env" and "falsebr.env" should be merged and passed
      -- forward instead of just "env". Merging means that if the same variable
      -- was introduced in both branches then it should be present in the final
      -- environment.
      --
      -- Q: What if a variable "x : T" is defined only in one branch?
      -- A: In merged envrionment introduce "x" with type Union(T, "undefined"),
      --    and emit a warning when subtyping rule is applied.
      this.env := env
      this.rules := [ruleCondExpr(cond, truebr, falsebr)]
      this

    walkFun (fn : FN, ctx : CTX, env : ENV) : TN ==
      debug ["Processing function" :: PF, string(fn.name :: PF)]

      funDeclNode := addNode!(ctx, [fn], env)
      addSubTree!(ctx)
      env' := createScope env

      -- It's vitally important that result type is represented by "%2" type
      -- variable (e.g. 'return' refers to "%2").
      funDefNode := addNode!(ctx, [fn.name], env')
      resNode := addNode!(ctx, emptyNode(), env')
      argNodeList := [addNode!(ctx, emptyNode(), env) for n in fn.args]

      resNode.node := resNode.type
      for argNode in argNodeList for n in fn.args repeat
        argNode.node := nodeTypeDecl((n :: TD).expr, argNode.type)

      -- Take the type of function and replace those components, that were not
      -- specified, with type variables.
      fnType : MT := signature fn

      typeList : List(N) :=
        ([(emptyNode?(t) => n.type; t)
          for n in [resNode, :argNodeList] for t in [fnType.result, :fnType.args]])

      fnType' := nodeMappingType(rest typeList, first typeList)
      setTypeOf!(ctx, funDefNode, [fnType'])

      debug(["Function" :: PF, string(bold (fn.name :: PF)), "has" :: PF,
             bold(fnType' :: PF), "type based on definition." :: PF])

      -- Fetch signatures from the environment, including those defined by
      -- the domain / package / function. Filter out those that don't match
      -- the type calculated above.
      candidateList : List(MT) := []
      for n in env(fn.name) repeat
        candidate := emptyNode()

        if typeOrigin? n then
          to := n :: TO
          if to.type = ["$" :: Symbol] and mappingType? to.expr then
            candidate := to.expr
        if mappingType? n then
          candidate := n

        if not emptyNode? candidate then
          ures := unifyType(fnType', candidate)
          failed? ures => "iterate"
          candidate := substitute(fnType', ures :: SUBST)
          candidateList := [candidate :: MT, :candidateList]

      for c in candidateList repeat 
        for type in c.args | not unbound? type repeat
          env' := envAddType(type, env')

      -- TODO: Filter out function which have been already defined.

      if not empty? candidateList then
        info(["Environment contains" :: PF, string bold(fn.name :: PF),
              "from" :: PF, bold("$" :: PF), "with matching signatures:" :: PF,
              bold bracket [c :: PF for c in candidateList]])
      else
        info(["Considering" :: PF, string bold(fn.name :: PF),
              "of type" :: PF, bold(fnType :: PF),
              "to be a local function!" :: PF])
        candidateList := [fnType]

      setTypeOf!(ctx, funDeclNode, [[c] for c in candidateList])
      setTypeOf!(ctx, resNode, [c.result for c in candidateList])
      for argNode in argNodeList for i in 1.. repeat
        setTypeOf!(ctx, argNode, [c.args.i for c in candidateList])

      for n in fn.args for argNode in argNodeList repeat
        arg := n :: TD
        env'(arg.expr :: Symbol) := argNode.type

      bodyNode := walk(fn.body, ctx, env')

      leaveSubTree!(ctx)

      funDeclNode.rules := [ruleTypeIs(funDefNode, funDeclNode)]
      funDefNode.rules := [ruleFun(fn, argNodeList, resNode, bodyNode)]

      return funDeclNode

    walkFtor (ft : FT, ctx : CTX, env : ENV) : TN ==
      sig := signature ft
      -- sig is unchecked and may contain invalid types
      ftorApp := nodeApp([ft.name], [[td] for td in ft.args])

      debug pile([spaces ["Processing functor" :: PF, bold(ftorApp :: PF), "with:" :: PF],
                  ft.type :: PF])

      addSubTree!(ctx)

      this := addNode!(ctx, [ft.name], env)

      resNode := addNode!(ctx, ft.type, env)
      -- FIXME: Functor's return type is not of "Join" node!
      resType := (sequence? ft.type => nodeSeq("Join", (ft.type :: SEQ).list); ft.type)
      setTypeOf!(ctx, resNode, [resType])
      resType := resNode.type

      argSub := [[]]$AssociationList(Symbol, N)
      argNodeList : List(TN) := []

      -- process functor's arguments
      for arg in ft.args repeat
        name := arg.expr :: Symbol
        argNode := addNode!(ctx, arg.expr, env)
        setTypeOf!(ctx, argNode, [arg.type])
        env(name) := argNode.type
        env := envAddTypeAs(arg.type, name, env)
        argSub(name) := argNode.type
        argNodeList := [argNode, :argNodeList]

      argNodeList := reverse argNodeList
      argList := [argNode.node for argNode in argNodeList]
      env("$" :: Symbol) := nodeApp([ft.name], argList)
      setTypeOf!(ctx, this, [nodeMappingType(argList, resType)])

      -- process functor's body
      for n in (ft.type :: SEQ).list | typeDecl? n repeat
        td := n :: TD
        env(td.expr :: Symbol) := nodeTypeOrigin(td.type, ["$" :: Symbol])

      bodyNode := walk(ft.capsule, ctx, env)

      leaveSubTree!(ctx)

      this.rules := [ruleFtor(ft, argNodeList, resNode, bodyNode)]
      this

    walkImport (im : IM, ctx : CTX, env : ENV) : TN ==
      debug ["Importing" :: PF, im.type :: PF]
      env := envAddType(im.type, env)
      tn := addNode!(ctx, [im], env)
      setTypeOf!(ctx, tn, [voidType])
      done! tn

    walkLambda (lam : LAM, ctx : CTX, env : ENV) : TN ==
      this := addNode!(ctx, [lam], env)

      -- Replace unknown types with type variables and add arguments to the
      -- environment. Rewrite those lambda arguments that miss the type.
      deps : List(N) := []
      argList : List(TD) := []
      argTypeList : List(N) := []

      for arg in lam.args repeat
        name := arg.expr :: Symbol
        if emptyNode? arg.type then
          lamArg := addNode!(ctx, arg.expr, env)
          deps := [nodeRef(lamArg), :deps]
          argList := [[arg.expr, typeRef(lamArg)]$TD, :argList]
          argTypeList := [lamArg.type, :argTypeList]
          env(name) := lamArg.type
        else
          argList := [arg, :argList]
          argTypeList := [arg.type, :argTypeList]
          env(name) := arg.type

      argList := reverse argList
      argTypeList := reverse argTypeList

      retType := lam.type -- (emptyNode? lam.type => addTypeVar! ctx; lam.type)
      lamType := [argTypeList, retType]$MT

      debug ["Lambda expression of type" :: PF, bold(lamType :: PF)]

      -- generate a node with result type
      lamBodyType := addNode!(ctx, lam.type, env)
      lamBody := walk(lam.body, ctx, env)
      setTypeOf!(ctx, lamBodyType, [retType])
      lamBodyType.rules := [ruleSubType(lamBody, lamBodyType)]

      deps := concat(reverse deps, nodeRef(lamBodyType))

      -- add a node with type of the lambda expression just for dependants
      --setTypeOf!(ctx, this, [lamType])
      this.rules := [[deps, nodeLambda(argList, typeRef(lamBodyType), nodeRef(lamBody))]]
      this

    walkLoop (lp : LP, ctx : CTX, env : ENV) : TN ==
      debug ["Loop statement." :: PF]
      this := addNode!(ctx, [lp], env)
      deps : List(N) := []
      env' := env
      type : N

      if lp.kind case "collect" then
        itemTypeNode := addNode!(ctx, ['collect], env)
        deps := [nodeRef(itemTypeNode), :deps]
        setTypeOf!(ctx, this, [nodeApp(['List], [itemTypeNode.type])])
      else
        setTypeOf!(ctx, this, [voidType])

      debug ["Processing" :: PF, #(lp.itors) :: PF, "iterator(s)." :: PF]
      itorList : List(TN) := []
      for n in lp.itors repeat
        itor := n :: IT

        itorExpr := addNode!(ctx, n, env)
        varExpr := addNode!(ctx, [itor.var], env)
        seqType := addNode!(ctx, emptyNode(), env)
        seqExpr := walk(itor.seq, ctx, env)

        setTypeOf!(ctx, seqType,
            [nodeApp(['List], [varExpr.type]),
             nodeApp(['UniversalSegment], [varExpr.type])])
        seqType.rules := [ruleTypeIs(seqExpr, seqType), ruleSubType(seqExpr, seqType)]

        -- Iterator variable is added to loop's body environment,
        -- but is also known to guards.
        env'(itor.var) := varExpr.type

        setTypeOf!(ctx, itorExpr, [voidType])

        itorExpr.rules := [ruleLoopIter(varExpr, seqType, itorExpr)]
        itorList := [itorExpr, :itorList]

      debug ["Processing" :: PF, #(lp.guards) :: PF, "guard(s)." :: PF]
      guardList : List(TN) := []
      for guard in lp.guards repeat
        guardType := addNode!(ctx, guard, env')
        setTypeOf!(ctx, guardType, [booleanType])
        guardExpr := walk(guard, ctx, env')
        guardType.rules := [ruleSubType(guardExpr, guardType)]
        guardList := [guardType, :guardList]

      debug ["Processing loop body." :: PF]
      body :=
        lp.kind case "collect" =>
          bodyType := addNode!(ctx, lp.body, env')
          setTypeOf!(ctx, bodyType, [type])
          bodyExpr := walk(lp.body, ctx, env')
          bodyType.rules := [ruleSubType(bodyExpr, bodyType)]
          bodyType
        walk(lp.body, ctx, env')

      this.rules := [ruleLoop(lp.kind, itorList, guardList, body)]
      this

    walkSeg (seg : SEG, ctx : CTX, env : ENV) : TN ==
      debug ["Processing segment:" :: PF, string(seg :: PF)]
      this := addNode!(ctx, [seg], env)

      startExpr := walk(seg.start, ctx, env)

      endExpr' : Union(TN, "none") :=
        not emptyNode? seg.end =>
          endExpr := walk(seg.end, ctx, env)
          setTypeOf!(ctx, endExpr, [startExpr.type])
          endExpr
        "none"

      stepExpr' : Union(TN, "none") :=
        not emptyNode? seg.step =>
          stepExpr := walk(seg.step, ctx, env)
          setTypeOf!(ctx, stepExpr, [integerType])
          stepExpr
        "none"

      setTypeOf!(ctx, this, [nodeApp(['UniversalSegment], [startExpr.type])])
      this.rules := [ruleSeg(startExpr, endExpr', stepExpr')]
      this

    walkSeq (s : SEQ, ctx : CTX, env : ENV) : TN ==
      import List(TN)

      debug ["Found sequence of" :: PF, #(s.list) :: PF, "expressions." :: PF]
      this := addNode!(ctx, [s])

      exprList : List(TN) := [(n := walk(e, ctx, env); env := n.env; n) for e in s.list]

      this.rules := [ruleSeq(s.kind, this, exprList)]
      this.env := (last exprList).env
      this

    walkSym (s : Symbol, ctx : CTX, env : ENV) : TN ==
      debug ["Symbol lookup for" :: PF, string(s :: PF)]

      this := addNode!(ctx, [s], env)

      types := env(s)
      -- BUG: parseTran uses true and false as "Boolean" and not as "() -> Boolean"
      -- workaround for Boolean constants
      if s = 'true or s = 'false then
        types := [booleanType, :types]
      if s = '_$NoValue then
        types := [voidType, :types]
      if s = 'leave then
        leaveType := nodeMappingType([integerType, voidType], typeAny) 
        types := [leaveType, :types]
      if s = 'error then
        errorType := nodeMappingType([stringType], typeAny)
        types := [errorType, :types]
      if s = 'return then
        resType := node(ctx, 2).type
        returnType := nodeMappingType([integerType, resType], typeAny)
        types := [returnType, :types]

      -- handle a symbol which is a type constructor
      if inDatabase? s then
        ti := getTypeInfo([[s], [emptyNode()]]$APP)

        ftorArgList : List(N) := []
        ftorArgNodeList : List(TN) := []
        ftorArgRenames : SUBST := empty()

        for arg in ti.args repeat
          ftorArg := arg.expr
          ftorArgType := arg.type

          if typeVar? ftorArg then
            origFtorArg := ftorArg
            ftorArgType := substitute(ftorArgType, ftorArgRenames)

            ftorArgTypeNode := addNode!(ctx, ftorArgType, env)
            setTypeOf!(ctx, ftorArgTypeNode, [ftorArgType])

            ftorArgNode := addNode!(ctx, ftorArg, env)
            ftorArg := ftorArgNode.type
            ftorArgRenames(origFtorArg :: TV) := [ftorArg]
            ftorArgNodeList := [ftorArgNode, :ftorArgNodeList]
            ftorArgNode.rules := [ruleSuperType(ftorArgNode, ftorArgTypeNode)]

          ftorArgList := [ftorArg, :ftorArgList]

        ftorResType := nodeApp(['Type], [])
        ftorType := nodeMappingType(reverse ftorArgList, ftorResType)
        env(s) := ftorType
        types := [ftorType, :types]

        if not empty? ftorArgNodeList then
          this.rules := [[[nodeRef(n) for n in ftorArgNodeList], [s]]]

      empty? types =>
        fail ["Undefined symbol:" :: PF, bold red string (s :: PF), "!" :: PF]
        error ""
      
      info(["Found" :: PF, string bold(s :: PF), "with type :" :: PF,
            bold bracket [t :: PF for t in types]])
      setTypeOf!(ctx, this, types)
      this 

    walkTypeDecl (td : TD, ctx : CTX, env : ENV) : TN ==
      debug(["Expression" :: PF, td.expr :: PF, "has type" :: PF, td.type :: PF])

      not symbol? td.expr =>
        fail ["Type annotation works only for symbols!" :: PF]
        error ""

      -- Type definition for a symbol.
      s := td.expr :: Symbol
      ts := env(s)

      -- Add it to the environment or crash if already defined, unless it's
      -- another function declaration (i.e. allow function type overloading).
      if not mappingType? td.type then
        (not empty? ts) and (first ts ~= td.type) =>
          fail([bold red ("Error!" :: PF), "Symbol" :: PF, string(s :: PF),
                "already defined as" :: PF, bracket [t :: PF for t in ts], "!" :: PF])
          error ""

      env(s) := td.type
      n := addNode!(ctx, [td], env)
      setTypeOf!(ctx, n, [td.type])
      done! n

    walkTypeSelect (ts : TS, ctx : CTX, env : ENV) : TN ==
      debug(["Expression" :: PF, ts.expr :: PF,
             "has to return type" :: PF, ts.type :: PF])

      not apply? ts.expr =>
        fail ["Type cut operator works only for function application!" :: PF]
        error ""

      env := envAddType(ts.type, env)
      this := addNode!(ctx, [ts], env)
      expr := walk(ts.expr, ctx, env)
      setTypeOf!(ctx, this, [ts.type])
      this.rules := [ruleSubType(expr, this)]
      this

    walkTypeCoerce (tc : TC, ctx : CTX, env : ENV) : TN ==
      debug ["Expression" :: PF, tc.expr :: PF, "have to coerce to" :: PF, tc.type :: PF]
      env := envAddType(tc.type, env)

      this := addNode!(ctx, [tc], env)
      setTypeOf!(ctx, this, [tc.type])

      expr := walk(tc.expr, ctx, env)
      coerceFun := walk(['coerce], ctx, env)
      this.rules := [ruleSubType(expr, this), ruleApply(coerceFun, [expr])]
      this
    
    walkTypeOrigin (to : TO, ctx : CTX, env : ENV) : TN ==
      not symbol? to.expr =>
        fail ("Type origin selector works only for symbols!" :: PF)
        error ""

      debug(["Symbol" :: PF, string(to.expr :: PF),
             "must originate from" :: PF, bold(to.type :: PF),
             "type!" :: PF])

      env := envAddType(to.type, env)
      this := addNode!(ctx, [to], env)

      expr := walk(to.expr, ctx, env)

      this.rules := [ruleTypeOrigin(expr, to.type)]
      this

    walkCase (c : SC, ctx : CTX, env : ENV) : TN ==
      env := envAddType(c.type, env)

      this := addNode!(ctx, [c], env)
      setTypeOf!(ctx, this, [booleanType])

      if symbol? c.expr then
        this.env := (env(c.expr :: Symbol) := c.type)

      exprType := addNode!(ctx, c.type, env)
      setTypeOf!(ctx, exprType, [c.type])

      expr := walk(c.expr, ctx, env)
      exprType.rules := [ruleSuperType(exprType, expr)]

      this.rules := [[[nodeRef(exprType)], [c]]]
      this

    walkInt (i : Integer, ctx : CTX, env : ENV) : TN ==
      debug [i :: PF, "is" :: PF, integerType :: PF, ":)" :: PF]
      type :=
        i > 0 => nodeApp(['PositiveInteger], [])
        i >= 0 => nodeApp(['NonNegativeInteger], [])
        nodeApp(['NonNegativeInteger], [])
      this := addNode!(ctx, [i], env)
      setTypeOf!(ctx, this, [type])
      this

    walkFlt (f : DoubleFloat, ctx : CTX, env : ENV) : TN ==
      debug [f :: PF, "is" :: PF, floatType :: PF, ":)" :: PF]
      this := addNode!(ctx, [f], env)
      setTypeOf!(ctx, this, [floatType])
      this

    walkStr (s : String, ctx : CTX, env : ENV) : TN ==
      debug [string(s :: PF), "is" :: PF, stringType :: PF, ":)" :: PF]
      this := addNode!(ctx, [s], env)
      setTypeOf!(ctx, this, [[string(s :: Symbol)], stringType])
      this

    walkEmpty (e : N, ctx : CTX, env : ENV) : TN ==
      this := addNode!(ctx, e, env)
      setTypeOf!(ctx, this, [typeUndef])
      this

    walk (n, ctx, env) ==
      apply? n => walkApp(n :: APP, ctx, env)
      assign? n => walkAssign(n :: ASS, ctx, env)
      case? n => walkCase(n :: SC, ctx, env)
      condExpr? n => walkCondExpr(n :: CE, ctx, env)
      float? n => walkFlt(n :: DoubleFloat, ctx, env)
      functor? n => walkFtor(n :: FT, ctx, env)
      import? n => walkImport(n :: IM, ctx, env)
      integer? n => walkInt(n :: Integer, ctx, env)
      lambda? n => walkLambda(n :: LAM, ctx, env)
      loop? n => walkLoop(n :: LP, ctx, env)
      segment? n => walkSeg(n :: SEG, ctx, env)
      sequence? n => walkSeq(n :: SEQ, ctx, env)
      string? n => walkStr(n :: String, ctx, env)
      symbol? n => walkSym(n :: Symbol, ctx, env)
      typeCoerce? n => walkTypeCoerce(n :: TC, ctx, env)
      typeDecl? n => walkTypeDecl(n :: TD, ctx, env)
      typeOrigin? n => walkTypeOrigin(n :: TO, ctx, env)
      typeSelect? n => walkTypeSelect(n :: TS, ctx, env)
      function? n => walkFun(n :: FN, ctx, env)
      emptyNode? n => walkEmpty(n, ctx, env)
      -- namedType, mappingType, recordType, sumType, unionType, macro, where
      fail ["Expression" :: PF, bold red paren(n :: PF), "not handled yet!" :: PF]
      error ""
