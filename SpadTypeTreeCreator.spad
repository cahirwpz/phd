)abbrev package STRFAC SpadTypeRuleFactory
SpadTypeRuleFactory() : Exports == Implementation where
  N ==> SpadNode
  FN ==> SpadFunction(N)
  FT ==> SpadFunctor(N)
  TR ==> SpadTypeRule
  TN ==> SpadTypeNode
  OTN ==> Union(TN, "none")

  Exports ==> with
    ruleAssign : (TN, TN) -> TR
    ruleAssignFresh : (TN, TN, TN) -> TR
    ruleApply : (TN, List(TN)) -> TR
    ruleApply : (TN, List(TN), List(TN)) -> TR
    ruleCoerce : (TN, List(TN), N) -> TR
    ruleCondExpr : (TN, TN, TN) -> TR
    ruleIfThen : (TN, TN) -> TR
    ruleFun : (FN, List(TN), TN, TN) -> TR
    ruleFunDef : (TN, TN) -> TR
    ruleFtor : (FT, List(TN), TN, TN, TN) -> TR
    ruleLoopIter : (TN, TN, TN) -> TR
    ruleLoop : (Union("loop", "collect", "repeat"), 
                List(TN), List(TN), Union(TN, "none"), TN) -> TR
    ruleRef : (List(TN), TN) -> TR
    ruleTypeIs : (TN, TN) -> TR
    ruleTypeIs : (List(TN), TN, TN) -> TR
    ruleSeg : (TN, OTN, OTN) -> TR
    ruleSeq : (Union("Domain", "Package", "Join", "Capsule", "Sequence",
                     "Tuple", "Body"), TN, List(TN)) -> TR
    ruleCapsule : List(TN) -> TR
    ruleTypeOrigin : (TN, N) -> TR
    ruleSubType : (TN, TN) -> TR
    ruleSubType : (List(TN), TN, TN) -> TR
    ruleSuperType : (TN, TN) -> TR

  Implementation ==> add
    import SpadNodeFactory

    -- for assignment "L := R" do:
    -- compute "L, R"; if "L := R" then solution is "L := R"
    ruleAssign (L', R') ==
      (L, R) := (nodeRef(L'), nodeRef(R'))
      [[L, R, nodeAssign(L, R)], nodeAssign(L, R)]

    ruleAssignFresh (D', L', R') ==
      (D, L, R) := (nodeRef(D'), nodeRef(L'), nodeRef(R'))
      [[D, L, R, nodeAssign(L, R)], nodeSeq("Sequence", [D, nodeAssign(L, R)])]

    ruleApply (fun, args) ==
      (funRef, argRefs) := (nodeRef(fun), [nodeRef(arg) for arg in args])
      [[funRef, :argRefs, nodeApp(funRef, argRefs)],
       nodeApp(funRef, argRefs)]

    ruleApply (fun, args, extras) ==
      (funRef, argRefs) := (nodeRef(fun), [nodeRef(arg) for arg in args])
      extraRefs := [nodeRef(extra) for extra in extras]
      [[:extraRefs, funRef, :argRefs, nodeApp(funRef, argRefs)],
       nodeApp(funRef, argRefs)]

    ruleCoerce (fun, args, rtyp) ==
      (funRef, argRefs) := (nodeRef(fun), [nodeRef(arg) for arg in args])
      [[funRef, :argRefs, nodeApp(funRef, argRefs)],
       nodeTypeSelect(nodeApp(funRef, argRefs), rtyp)]

    ruleCondExpr (C', T', F') ==
      (C, T, F) := (nodeRef(C'), nodeRef(T'), nodeRef(F'))
      [[C, T, F, nodeCondExpr(C, T, F)], nodeCondExpr(C, T, F)]

    ruleIfThen (C', T') ==
      (C, T) := (nodeRef(C'), nodeRef(T'))
      [[C, T, nodeCondExpr(C, T, emptyNode)], nodeCondExpr(C, T, emptyNode)]

    -- for function "fn (a1 : A1, ..., an : An) : T == B" do:
    -- compute "A1, ..., An, T, B"; if "T is B" then solution is "fn"
    ruleFun (fn, As', T', B') ==
      (As, T, B) := ([nodeRef(a) for a in As'], nodeRef(T'), nodeRef(B'))
      [[:As, T, B, nodeSubType(B, T)], nodeFun(fn.name, As, T, B)]

    ruleFunDef (S', T') ==
      (S, T) := (nodeRef(S'), nodeRef(T'))
      [[S, nodeTypeIs(S, T)], S]

    -- for functor "ft (a1 : A1, ..., an : An) : T == E add B" do:
    -- compute "A1, ..., An, T, B"; if "B <: T" then solution is "ft"
    ruleFtor (ft, As', E', T', B') ==
      As := [nodeRef(a) for a in As']
      (E, T, B) := (nodeRef(E'), nodeRef(T'), nodeRef(B'))
      [[:As, E, T, B, nodeSubType(B, T)], nodeFtor(ft.name, ft.args, T, E, B)]

    ruleLoopIter (var, seq, iter) == 
      (varRef, seqRef, iterRef) := (nodeRef(var), nodeRef(seq), nodeRef(iter))
      [[varRef, seqRef], nodeIterator(var.node :: Symbol, seqRef)]

    ruleLoop (kind, itors, guards, bodyType, body) ==
      itorRefs := [nodeRef(itor) for itor in itors]
      guardRefs := [nodeRef(guard) for guard in guards]
      bodyRef := nodeRef(body)
      formulas :=
        bodyType case TN =>
          [:itorRefs, :guardRefs, nodeRef(bodyType), bodyRef]
        [:itorRefs, :guardRefs, bodyRef]
      [formulas, nodeLoop(kind, itorRefs, guardRefs, bodyRef)]

    ruleRef (deps, body) ==
      depRefs := [nodeRef(dep) for dep in deps]
      bodyRef := nodeRef(body)
      [depRefs, bodyRef]

    ruleSeg (start, end, step) ==
      startRef := nodeRef(start)
      formulas := [startRef]$List(N)
      if end case TN then
        endRef := nodeRef(end)
        concat!(formulas, endRef)
      else
        endRef := emptyNode()
      if step case TN then
        stepRef := nodeRef(step)
        concat!(formulas, stepRef)
      else
        stepRef := emptyNode()
      [formulas, nodeSeg(startRef, endRef, stepRef)]

    ruleSeq (kind, seq, exprs) ==
      (seqRef, exprRefs) := (nodeRef(seq), [nodeRef(expr) for expr in exprs])
      [[:exprRefs, nodeTypeIs(seqRef, last exprRefs)], nodeSeq(kind, exprRefs)]

    ruleCapsule exprList ==
      exprRefList := [nodeRef(expr) for expr in exprList | not done? expr]
      [exprRefList, nodeSeq("Capsule", exprRefList)]

    ruleTypeOrigin (expr, origin) ==
      exprRef := nodeRef(expr)
      [[exprRef, nodeTypeOrigin(exprRef, origin)],
       nodeTypeOrigin(exprRef, origin)]

    ruleSuperType (superType, type) ==
      (superTypeRef, typeRef) := (nodeRef(superType), nodeRef(type))
      [[typeRef, nodeSubType(superTypeRef, typeRef)], nodeRef(type)]

    -- compute "S"; if "S is T" then solution is "S"
    ruleTypeIs (S', T') ==
      ruleTypeIs ([], S', T')

    -- compute "P1, ..., Pn, S"; if "S is T" then solution is "S"
    ruleTypeIs (Ps', S', T') ==
      (Ps, S, T) := ([nodeRef(p) for p in Ps'], nodeRef(S'), nodeRef(T'))
      [[:Ps, S, nodeTypeIs(S, T)], S]

    -- compute "S"; if "S <: T" then solution is "S"
    ruleSubType (S', T') ==
      ruleSubType ([], S', T')

    -- compute "P1, ..., Pn, S"; if "S <: T" then solution is "S"
    ruleSubType (Ps', S', T') ==
      (Ps, S, T) := ([nodeRef(p) for p in Ps'], nodeRef(S'), nodeRef(T'))
      [[:Ps, S, nodeSubType(S, T)], S]


)abbrev package STEXCAPT SpadTreeExtractCapsuleType
SpadTreeExtractCapsuleType(find : NR -> TN) : SpadTreeWalkerCategory == Implementation where
  PF ==> PrintableForm
  PI ==> PositiveInteger
  N ==> SpadNode
  APP ==> SpadApply(N)
  ASS ==> SpadAssign(N)
  CE ==> SpadCondExpr(N)
  FN ==> SpadFunction(N)
  NR ==> SpadNodeRef(N)
  TD ==> SpadTypeDecl(N)
  TO ==> SpadTypeOrigin(N)
  TV ==> SpadTypeVar(N)
  SEQ ==> SpadSequence(N)
  TN ==> SpadTypeNode

  Implementation ==> add
    import Logger('Capsule)

    rewrite (seq : SEQ) : N ==
      ns := [rewrite(coerce(n)@NR) for n in seq.list | nodeRef? n]
      nodeSeq("Join", [n for n in ns | not emptyNode? n])

    rewrite (ass : ASS) : N == emptyNode()
    rewrite (td : TD) : N == emptyNode()

    rewrite (nr : NR) : N ==
      tn := find(nr)
      tn.node = [nr] =>
        fail pile ["Self reference detected:" :: PF, tn :: PF]
        error ""
      -- nodes that have no rules are leaves and we accept them
      empty? tn.rules => rewrite tn.node
      n := first(tn.rules).solution
      -- for functions take definition type
      function? n =>
        fn : FN := coerce(n)
        fnName : Symbol := coerce(fn.name)
        nodeTypeDecl([fnName], tn.type)
      -- for conditional expression add type guards to the content of branches
      condExpr? n =>
        ce : CE := coerce(n)
        cond := rewrite(ce.cond)
        truebr := nodeTypeGuard(rewrite(ce.truebr), cond)
        falsebr := nodeTypeGuard(rewrite(ce.falsebr), nodeApp(['not], [cond]))
        nodeSeq("Join", [truebr, falsebr])
      rewrite n

)abbrev package STTCREAT SpadTypeTreeCreator
SpadTypeTreeCreator() : Exports == Implementation where
  PF ==> PrintableForm
  PI ==> PositiveInteger

  N ==> SpadNode
  APP ==> SpadApply(N)
  ASS ==> SpadAssign(N)
  CE ==> SpadCondExpr(N)
  FN ==> SpadFunction(N)
  FT ==> SpadFunctor(N)
  IM ==> SpadImport(N)
  IT ==> SpadIterator(N)
  LAM ==> SpadLambda(N)
  LP ==> SpadLoop(N)
  MT ==> SpadMappingType(N)
  NR ==> SpadNodeRef(N)
  RT ==> SpadRecordType(N)
  SC ==> SpadCase(N)
  SEG ==> SpadSegment(N)
  SEQ ==> SpadSequence(N)
  SM ==> SpadMacro(N)
  TC ==> SpadTypeCoerce(N)
  TD ==> SpadTypeDecl(N)
  TEH ==> SpadTypeHas(N)
  TEI ==> SpadTypeIs(N)
  TG ==> SpadTypeGuard(N)
  TO ==> SpadTypeOrigin(N)
  TI ==> SpadTypeInfo(N)
  TS ==> SpadTypeSelect(N)
  TV ==> SpadTypeVar(N)
  UT ==> SpadUnionType(N)
  SW ==> SpadWhere(N)

  SUBS ==> AssociationList(TV, List(N))

  ENV ==> SpadEnvironment
  TN ==> SpadTypeNode
  TR ==> SpadTypeRule
  CTX ==> SpadTypeTree

  Exports ==> with
    walk : (N, CTX, ENV) -> TN

  Implementation ==> add
    import SpadNode
    import SpadNodeFactory
    import SpadDatabase
    import SpadEnvironment
    import SpadTypeEvaluator
    import SpadTypeRuleFactory
    import SpadTypeNodeArray
    import SpadLogic
    import TypeUnifier
    import TypeEvaluator
    import Printer
    import Logger('Create)

    envAddType (t : N, env : ENV) : ENV ==
      apply? t =>
        app := t :: APP
        env := addDomain(app, env)
        for k in app.args repeat
          env := envAddType(k, env)
        env

      mappingType? t =>
        mt := t :: MT
        for k in [mt.result, :mt.args] repeat
          env := envAddType(k, env)
        env

      recordType? t =>
        rt := t :: RT
        for f in fields rt repeat
          env := envAddType(f.type, env)
        for f in makeRecordFunList t repeat
          env(f.expr :: Symbol) := nodeTypeOrigin(f.type, t)
        env

      unionType? t =>
        ut := t :: UT
        for v in variants ut repeat
          if typeDecl? v then
            v := (v :: TD).type
          env := envAddType(v, env)
        for f in makeUnionFunList t repeat
          env(f.expr :: Symbol) := nodeTypeOrigin(f.type, t)
        env

      symbol? t => env -- BUG! this is not correct but will do for time being
      string? t => env

      fail ["Type" :: PF, bold(t :: PF), "not handled!" :: PF]
      error "envAddType"

    walkApp (a : APP, ctx : CTX, env : ENV) : TN ==
      -- treat QUOTE(symbol) application as a symbol value
      a.function = ['QUOTE] and #a.args = 1 =>
        this := addNode!(ctx, [a], env)
        setTypeOf!(ctx, this, [symbolType])
        this

      debug ["Processing function application." :: PF]

      this := addNode!(ctx, [a], env)

      -- First case: just a function call.
      funExpr := walk(a.function, ctx, env)
      argExprList := [walk(arg, ctx, env) for arg in a.args]

      -- Second case: element indexing or record field access.
      eltFunList : List(N) := []
      eltFunTypeList : List(MT) := []
      if a.function ~= ['elt] and a.function ~= ['return] then
        for n in search('elt, env) | typeOrigin? n repeat
          eltFunType := (n :: TO).expr :: MT
          if #eltFunType.args = #a.args + 1 then
            eltFunList := [n, :eltFunList]
            eltFunTypeList := [eltFunType, :eltFunTypeList]

      if not empty? eltFunList then
        eltFunExpr := addNode!(ctx, ['elt], env)
        eltFunExpr.node := nodeTypeOrigin(eltFunExpr.node, typeRef(eltFunExpr))
        setTypeOf!(ctx, eltFunExpr, eltFunList)
        this.rules :=
          [ruleApply(eltFunExpr, [funExpr, :argExprList]), :this.rules]

      -- Add origin to function expression.
      if not(funExpr.node = ['return] or funExpr.node = ['error]) then
        funExpr.node := nodeTypeOrigin(funExpr.node, typeRef(funExpr))

      -- First case with a twist: arbitrary list construction.
      if a.function = ['construct] then
        item := addNode!(ctx, emptyNode(), env)
        item.node := item.type
        setTypeOf!(ctx, item, dropSubTypes [argExpr.type for argExpr in argExprList])
        constructArgs := [item.type for i in 1..#a.args]
        constructRes := nodeApp(['List], [item.type])
        extendTypeOf!(ctx, funExpr, [nodeMappingType(constructArgs, constructRes)])
        this.rules := [ruleApply(funExpr, argExprList, [item]), :this.rules]

      this.rules := [ruleApply(funExpr, argExprList), :this.rules]
      this

    walkAssign (a : ASS, ctx : CTX, env : ENV) : TN ==
      apply? a.lval =>
        app := a.lval :: APP
        this := walk(nodeApp(['setelt!], [app.function, :app.args, a.rval]), ctx, env)
        this.node := [a]
        this

      this := addNode!(ctx, emptyNode())
      right := walk(a.rval, ctx, env)

      fresh? :=
        symbol? a.lval =>
          s := a.lval :: Symbol
          -- user can overload a symbol of function that belong to any capsule,
          -- to check if overloading takes place and fresh symbol must be
          -- introduced we need to filter out mappings with origin
          ts := [t for t in search(s, env) | not typeOrigin? t]
          empty? ts
        false

      decl : TN

      if fresh? then
        debug ["Processing fresh assignment" :: PF, string(a.lval :: PF)]
        -- introduce type declaration and propagate type through environment
        decl := walk(nodeTypeDecl(a.lval, right.type), ctx, env)
        env := decl.env

      left := walk(a.lval, ctx, env)

      -- Only left-value environment is propagated!
      this.env := left.env
      if fresh? then
        this.rules := [ruleAssignFresh(decl, left, right)]
      else
        this.rules := [ruleAssign(left, right)]
      this

    walkCondExpr (ce : CE, ctx : CTX, env : ENV) : TN ==
      debug ["Processing conditional expression." :: PF]
      this := addNode!(ctx, [ce])

      cond := walk(ce.cond, ctx, env)
      trueEnv := createScope cond.env
      trueEnv := addConstraints(ce.cond, trueEnv)
      truebr := walk(ce.truebr, ctx, trueEnv)

      emptyNode? ce.falsebr =>
        this.env := env
        this.rules := [ruleIfThen(cond, truebr)]
        this

      falseEnv := createScope (case? ce.cond => env; cond.env)
      falseEnv := addConstraints(nodeApp(['not], [ce.cond]), falseEnv)
      falsebr := walk(ce.falsebr, ctx, falseEnv)

      env := mergeEnv(env, trueEnv, falseEnv)

      -- TODO: "truebr.env" and "falsebr.env" should be merged and passed
      -- forward instead of just "env". Merging means that if the same variable
      -- was introduced in both branches then it should be present in the final
      -- environment.
      --
      -- Q: What if a variable "x : T" is defined only in one branch?
      -- A: In merged envrionment introduce "x" with type Union(T, "undefined"),
      --    and emit a warning when subtyping rule is applied.
      this.env := env
      this.rules := [ruleCondExpr(cond, truebr, falsebr)]
      this

    walkFun (fn : FN, ctx : CTX, env : ENV) : TN ==
      funName := (fn.name case "lambda" => '_+_-_>; fn.name :: Symbol)
      funDeclNode := addNode!(ctx, emptyNode(), env)

      if fn.name case "lambda" then
        debug ("Processing lambda expression." :: PF)
      else
        debug ["Processing function" :: PF, string(funName :: PF)]

      addSubTree!(ctx)
      env' := createScope env

      -- It's vitally important that result type is represented by "%2" type
      -- variable (e.g. 'return' refers to "%2").
      funDefNode := addNode!(ctx, emptyNode(), env')
      resNode := addNode!(ctx, emptyNode(), env')
      argNodeList := [addNode!(ctx, emptyNode(), env') for n in fn.args]

      resNode.node := resNode.type
      for argNode in argNodeList for n in fn.args repeat
        argNode.node :=
          typeDecl? n => nodeTypeDecl((n :: TD).expr, argNode.type)
          string? n => n
          error "walkApp: unexpected argument format"

      -- Take the type of function and replace those components, that were not
      -- specified, with type variables.
      fnType : MT := signature fn

      for argNode in argNodeList for argType in fnType.args repeat
        if not unbound? argType then
          bindNode!(ctx, argNode, argType)
          done! argNode

      if not unbound? fnType.result then
        bindNode!(ctx, resNode, fnType.result)
        done! resNode

      typeList : List(N) :=
        ([(emptyNode?(t) => n.type; t)
          for n in [resNode, :argNodeList] for t in [fnType.result, :fnType.args]])

      fnType' := nodeMappingType(rest typeList, first typeList)
      setTypeOf!(ctx, funDefNode, [fnType'])

      if fn.name case "lambda" then
        debug(["Lambda expression has" :: PF, bold(fnType' :: PF),
               "type based on definition." :: PF])
      else
        debug(["Function" :: PF, string(bold (funName :: PF)), "has" :: PF,
               bold(fnType' :: PF), "type based on definition." :: PF])

      -- Fetch signatures from the environment, including those defined by
      -- the domain / package / function. Filter out those that don't match
      -- the type calculated above.
      candidateList : List(MT) := []

      dom := first env("$" :: Symbol)

      if fn.name case Symbol then
        for n in search(fn.name :: Symbol, env') repeat
          candidate := emptyNode()

          if typeGuard? n then
            tg := n :: TG
            if true? evaluate(tg.type, env("ctrs")) then
              candidate := tg.expr
          if typeOrigin? n then
            to := n :: TO
            if to.type = dom and mappingType? to.expr then
              candidate := to.expr
          if mappingType? n then
            candidate := n

          if not emptyNode? candidate then
            ures := unifyType(fnType', candidate)
            ures case "failed" => "iterate"
            candidate := substitute(fnType', ures :: SUBS)
            candidateList := [candidate :: MT, :candidateList]

      for c in candidateList repeat 
        for type in c.args | not unbound? type repeat
          env' := envAddType(type, env')
        if not unbound? c.result then
          env' := envAddType(c.result, env')

      -- TODO: Filter out function which have been already defined.
      if not empty? candidateList then
        info(["Environment contains" :: PF, string bold(funName :: PF),
              "from" :: PF, bold("$" :: PF), "with matching signatures:" :: PF,
              bold bracket [c :: PF for c in candidateList]])

        extendTypeOf!(ctx, funDeclNode, [[c] for c in candidateList])
        extendTypeOf!(ctx, resNode, [c.result for c in candidateList])
        for argNode in argNodeList for i in 1.. repeat
          extendTypeOf!(ctx, argNode, [c.args.i for c in candidateList])
      else
        info(["Considering" :: PF, string bold(funName :: PF),
              "of type" :: PF, bold(fnType :: PF),
              "to be a local function!" :: PF])

      for n in fn.args for argNode in argNodeList repeat
        typeDecl? n =>
          td := n :: TD
          env'(td.expr :: Symbol) := argNode.type
        string? n =>
          s := n :: String
          env'(s :: Symbol) := n
        error "walkFun: unexpected argument format"

      if fn.name case Symbol then
        -- add the type to environment visible inside function's body
        -- to enable recursion
        env'(fn.name :: Symbol) := funDefNode.type

      bodyNode := walk(fn.body, ctx, env')

      leaveSubTree!(ctx)

      -- lambda is an expression so it must have a type (of its definiton)
      funDeclType := (fn.name case "lambda" => funDefNode.type; typeUndef)
      bindNode!(ctx, funDeclNode, funDeclType)

      funDeclNode.node := nodeRef(funDefNode)
      funDeclNode.rules := [ruleRef([funDefNode], funDefNode)]
      if fresh? and fn.name case Symbol then
        -- propagate function's declaration
        (funDeclNode.env)(fn.name :: Symbol) := funDefNode.type
      funDefNode.rules := [ruleFun(fn, argNodeList, resNode, bodyNode)]

      return funDeclNode

    walkFtor (ft : FT, ctx : CTX, env : ENV) : TN ==
      sig := signature ft
      -- sig is unchecked and may contain invalid types
      ftorApp := nodeApp([ft.name], [[td] for td in ft.args])

      debug pile([spaces ["Processing functor" :: PF, bold(ftorApp :: PF),
                          "with:" :: PF], ft.type :: PF])

      addSubTree!(ctx)

      this := addNode!(ctx, [ft.name], env)

      resNode := addNode!(ctx, ft.type, env)
      resType := resNode.type

      argSub := [[]]$Table(Symbol, N)
      argNodeList : List(TN) := []

      -- process functor's arguments
      for arg in ft.args repeat
        name := arg.expr :: Symbol
        argNode := addNode!(ctx, arg.expr, env)
        bindNode!(ctx, argNode, arg.type)
        env(name) := argNode.type
        env := addDomainAs(arg.type :: APP, name, env)
        argSub(name) := argNode.type
        argNodeList := [argNode, :argNodeList]

      argNodeList := reverse argNodeList
      argList := [argNode.node for argNode in argNodeList]
      ftType := nodeApp([ft.name], argList)
      env("$" :: Symbol) := ftType
      setTypeOf!(ctx, this, [nodeMappingType(argList, resType)])

      -- add functor's type info to the environment
      invalidateTypeInfo(ft.name)
      ti := getTypeInfo ft
      env := addDomain(ftType :: APP, env)
      ftRealType := substitute(first env(ftType :: APP), typeVar() :: TV, ftType)
      ftRes :=
        ft.type = categoryType => categoryType()
        -- FIXME: Functor's return type is not of "Join" node!
        nodeSeq("Join", (ftRealType :: TI).body.list)
      bindNode!(ctx, resNode, ftRes)

      extNode := addNode!(ctx, ft.extends, env)
      bindNode!(ctx, extNode,
                (emptyNode? ft.extends => typeUndef(); ft.extends))

      bodyNode := walk(ft.capsule, ctx, env)

      capsuleType := nodeSeq("Join", [extNode.type, bodyNode.type])

      leaveSubTree!(ctx)

      this.rules := [ruleFtor(ft, argNodeList, extNode, resNode, bodyNode)]
      this

    walkImport (im : IM, ctx : CTX, env : ENV) : TN ==
      debug ["Importing" :: PF, im.type :: PF]
      env := envAddType(im.type, env)
      tn := addNode!(ctx, [im], env)
      bindNode!(ctx, tn, typeUndef)
      done! tn

    walkLoop (lp : LP, ctx : CTX, env : ENV) : TN ==
      debug ["Loop statement." :: PF]

      this := addNode!(ctx, [lp], env)
      env' := env

      debug ["Processing" :: PF, #(lp.itors) :: PF, "iterator(s)." :: PF]
      itorList : List(TN) := []
      for n in lp.itors repeat
        itor := n :: IT

        itorExpr := addNode!(ctx, n, env)
        varExpr := addNode!(ctx, [itor.var], env)
        seqType := addNode!(ctx, emptyNode(), env)
        seqExpr := walk(itor.seq, ctx, env)

        setTypeOf!(ctx, seqType,
            [nodeApp(['List], [varExpr.type]),
             nodeApp(['UniversalSegment], [varExpr.type])])
        seqType.rules := [ruleTypeIs(seqExpr, seqType), ruleSubType(seqExpr, seqType)]

        -- Iterator variable is added to loop's body environment,
        -- but is also known to guards.
        env'(itor.var) := varExpr.type

        bindNode!(ctx, itorExpr, typeUndef)

        itorExpr.rules := [ruleLoopIter(varExpr, seqType, itorExpr)]
        itorList := [itorExpr, :itorList]

      debug ["Processing" :: PF, #(lp.guards) :: PF, "guard(s)." :: PF]
      guardList : List(TN) := []
      for guard in lp.guards repeat
        guardExpr := walk(guard, ctx, env')
        bindNode!(ctx, guardExpr, booleanType)
        guardList := [guardExpr, :guardList]

      debug ["Processing loop body." :: PF]
      maybeBodyType : Union(TN, "none") := "none"
      body : TN
      if lp.kind case "collect" then
        bodyType := addNode!(ctx, emptyNode, env)
        body := walk(lp.body, ctx, env')
        bodyType.node := bodyType.type
        bodyType.rules := [ruleSubType(body, bodyType)]
        setTypeOf!(ctx, body, [bodyType.type])
        setTypeOf!(ctx, this, [nodeApp(['List], [bodyType.type])])
        maybeBodyType := bodyType
      else
        body := walk(lp.body, ctx, env')
        setTypeOf!(ctx, body, [typeAny])
        bindNode!(ctx, this, typeUndef)

      this.rules := 
        [ruleLoop(lp.kind, itorList, guardList, maybeBodyType, body)]
      this

    walkSeg (seg : SEG, ctx : CTX, env : ENV) : TN ==
      debug ["Processing segment:" :: PF, string(seg :: PF)]
      this := addNode!(ctx, [seg], env)

      startExpr := walk(seg.start, ctx, env)

      endExpr' : Union(TN, "none") :=
        not emptyNode? seg.end =>
          endExpr := walk(seg.end, ctx, env)
          setTypeOf!(ctx, endExpr, [startExpr.type])
          endExpr
        "none"

      stepExpr' : Union(TN, "none") :=
        not emptyNode? seg.step =>
          stepExpr := walk(seg.step, ctx, env)
          setTypeOf!(ctx, stepExpr, [integerType])
          stepExpr
        "none"

      setTypeOf!(ctx, this, [nodeApp(['UniversalSegment], [startExpr.type])])
      this.rules := [ruleSeg(startExpr, endExpr', stepExpr')]
      this

    walkSeq (s : SEQ, ctx : CTX, env : ENV) : TN ==
      import List(TN)

      debug ["Found sequence of" :: PF, #(s.list) :: PF, "expressions." :: PF]
      this := addNode!(ctx, [s])

      exprList : List(TN) := [(n := walk(e, ctx, env); env := n.env; n) for e in s.list]

      if s.kind = "Capsule" then
        rule := ruleCapsule(exprList)
        findTypeNode := ((nr : NR) : TN +-> node(ctx, nr))
        capsuleType := rewrite(rule.solution)$SpadTreeExtractCapsuleType(findTypeNode)
        bindNode!(ctx, this, capsuleType)
        this.rules := [rule]
      else
        this.rules := [ruleSeq(s.kind, this, exprList)]
      this.env := (last exprList).env
      this

    walkSym (s : Symbol, ctx : CTX, env : ENV) : TN ==
      debug ["Symbol lookup for" :: PF, string(s :: PF)]

      this := addNode!(ctx, [s], env)

      types := search(s, env)

      -- BUG: parseTran uses true and false as "Boolean" and not as "() -> Boolean"
      -- workaround for Boolean constants
      if s = 'true or s = 'false then
        types := [booleanType, :types]
      if s = '_$NoValue then
        types := [voidType, :types]
      if s = 'leave then
        leaveType := nodeMappingType([integerType, voidType], typeUndef) 
        types := [leaveType, :types]
      if s = 'error then
        errorType := nodeMappingType([stringType], typeAny)
        types := [errorType, :types]
      if s = 'return then
        resType := node(ctx, 2).type
        returnType := nodeMappingType([positiveIntegerType, resType], typeAny)
        types := [returnType, :types]

      -- handle a symbol which is a type constructor
      if inDatabase? s then
        ti := getTypeInfo([[s], [emptyNode()]]$APP)

        ftorArgList : List(N) := []
        ftorArgNodeList : List(TN) := []
        ftorArgRenames : SUBS := empty()

        for arg in ti.args repeat
          ftorArg := arg.expr
          ftorArgType := arg.type

          if typeVar? ftorArg then
            origFtorArg := ftorArg
            ftorArgType := substitute(ftorArgType, ftorArgRenames)

            ftorArgTypeNode := addNode!(ctx, ftorArgType, env)
            setTypeOf!(ctx, ftorArgTypeNode, [ftorArgType])

            ftorArgNode := addNode!(ctx, ftorArg, env)
            ftorArg := ftorArgNode.type
            ftorArgRenames(origFtorArg :: TV) := [ftorArg]
            ftorArgNodeList := [ftorArgNode, :ftorArgNodeList]
            ftorArgNode.rules := [ruleSuperType(ftorArgNode, ftorArgTypeNode)]

          ftorArgList := [ftorArg, :ftorArgList]

        ftorResType := nodeApp(['Type], [])
        ftorType := nodeMappingType(reverse ftorArgList, ftorResType)
        env(s) := ftorType
        types := [ftorType, :types]

        if not empty? ftorArgNodeList then
          this.rules := [[[nodeRef(n) for n in ftorArgNodeList], [s]]]

      empty? types =>
        fail ["Undefined symbol:" :: PF, bold red string (s :: PF), "!" :: PF]
        debug (env :: PF)
        error ""
      
      info(["Found" :: PF, string bold(s :: PF), "with type :" :: PF,
            bold bracket [t :: PF for t in types]])
      setTypeOf!(ctx, this, types)
      this 

    walkTypeDecl (td : TD, ctx : CTX, env : ENV) : TN ==
      debug(["Expression" :: PF, td.expr :: PF, "has type" :: PF, td.type :: PF])

      not symbol? td.expr =>
        fail ["Type annotation works only for symbols!" :: PF]
        error ""

      -- Type definition for a symbol.
      s := td.expr :: Symbol
      ts := [t for t in search(s, env) | not typeOrigin? t]

      -- Add type to the environment or crash if already defined,
      -- this behaviour is supressed for mappings that have origin.
      not empty? ts and not member?(td.type, ts) =>
        fail([bold red ("Error!" :: PF), "Symbol" :: PF, string(s :: PF),
              "already defined as" :: PF, bracket [t :: PF for t in ts], "!" :: PF])
        error ""

      env(s) := td.type
      tn := addNode!(ctx, [td], env)
      bindNode!(ctx, tn, typeUndef)
      tn

    walkTypeSelect (ts : TS, ctx : CTX, env : ENV) : TN ==
      debug(["Expression" :: PF, ts.expr :: PF,
             "has to return type" :: PF, ts.type :: PF])

      not apply? ts.expr =>
        fail ["Type cut operator works only for function application!" :: PF]
        error ""

      env := envAddType(ts.type, env)
      this := addNode!(ctx, [ts], env)
      expr := walk(ts.expr, ctx, env)
      setTypeOf!(ctx, this, [ts.type])
      this.rules := [ruleSubType(expr, this)]
      this

    walkTypeCoerce (tc : TC, ctx : CTX, env : ENV) : TN ==
      debug ["Expression" :: PF, tc.expr :: PF, "have to coerce to" :: PF, tc.type :: PF]
      env := envAddType(tc.type, env)

      this := addNode!(ctx, [tc], env)
      setTypeOf!(ctx, this, [tc.type])

      expr := walk(tc.expr, ctx, env)

      rs : List(TR) := []
      if not empty? search('qcoerce, env) then
        qcoerceFun := walk(['qcoerce], ctx, env)
        rs := [ruleCoerce(qcoerceFun, [expr], tc.type), :rs]
      if not empty? search('coerce, env) then
        coerceFun := walk(['coerce], ctx, env)
        rs := [ruleCoerce(coerceFun, [expr], tc.type), :rs]
      this.rules := [ruleSubType(expr, this), :rs]
      this

    walkTypeHas (te : TEH, ctx : CTX, env : ENV) : TN ==
      this := addNode!(ctx, [te], env)
      bindNode!(ctx, this, booleanType)
      this

    walkTypeIs (te : TEI, ctx : CTX, env : ENV) : TN ==
      this := addNode!(ctx, [te], env)
      bindNode!(ctx, this, booleanType)
      this
    
    walkTypeOrigin (to : TO, ctx : CTX, env : ENV) : TN ==
      not symbol? to.expr =>
        fail ("Type origin selector works only for symbols!" :: PF)
        error ""

      debug(["Symbol" :: PF, string(to.expr :: PF),
             "must originate from" :: PF, bold(to.type :: PF),
             "type!" :: PF])

      env := envAddType(to.type, env)
      this := addNode!(ctx, [to], env)

      expr := walk(to.expr, ctx, env)

      this.rules := [ruleTypeOrigin(expr, to.type)]
      this

    walkCase (c : SC, ctx : CTX, env : ENV) : TN ==
      env := envAddType(c.type, env)

      this := addNode!(ctx, [c], env)
      setTypeOf!(ctx, this, [booleanType])
      this

    walkInt (i : Integer, ctx : CTX, env : ENV) : TN ==
      type :=
        i > 0 => nodeApp(['PositiveInteger], []) 
        i >= 0 => nodeApp(['NonNegativeInteger], [])
        nodeApp(['Integer], [])
      this := addNode!(ctx, [i], env)
      bindNode!(ctx, this, type)
      done! this

    walkFlt (f : DoubleFloat, ctx : CTX, env : ENV) : TN ==
      this := addNode!(ctx, [f], env)
      bindNode!(ctx, this, floatType)
      done! this

    walkStr (s : String, ctx : CTX, env : ENV) : TN ==
      debug [string(s :: PF), "is" :: PF, stringType :: PF, ":)" :: PF]
      this := addNode!(ctx, [s], env)
      setTypeOf!(ctx, this, [[string(s :: Symbol)], stringType])
      this

    walkEmpty (e : N, ctx : CTX, env : ENV) : TN ==
      this := addNode!(ctx, e, env)
      bindNode!(ctx, this, typeUndef)
      done! this

    walk (n, ctx, env) ==
      apply? n => walkApp(n :: APP, ctx, env)
      assign? n => walkAssign(n :: ASS, ctx, env)
      case? n => walkCase(n :: SC, ctx, env)
      condExpr? n => walkCondExpr(n :: CE, ctx, env)
      float? n => walkFlt(n :: DoubleFloat, ctx, env)
      functor? n => walkFtor(n :: FT, ctx, env)
      import? n => walkImport(n :: IM, ctx, env)
      integer? n => walkInt(n :: Integer, ctx, env)
      loop? n => walkLoop(n :: LP, ctx, env)
      segment? n => walkSeg(n :: SEG, ctx, env)
      sequence? n => walkSeq(n :: SEQ, ctx, env)
      string? n => walkStr(n :: String, ctx, env)
      symbol? n => walkSym(n :: Symbol, ctx, env)
      typeCoerce? n => walkTypeCoerce(n :: TC, ctx, env)
      typeDecl? n => walkTypeDecl(n :: TD, ctx, env)
      typeHas? n => walkTypeHas(n :: TEH, ctx, env)
      typeIs? n => walkTypeIs(n :: TEI, ctx, env)
      typeOrigin? n => walkTypeOrigin(n :: TO, ctx, env)
      typeSelect? n => walkTypeSelect(n :: TS, ctx, env)
      function? n or lambda? n => walkFun(n :: FN, ctx, env)
      emptyNode? n => walkEmpty(n, ctx, env)
      -- namedType, mappingType, recordType, sumType, unionType, macro, where
      fail ["Expression" :: PF, bold red paren(n :: PF), "not handled yet!" :: PF]
      error ""
