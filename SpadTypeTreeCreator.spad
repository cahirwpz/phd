)abbrev package STRFAC SpadTypeRuleFactory
SpadTypeRuleFactory() : Exports == Implementation where
  N ==> SpadNode
  FN ==> SpadFunction(N)
  FT ==> SpadFunctor(N)
  TR ==> SpadTypeRule
  TN ==> SpadTypeNode
  OTN ==> Union(TN, "none")

  Exports ==> with
    ruleAssign : (TN, TN) -> TR
    ruleApply : (TN, List(TN)) -> TR
    ruleApply : (TN, List(TN), List(TN)) -> TR
    ruleCondExpr : (TN, TN, TN) -> TR
    ruleIfThen : (TN, TN) -> TR
    ruleFun : (FN, List(TN), TN, TN) -> TR
    ruleFunDef : (TN, TN) -> TR
    ruleFtor : (FT, List(TN), TN, TN) -> TR
    ruleLoopIter : (TN, TN, TN) -> TR
    ruleLoop : (Union("loop", "collect", "repeat"), 
                List(TN), List(TN), Union(TN, "none"), TN) -> TR
    ruleRef : (List(TN), TN) -> TR
    ruleTypeIs : (TN, TN) -> TR
    ruleTypeIs : (List(TN), TN, TN) -> TR
    ruleSeg : (TN, OTN, OTN) -> TR
    ruleSeq : (Union("Domain", "Package", "Join", "Capsule", "Sequence",
                     "Tuple", "Body"), TN, List(TN)) -> TR
    ruleCapsule : List(TN) -> TR
    ruleTypeOrigin : (TN, N) -> TR
    ruleSubType : (TN, TN) -> TR
    ruleSubType : (List(TN), TN, TN) -> TR
    ruleSuperType : (TN, TN) -> TR

  Implementation ==> add
    import SpadNodeFactory

    -- for assignment "L := R" do:
    -- compute "L, R"; if "L := R" then solution is "L := R"
    ruleAssign (L', R') ==
      (L, R) := (nodeRef(L'), nodeRef(R'))
      [[L, R, nodeAssign(L, R)], nodeAssign(L, R)]

    ruleApply (fun, args) ==
      (funRef, argRefs) := (nodeRef(fun), [nodeRef(arg) for arg in args])
      [[funRef, :argRefs, nodeApp(funRef, argRefs)],
       nodeApp(funRef, argRefs)]

    ruleApply (fun, args, extras) ==
      (funRef, argRefs) := (nodeRef(fun), [nodeRef(arg) for arg in args])
      extraRefs := [nodeRef(extra) for extra in extras]
      [[:extraRefs, funRef, :argRefs, nodeApp(funRef, argRefs)],
       nodeApp(funRef, argRefs)]

    ruleCondExpr (C', T', F') ==
      (C, T, F) := (nodeRef(C'), nodeRef(T'), nodeRef(F'))
      [[C, T, F, nodeCondExpr(C, T, F)], nodeCondExpr(C, T, F)]

    ruleIfThen (C', T') ==
      (C, T) := (nodeRef(C'), nodeRef(T'))
      [[C, T, nodeCondExpr(C, T, emptyNode)], nodeCondExpr(C, T, emptyNode)]

    -- for function "fn (a1 : A1, ..., an : An) : T == B" do:
    -- compute "A1, ..., An, T, B"; if "T is B" then solution is "fn"
    ruleFun (fn, As', T', B') ==
      (As, T, B) := ([nodeRef(a) for a in As'], nodeRef(T'), nodeRef(B'))
      [[:As, T, B, nodeSubType(B, T)], nodeFun(fn.name, As, T, B)]

    ruleFunDef (S', T') ==
      (S, T) := (nodeRef(S'), nodeRef(T'))
      [[S, nodeTypeIs(S, T)], S]

    -- for functor "ft (a1 : A1, ..., an : An) : T == E add B" do:
    -- compute "A1, ..., An, T, B"; if "B <: T" then solution is "ft"
    ruleFtor (ft, As', T', B') ==
      (As, T, B) := ([nodeRef(a) for a in As'], nodeRef(T'), nodeRef(B'))
      E := (emptyNode? ft.extends => ['Type]; ft.extends)
      [[:As, T, B, nodeSubType(B, T)], nodeFtor(ft.name, ft.args, ft.type, E, B)]

    ruleLoopIter (var, seq, iter) == 
      (varRef, seqRef, iterRef) := (nodeRef(var), nodeRef(seq), nodeRef(iter))
      [[varRef, seqRef], nodeIterator(var.node :: Symbol, seqRef)]

    ruleLoop (kind, itors, guards, bodyType, body) ==
      itorRefs := [nodeRef(itor) for itor in itors]
      guardRefs := [nodeRef(guard) for guard in guards]
      bodyRef := nodeRef(body)
      formulas :=
        bodyType case TN =>
          [:itorRefs, :guardRefs, nodeRef(bodyType), bodyRef]
        [:itorRefs, :guardRefs, bodyRef]
      [formulas, nodeLoop(kind, itorRefs, guardRefs, bodyRef)]

    ruleRef (deps, body) ==
      depRefs := [nodeRef(dep) for dep in deps]
      bodyRef := nodeRef(body)
      [[:depRefs, bodyRef], bodyRef]

    ruleSeg (start, end, step) ==
      startRef := nodeRef(start)
      formulas := [startRef]$List(N)
      if end case TN then
        endRef := nodeRef(end)
        concat!(formulas, endRef)
      else
        endRef := emptyNode()
      if step case TN then
        stepRef := nodeRef(step)
        concat!(formulas, stepRef)
      else
        stepRef := emptyNode()
      [formulas, nodeSeg(startRef, endRef, stepRef)]

    ruleSeq (kind, seq, exprs) ==
      (seqRef, exprRefs) := (nodeRef(seq), [nodeRef(expr) for expr in exprs])
      [[:exprRefs, nodeTypeIs(seqRef, last exprRefs)], nodeSeq(kind, exprRefs)]

    ruleCapsule exprList ==
      exprRefList := [nodeRef(expr) for expr in exprList | not done? expr]
      [[:exprRefList, nodeSeq("Capsule", exprRefList)], nodeSeq("Capsule", exprRefList)]

    ruleTypeOrigin (expr, origin) ==
      exprRef := nodeRef(expr)
      [[exprRef, nodeTypeOrigin(exprRef, origin)],
       nodeTypeOrigin(exprRef, origin)]

    ruleSuperType (superType, type) ==
      (superTypeRef, typeRef) := (nodeRef(superType), nodeRef(type))
      [[typeRef, nodeSubType(superTypeRef, typeRef)], nodeRef(type)]

    -- compute "S"; if "S is T" then solution is "S"
    ruleTypeIs (S', T') ==
      ruleTypeIs ([], S', T')

    -- compute "P1, ..., Pn, S"; if "S is T" then solution is "S"
    ruleTypeIs (Ps', S', T') ==
      (Ps, S, T) := ([nodeRef(p) for p in Ps'], nodeRef(S'), nodeRef(T'))
      [[:Ps, S, nodeTypeIs(S, T)], S]

    -- compute "S"; if "S <: T" then solution is "S"
    ruleSubType (S', T') ==
      ruleSubType ([], S', T')

    -- compute "P1, ..., Pn, S"; if "S <: T" then solution is "S"
    ruleSubType (Ps', S', T') ==
      (Ps, S, T) := ([nodeRef(p) for p in Ps'], nodeRef(S'), nodeRef(T'))
      [[:Ps, S, nodeSubType(S, T)], S]

)abbrev package STTCREAT SpadTypeTreeCreator
SpadTypeTreeCreator() : Exports == Implementation where
  PF ==> PrintableForm

  N ==> SpadNode
  APP ==> SpadApply(N)
  ASS ==> SpadAssign(N)
  CE ==> SpadCondExpr(N)
  FN ==> SpadFunction(N)
  FT ==> SpadFunctor(N)
  IM ==> SpadImport(N)
  IT ==> SpadIterator(N)
  LAM ==> SpadLambda(N)
  LP ==> SpadLoop(N)
  MT ==> SpadMappingType(N)
  NR ==> SpadNodeRef(N)
  RT ==> SpadRecordType(N)
  SC ==> SpadCase(N)
  SEG ==> SpadSegment(N)
  SEQ ==> SpadSequence(N)
  SM ==> SpadMacro(N)
  TC ==> SpadTypeCoerce(N)
  TD ==> SpadTypeDecl(N)
  TG ==> SpadTypeGuard(N)
  TO ==> SpadTypeOrigin(N)
  TI ==> SpadTypeInfo(N)
  TS ==> SpadTypeSelect(N)
  TV ==> SpadTypeVar(N)
  UT ==> SpadUnionType(N)
  SW ==> SpadWhere(N)

  SUBS ==> AssociationList(TV, List(N))

  ENV ==> SpadEnvironment
  TN ==> SpadTypeNode
  TR ==> SpadTypeRule
  CTX ==> SpadTypeTree

  Exports ==> with
    walk : (N, CTX, ENV) -> TN

  Implementation ==> add
    import SpadNode
    import SpadNodeFactory
    import SpadDatabase
    import SpadEnvironment
    import SpadTypeEvaluator
    import SpadTypeRuleFactory
    import SpadTypeNodeArray
    import TypeUnifier
    import Printer
    import Logger('Create)

    envAddType (t : N, env : ENV) : ENV ==
      apply? t =>
        app := t :: APP
        env := addDomain(app, env)
        for k in app.args repeat
          env := envAddType(k, env)
        env

      mappingType? t =>
        mt := t :: MT
        for k in [mt.result, :mt.args] repeat
          env := envAddType(k, env)
        env

      recordType? t =>
        rt := t :: RT
        for f in fields rt repeat
          env := envAddType(f.type, env)
        for f in makeRecordFunList t repeat
          env(f.expr :: Symbol) := nodeTypeOrigin(f.type, t)
        env

      unionType? t =>
        ut := t :: UT
        for v in variants ut repeat
          env := envAddType(v, env)
        for f in makeUnionFunList t repeat
          env(f.expr :: Symbol) := nodeTypeOrigin(f.type, t)
        env

      symbol? t => env -- BUG! this is not correct but will do for time being
      string? t => env

      fail ["Type" :: PF, bold(t :: PF), "not handled!" :: PF]
      error "envAddType"

    walkApp (a : APP, ctx : CTX, env : ENV) : TN ==
      -- rewrite QUOTE(symbol) to value 'symbol
      a.function = ['QUOTE] and #a.args = 1 =>
        this := addNode!(ctx, first a.args, env)
        setTypeOf!(ctx, this, [symbolType])
        this

      debug ["Processing function application." :: PF]

      this := addNode!(ctx, [a], env)

      -- First case: just a function call.
      funExpr := walk(a.function, ctx, env)
      argExprList := [walk(arg, ctx, env) for arg in a.args]

      -- Second case: element indexing or record field access.
      eltFunList : List(N) := []
      eltFunTypeList : List(MT) := []
      if a.function ~= ['elt] and a.function ~= ['return] then
        for n in search('elt, env) | typeOrigin? n repeat
          eltFunType := (n :: TO).expr :: MT
          if #eltFunType.args = #a.args + 1 then
            eltFunList := [n, :eltFunList]
            eltFunTypeList := [eltFunType, :eltFunTypeList]

      if not empty? eltFunList then
        argExprList' := [funExpr, :argExprList]
        eltFunExpr := addNode!(ctx, ['elt], env)
        eltFunExpr.node := nodeTypeOrigin(eltFunExpr.node, typeRef(eltFunExpr))
        setTypeOf!(ctx, eltFunExpr, eltFunList)
        this.rules := [ruleApply(eltFunExpr, argExprList'), :this.rules]

      -- Add origin to function expression.
      if not(funExpr.node = ['return] or funExpr.node = ['error]) then
        funExpr.node := nodeTypeOrigin(funExpr.node, typeRef(funExpr))

      -- First case with a twist: arbitrary list construction.
      if a.function = ['construct] then
        item := addNode!(ctx, ['construct], env)
        setTypeOf!(ctx, item, [argExpr.type for argExpr in argExprList])
        constructArgs := [item.type for i in 1..#a.args]
        constructRes := nodeApp(['List], [item.type])
        extendTypeOf!(ctx, funExpr, [nodeMappingType(constructArgs, constructRes)])
        this.rules := [ruleApply(funExpr, argExprList, [item]), :this.rules]

      this.rules := [ruleApply(funExpr, argExprList), :this.rules]
      this

    walkAssign (a : ASS, ctx : CTX, env : ENV) : TN ==
      apply? a.lval =>
        app := a.lval :: APP
        this := walk(nodeApp(['setelt!], [app.function, :app.args, a.rval]), ctx, env)
        this.node := [a]
        this

      this := addNode!(ctx, [a])

      introduced? := false
      if symbol? a.lval then
        s := a.lval :: Symbol
        if empty? search(s, env) then
          debug ["Processing fresh assignment" :: PF, string(s :: PF)]
          env(s) := this.type
          introduced? := true

      left := walk(a.lval, ctx, env)
      -- we know the type of left-value while checking right-value (!?)
      right := walk(a.rval, ctx, env)

      if introduced? then
        left.node := nodeTypeDecl(left.node, typeRef(left))

      -- Only left-value environment is propagated!
      this.env := left.env
      this.rules := [ruleAssign(left, right)]
      this

    walkCondExpr (ce : CE, ctx : CTX, env : ENV) : TN ==
      debug ["Processing conditional expression." :: PF]
      this := addNode!(ctx, [ce])

      cond := walk(ce.cond, ctx, env)
      truebr := walk(ce.truebr, ctx, cond.env)

      emptyNode? ce.falsebr =>
        this.env := env
        this.rules := [ruleIfThen(cond, truebr)]
        this

      falsebr := walk(ce.falsebr, ctx, (case? ce.cond => env; cond.env))

      -- TODO: "truebr.env" and "falsebr.env" should be merged and passed
      -- forward instead of just "env". Merging means that if the same variable
      -- was introduced in both branches then it should be present in the final
      -- environment.
      --
      -- Q: What if a variable "x : T" is defined only in one branch?
      -- A: In merged envrionment introduce "x" with type Union(T, "undefined"),
      --    and emit a warning when subtyping rule is applied.
      this.env := env
      this.rules := [ruleCondExpr(cond, truebr, falsebr)]
      this

    walkFun (fn : FN, ctx : CTX, env : ENV) : TN ==
      funName := (fn.name case "lambda" => '_+_-_>; fn.name :: Symbol)

      if fn.name case "lambda" then
        debug ("Processing lambda expression." :: PF)
      else
        debug ["Processing function" :: PF, string(funName :: PF)]

      funDeclNode := addNode!(ctx, [fn], env)
      addSubTree!(ctx)
      env' := createScope env

      -- It's vitally important that result type is represented by "%2" type
      -- variable (e.g. 'return' refers to "%2").
      funDefNode := addNode!(ctx, [funName], env')
      resNode := addNode!(ctx, emptyNode(), env')
      argNodeList := [addNode!(ctx, emptyNode(), env') for n in fn.args]

      resNode.node := resNode.type
      for argNode in argNodeList for n in fn.args repeat
        argNode.node := nodeTypeDecl((n :: TD).expr, argNode.type)

      -- Take the type of function and replace those components, that were not
      -- specified, with type variables.
      fnType : MT := signature fn

      for argNode in argNodeList for argType in fnType.args repeat
        if not unbound? argType then
          setTypeOf!(ctx, argNode, [argType])

      if not unbound? fnType.result then
        setTypeOf!(ctx, resNode, [fnType.result])

      typeList : List(N) :=
        ([(emptyNode?(t) => n.type; t)
          for n in [resNode, :argNodeList] for t in [fnType.result, :fnType.args]])

      fnType' := nodeMappingType(rest typeList, first typeList)
      setTypeOf!(ctx, funDefNode, [fnType'])

      if fn.name case "lambda" then
        debug(["Lambda expression has" :: PF, bold(fnType' :: PF),
               "type based on definition." :: PF])
      else
        debug(["Function" :: PF, string(bold (funName :: PF)), "has" :: PF,
               bold(fnType' :: PF), "type based on definition." :: PF])

      -- Fetch signatures from the environment, including those defined by
      -- the domain / package / function. Filter out those that don't match
      -- the type calculated above.
      candidateList : List(MT) := []

      if fn.name case Symbol then
        for n in search(fn.name :: Symbol, env') repeat
          candidate := emptyNode()

          if typeOrigin? n then
            to := n :: TO
            if to.type = ["$" :: Symbol] and mappingType? to.expr then
              candidate := to.expr
          if mappingType? n then
            candidate := n

          if not emptyNode? candidate then
            ures := unifyType(fnType', candidate)
            ures case "failed" => "iterate"
            candidate := substitute(fnType', ures :: SUBS)
            candidateList := [candidate :: MT, :candidateList]

      for c in candidateList repeat 
        for type in c.args | not unbound? type repeat
          env' := envAddType(type, env')
        if not unbound? c.result then
          env' := envAddType(c.result, env')

      -- TODO: Filter out function which have been already defined.
      if not empty? candidateList then
        info(["Environment contains" :: PF, string bold(funName :: PF),
              "from" :: PF, bold("$" :: PF), "with matching signatures:" :: PF,
              bold bracket [c :: PF for c in candidateList]])

        extendTypeOf!(ctx, funDeclNode, [[c] for c in candidateList])
        extendTypeOf!(ctx, resNode, [c.result for c in candidateList])
        for argNode in argNodeList for i in 1.. repeat
          extendTypeOf!(ctx, argNode, [c.args.i for c in candidateList])
      else
        info(["Considering" :: PF, string bold(funName :: PF),
              "of type" :: PF, bold(fnType :: PF),
              "to be a local function!" :: PF])

      for n in fn.args for argNode in argNodeList repeat
        arg := n :: TD
        env'(arg.expr :: Symbol) := argNode.type

      bodyNode := walk(fn.body, ctx, env')

      leaveSubTree!(ctx)

      funDeclNode.rules := [ruleFunDef(funDefNode, funDeclNode)]
      funDefNode.rules := [ruleFun(fn, argNodeList, resNode, bodyNode)]

      return funDeclNode

    walkFtor (ft : FT, ctx : CTX, env : ENV) : TN ==
      sig := signature ft
      -- sig is unchecked and may contain invalid types
      ftorApp := nodeApp([ft.name], [[td] for td in ft.args])

      debug pile([spaces ["Processing functor" :: PF, bold(ftorApp :: PF), "with:" :: PF],
                  ft.type :: PF])

      addSubTree!(ctx)

      this := addNode!(ctx, [ft.name], env)

      resNode := addNode!(ctx, ft.type, env)
      -- FIXME: Functor's return type is not of "Join" node!
      resType := (sequence? ft.type => nodeSeq("Join", (ft.type :: SEQ).list); ft.type)
      setTypeOf!(ctx, resNode, [resType])
      resType := resNode.type

      argSub := [[]]$Table(Symbol, N)
      argNodeList : List(TN) := []

      -- process functor's arguments
      for arg in ft.args repeat
        name := arg.expr :: Symbol
        argNode := addNode!(ctx, arg.expr, env)
        setTypeOf!(ctx, argNode, [arg.type])
        env(name) := argNode.type
        env := addDomainAs(arg.type :: APP, name, env)
        argSub(name) := argNode.type
        argNodeList := [argNode, :argNodeList]

      argNodeList := reverse argNodeList
      argList := [argNode.node for argNode in argNodeList]
      env("$" :: Symbol) := nodeApp([ft.name], argList)
      setTypeOf!(ctx, this, [nodeMappingType(argList, resType)])

      -- process functor's body
      for n in (ft.type :: SEQ).list | typeDecl? n repeat
        td := n :: TD
        env(td.expr :: Symbol) := nodeTypeOrigin(td.type, ["$" :: Symbol])

      bodyNode := walk(ft.capsule, ctx, env)

      leaveSubTree!(ctx)

      this.rules := [ruleFtor(ft, argNodeList, resNode, bodyNode)]
      this

    walkImport (im : IM, ctx : CTX, env : ENV) : TN ==
      debug ["Importing" :: PF, im.type :: PF]
      env := envAddType(im.type, env)
      tn := addNode!(ctx, [im], env)
      bindNode!(ctx, tn, typeUndef)
      done! tn

    walkLoop (lp : LP, ctx : CTX, env : ENV) : TN ==
      debug ["Loop statement." :: PF]

      this := addNode!(ctx, [lp], env)
      env' := env

      debug ["Processing" :: PF, #(lp.itors) :: PF, "iterator(s)." :: PF]
      itorList : List(TN) := []
      for n in lp.itors repeat
        itor := n :: IT

        itorExpr := addNode!(ctx, n, env)
        varExpr := addNode!(ctx, [itor.var], env)
        seqType := addNode!(ctx, emptyNode(), env)
        seqExpr := walk(itor.seq, ctx, env)

        setTypeOf!(ctx, seqType,
            [nodeApp(['List], [varExpr.type]),
             nodeApp(['UniversalSegment], [varExpr.type])])
        seqType.rules := [ruleTypeIs(seqExpr, seqType), ruleSubType(seqExpr, seqType)]

        -- Iterator variable is added to loop's body environment,
        -- but is also known to guards.
        env'(itor.var) := varExpr.type

        bindNode!(ctx, itorExpr, typeUndef)

        itorExpr.rules := [ruleLoopIter(varExpr, seqType, itorExpr)]
        itorList := [itorExpr, :itorList]

      debug ["Processing" :: PF, #(lp.guards) :: PF, "guard(s)." :: PF]
      guardList : List(TN) := []
      for guard in lp.guards repeat
        guardExpr := walk(guard, ctx, env')
        bindNode!(ctx, guardExpr, booleanType)
        guardList := [guardExpr, :guardList]

      debug ["Processing loop body." :: PF]
      maybeBodyType : Union(TN, "none") := "none"
      body : TN
      if lp.kind case "collect" then
        bodyType := addNode!(ctx, emptyNode, env)
        body := walk(lp.body, ctx, env')
        bodyType.node := bodyType.type
        bodyType.rules := [ruleSubType(body, bodyType)]
        setTypeOf!(ctx, body, [bodyType.type])
        setTypeOf!(ctx, this, [nodeApp(['List], [bodyType.type])])
        maybeBodyType := bodyType
      else
        body := walk(lp.body, ctx, env')
        bindNode!(ctx, body, typeAny)
        bindNode!(ctx, this, typeUndef)

      this.rules := 
        [ruleLoop(lp.kind, itorList, guardList, maybeBodyType, body)]
      this

    walkSeg (seg : SEG, ctx : CTX, env : ENV) : TN ==
      debug ["Processing segment:" :: PF, string(seg :: PF)]
      this := addNode!(ctx, [seg], env)

      startExpr := walk(seg.start, ctx, env)

      endExpr' : Union(TN, "none") :=
        not emptyNode? seg.end =>
          endExpr := walk(seg.end, ctx, env)
          setTypeOf!(ctx, endExpr, [startExpr.type])
          endExpr
        "none"

      stepExpr' : Union(TN, "none") :=
        not emptyNode? seg.step =>
          stepExpr := walk(seg.step, ctx, env)
          setTypeOf!(ctx, stepExpr, [integerType])
          stepExpr
        "none"

      setTypeOf!(ctx, this, [nodeApp(['UniversalSegment], [startExpr.type])])
      this.rules := [ruleSeg(startExpr, endExpr', stepExpr')]
      this

    walkSeq (s : SEQ, ctx : CTX, env : ENV) : TN ==
      import List(TN)

      debug ["Found sequence of" :: PF, #(s.list) :: PF, "expressions." :: PF]
      this := addNode!(ctx, [s])

      exprList : List(TN) := [(n := walk(e, ctx, env); env := n.env; n) for e in s.list]

      this.rules := 
        s.kind = "Capsule" => [ruleCapsule(exprList)]
        [ruleSeq(s.kind, this, exprList)]
      this.env := (last exprList).env
      this

    walkSym (s : Symbol, ctx : CTX, env : ENV) : TN ==
      debug ["Symbol lookup for" :: PF, string(s :: PF)]

      this := addNode!(ctx, [s], env)

      types := search(s, env)

      -- Convert "constant -> T" into "T"
      for t in types repeat
        t := stripOriginIfCan t
        if mappingType? t and (t :: MT).args = [['constant]] then
          types := [(t :: MT).result, :types]

      -- BUG: parseTran uses true and false as "Boolean" and not as "() -> Boolean"
      -- workaround for Boolean constants
      if s = 'true or s = 'false then
        types := [booleanType, :types]
      if s = '_$NoValue then
        types := [voidType, :types]
      if s = 'leave then
        leaveType := nodeMappingType([integerType, voidType], typeUndef) 
        types := [leaveType, :types]
      if s = 'error then
        errorType := nodeMappingType([stringType], typeAny)
        types := [errorType, :types]
      if s = 'return then
        resType := node(ctx, 2).type
        returnType := nodeMappingType([integerType, resType], typeUndef)
        types := [returnType, :types]

      -- handle a symbol which is a type constructor
      if inDatabase? s then
        ti := getTypeInfo([[s], [emptyNode()]]$APP)

        ftorArgList : List(N) := []
        ftorArgNodeList : List(TN) := []
        ftorArgRenames : SUBS := empty()

        for arg in ti.args repeat
          ftorArg := arg.expr
          ftorArgType := arg.type

          if typeVar? ftorArg then
            origFtorArg := ftorArg
            ftorArgType := substitute(ftorArgType, ftorArgRenames)

            ftorArgTypeNode := addNode!(ctx, ftorArgType, env)
            setTypeOf!(ctx, ftorArgTypeNode, [ftorArgType])

            ftorArgNode := addNode!(ctx, ftorArg, env)
            ftorArg := ftorArgNode.type
            ftorArgRenames(origFtorArg :: TV) := [ftorArg]
            ftorArgNodeList := [ftorArgNode, :ftorArgNodeList]
            ftorArgNode.rules := [ruleSuperType(ftorArgNode, ftorArgTypeNode)]

          ftorArgList := [ftorArg, :ftorArgList]

        ftorResType := nodeApp(['Type], [])
        ftorType := nodeMappingType(reverse ftorArgList, ftorResType)
        env(s) := ftorType
        types := [ftorType, :types]

        if not empty? ftorArgNodeList then
          this.rules := [[[nodeRef(n) for n in ftorArgNodeList], [s]]]

      empty? types =>
        fail ["Undefined symbol:" :: PF, bold red string (s :: PF), "!" :: PF]
        debug (env :: PF)
        error ""
      
      info(["Found" :: PF, string bold(s :: PF), "with type :" :: PF,
            bold bracket [t :: PF for t in types]])
      setTypeOf!(ctx, this, types)
      this 

    walkTypeDecl (td : TD, ctx : CTX, env : ENV) : TN ==
      debug(["Expression" :: PF, td.expr :: PF, "has type" :: PF, td.type :: PF])

      not symbol? td.expr =>
        fail ["Type annotation works only for symbols!" :: PF]
        error ""

      -- Type definition for a symbol.
      s := td.expr :: Symbol
      ts := search(s, env)

      -- Add it to the environment or crash if already defined, unless it's
      -- another function declaration (i.e. allow function type overloading).
      if not mappingType? td.type then
        (not empty? ts) and (first ts ~= td.type) =>
          fail([bold red ("Error!" :: PF), "Symbol" :: PF, string(s :: PF),
                "already defined as" :: PF, bracket [t :: PF for t in ts], "!" :: PF])
          error ""

      env(s) := td.type
      tn := addNode!(ctx, [td], env)
      setTypeOf!(ctx, tn, [td.type])
      tn

    walkTypeSelect (ts : TS, ctx : CTX, env : ENV) : TN ==
      debug(["Expression" :: PF, ts.expr :: PF,
             "has to return type" :: PF, ts.type :: PF])

      not apply? ts.expr =>
        fail ["Type cut operator works only for function application!" :: PF]
        error ""

      env := envAddType(ts.type, env)
      this := addNode!(ctx, [ts], env)
      expr := walk(ts.expr, ctx, env)
      setTypeOf!(ctx, this, [ts.type])
      this.rules := [ruleSubType(expr, this)]
      this

    walkTypeCoerce (tc : TC, ctx : CTX, env : ENV) : TN ==
      debug ["Expression" :: PF, tc.expr :: PF, "have to coerce to" :: PF, tc.type :: PF]
      env := envAddType(tc.type, env)

      this := addNode!(ctx, [tc], env)
      setTypeOf!(ctx, this, [tc.type])

      expr := walk(tc.expr, ctx, env)
      coerceFun := walk(['coerce], ctx, env)
      this.rules := [ruleSubType(expr, this), ruleApply(coerceFun, [expr])]
      this
    
    walkTypeOrigin (to : TO, ctx : CTX, env : ENV) : TN ==
      not symbol? to.expr =>
        fail ("Type origin selector works only for symbols!" :: PF)
        error ""

      debug(["Symbol" :: PF, string(to.expr :: PF),
             "must originate from" :: PF, bold(to.type :: PF),
             "type!" :: PF])

      env := envAddType(to.type, env)
      this := addNode!(ctx, [to], env)

      expr := walk(to.expr, ctx, env)

      this.rules := [ruleTypeOrigin(expr, to.type)]
      this

    walkCase (c : SC, ctx : CTX, env : ENV) : TN ==
      env := envAddType(c.type, env)

      this := addNode!(ctx, [c], env)
      setTypeOf!(ctx, this, [booleanType])

      if symbol? c.expr then
        this.env := (env(c.expr :: Symbol) := c.type)

      exprType := addNode!(ctx, c.type, env)
      setTypeOf!(ctx, exprType, [c.type])

      expr := walk(c.expr, ctx, env)
      exprType.rules := [ruleSuperType(exprType, expr)]

      this.rules := [[[nodeRef(exprType)], [c]]]
      this

    walkInt (i : Integer, ctx : CTX, env : ENV) : TN ==
      type :=
        i > 0 => nodeApp(['PositiveInteger], []) 
        i >= 0 => nodeApp(['NonNegativeInteger], [])
        nodeApp(['Integer], [])
      this := addNode!(ctx, [i], env)
      bindNode!(ctx, this, type)
      done! this

    walkFlt (f : DoubleFloat, ctx : CTX, env : ENV) : TN ==
      this := addNode!(ctx, [f], env)
      bindNode!(ctx, this, floatType)
      done! this

    walkStr (s : String, ctx : CTX, env : ENV) : TN ==
      debug [string(s :: PF), "is" :: PF, stringType :: PF, ":)" :: PF]
      this := addNode!(ctx, [s], env)
      setTypeOf!(ctx, this, [[string(s :: Symbol)], stringType])
      this

    walkEmpty (e : N, ctx : CTX, env : ENV) : TN ==
      this := addNode!(ctx, e, env)
      bindNode!(ctx, this, typeUndef)
      done! this

    walk (n, ctx, env) ==
      apply? n => walkApp(n :: APP, ctx, env)
      assign? n => walkAssign(n :: ASS, ctx, env)
      case? n => walkCase(n :: SC, ctx, env)
      condExpr? n => walkCondExpr(n :: CE, ctx, env)
      float? n => walkFlt(n :: DoubleFloat, ctx, env)
      functor? n => walkFtor(n :: FT, ctx, env)
      import? n => walkImport(n :: IM, ctx, env)
      integer? n => walkInt(n :: Integer, ctx, env)
      loop? n => walkLoop(n :: LP, ctx, env)
      segment? n => walkSeg(n :: SEG, ctx, env)
      sequence? n => walkSeq(n :: SEQ, ctx, env)
      string? n => walkStr(n :: String, ctx, env)
      symbol? n => walkSym(n :: Symbol, ctx, env)
      typeCoerce? n => walkTypeCoerce(n :: TC, ctx, env)
      typeDecl? n => walkTypeDecl(n :: TD, ctx, env)
      typeOrigin? n => walkTypeOrigin(n :: TO, ctx, env)
      typeSelect? n => walkTypeSelect(n :: TS, ctx, env)
      function? n or lambda? n => walkFun(n :: FN, ctx, env)
      emptyNode? n => walkEmpty(n, ctx, env)
      -- namedType, mappingType, recordType, sumType, unionType, macro, where
      fail ["Expression" :: PF, bold red paren(n :: PF), "not handled yet!" :: PF]
      error ""
