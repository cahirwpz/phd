)abbrev package SPNFACT SpadNodeFactory
SpadNodeFactory() : Exports == Implementation where
  NNI ==> NonNegativeInteger
  N ==> SpadNode
  APP ==> SpadApply(N)
  MR ==> SpadMarker(N)

  Exports ==> with
    booleanType : () -> N
    integerType : () -> N
    floatType : () -> N
    stringType : () -> N
    voidType : () -> N
    nodeRef : NNI -> N
    typeVar : NNI -> N

  Implementation ==> add
    booleanType () == [[['Boolean], []]$APP]
    integerType () == [[['Integer], []]$APP]
    floatType () == [[['DoubleFloat], []]$APP]
    stringType () == [[['String], []]$APP]
    voidType () == [[['Void], []]$APP]
    nodeRef(i) == [[i, 'noderef]$MR]
    typeVar(i) == [[i, 'typevar]$MR]

)abbrev package OFEXT OutputFormExt
OutputFormExt() : Exports == Implementation where
  OF ==> OutputForm
  N ==> SpadNode

  Exports ==> with
    number : Integer -> Symbol
    funsig : (Symbol, Integer) -> Symbol
    spaces : List(OF) -> OF
    print : List(OF) -> Void

  Implementation ==> add
    import String
    import OutputForm

    number i ==
      coerce concat ["#", string i]

    funsig (name, args) ==
      coerce concat [string name, "/", string args]

    spaces lst ==
      lst' := [first lst]
      for e in rest lst repeat
        lst' := [e, " ", :lst']
      hconcat reverse lst'

    print (lst : List(OF)) : Void ==
      print spaces lst

)abbrev package TUNIFY TypeUnifier
TypeUnifier() : Exports == Implementation where
  OF ==> OutputForm
  N ==> SpadNode
  APP ==> SpadApply(N)
  MT ==> SpadMappingType(N)
  MR ==> SpadMarker(N)
  SUBST ==> AssociationList(MR, List(N))
  P ==> Record(t1 : N, t2 : N)
  URES ==> Union(SUBST, "failed")

  Exports ==> with
    failed? : URES -> Boolean 

    occurs? : (MR, N) -> Boolean
    unbound? : N -> Boolean

    substitute : (N, MR, N) -> N
    substitute : (N, SUBST) -> N

    unifyType : (N, N) -> URES
    unifyTypeList : List(P) -> URES

    matches? : (N, List(N)) -> Boolean
    findMatches : (List(N), List(N)) -> Record(terms : List(N), subst : SUBST)

  Implementation ==> add
    import SpadNode
    import OutputFormExt

    failed? t == t case "failed"

    occurs? (tvar, n) ==
      import List(N)

      apply? n =>
        app := n :: APP
        any?(m +-> occurs?(tvar, m), [app.function, :app.args])
      mappingType? n =>
        mt := n :: MT
        any?(m +-> occurs?(tvar, m), [mt.type, :mt.args])
      typeVar? n =>
        (n :: MR) = tvar
      false

    unbound? n ==
      import List(N)

      apply? n =>
        app := n :: APP
        any?(unbound?, [app.function, :app.args])
      mappingType? n =>
        mt := n :: MT
        any?(unbound?, [mt.type, :mt.args])
      typeVar? n or emptyNode? n =>
        true
      false

    substitute(n : N, var : MR, term : N) : N ==
      apply? n =>
        app := n :: APP
        lst := [substitute(k, var, term) for k in [app.function, :app.args]]
        [[first lst, rest lst]$APP]
      mappingType? n =>
        mt := n :: MT
        lst := [substitute(k, var, term) for k in [mt.type, :mt.args]]
        [[rest lst, first lst]$MT]
      typeVar? n and (n :: MR) = var =>
        term 
      n

    substitute(n : N, subst : SUBST) : N ==
      for s in entries subst repeat
        var := s.key
        for term in s.entry repeat
          n := substitute(n, var, term)
      n

    mergeSubstitutions : List(SUBST) -> SUBST
    mergeSubstitutions substitutionsList ==
      merged := [[]]
      -- merge list for each valid substitution
      for substitutions in substitutionsList repeat
        for s in entries substitutions repeat
          merged(s.key) := 
            key?(s.key, merged) =>
              concat(s.entry, merged(s.key))
            s.entry
      -- remove duplicates from term lists
      for s in entries merged repeat
        merged(s.key) := removeDuplicates s.entry
      merged

    unifyType(n1 : N, n2 : N) : URES ==
      -- print [hspace 2, brace(n1 :: OF), "~", brace(n2 :: OF)]

      -- left or right node is a type variable => just generate a substitution
      typeVar? n1 and typeVar? n2 =>
        mr1 := n1 :: MR
        mr2 := n2 :: MR
        mr1 = mr2 => [[]]
        -- always substitute newer variable with older one to avoid (?) cycles
        if mr1.id > mr2.id
          then [[[mr1, [n2]]]]
          else [[[mr2, [n1]]]]
      typeVar? n1 =>
        occurs? (n1 :: MR, n2) => "failed"
        [[[n1 :: MR, [n2]]]]
      typeVar? n2 =>
        occurs? (n2 :: MR, n1) => "failed"
        [[[n2 :: MR, [n1]]]]

      -- both nodes can be represented as lists of terms and variables
      -- so convert them to a pair of lists and perform unification
      mappingType? n1 and mappingType? n2 =>
        mt1 := n1 :: MT
        mt2 := n2 :: MT
        #(mt1.args) ~= #(mt2.args) => "failed"
        pairs : List(P) :=
          [[t1, t2] for t1 in [mt1.type, :mt1.args] for t2 in [mt2.type, :mt2.args]]
        unifyTypeList pairs
      apply? n1 and apply? n2 =>
        app1 := n1 :: APP
        app2 := n2 :: APP
        #(app1.args) ~= #(app2.args) => "failed"
        pairs : List(P) :=
          [[t1, t2] for t1 in [app1.function, :app2.args] for t2 in [app2.function, :app2.args]]
        unifyTypeList pairs

      -- constants
      symbol? n1 and symbol? n2 and (n1 :: Symbol) = (n2 :: Symbol) => [[]]
      integer? n1 and integer? n2 and (n1 :: Integer) = (n2 :: Integer) => [[]]
      string? n1 and string? n2 and (n1 :: String) = (n2 :: String) => [[]]

      "failed"

    unifyTypeList(pairs : List(P)) : URES ==
      subst : SUBST := [[]]
      while not empty? pairs repeat
        pair := first pairs
        ures := unifyType(pair.t1, pair.t2)
        failed? ures => return "failed"
        subst := concat (subst, ures :: SUBST)
        pairs := [[substitute(pair.t1, subst), substitute(pair.t2, subst)]$P for pair in rest pairs]
      subst

    matches?(term : N, terms : List(N)) : Boolean ==
      any?(t +-> not failed? unifyType(t, term) or term = t, terms)

    findMatches(terms1, terms2) ==
      terms : List(N) := []
      subst : List(SUBST) := []
      for t1 in terms1 repeat
        for t2 in terms2 repeat
          ures := unifyType(t1, t2)
          failed? ures => "iterate"
          terms := [substitute(t1, ures :: SUBST), :terms]
          subst := [ures :: SUBST, :subst]
      [removeDuplicates terms, mergeSubstitutions subst]

)abbrev domain TCNODE TCNode
TCNode() : Exports == Implementation where
  OF ==> OutputForm
  NNI ==> NonNegativeInteger
  ENV ==> SpadEnvironment
  N ==> SpadNode
  MR ==> SpadMarker(N)
  SUBST ==> AssociationList(MR, List(N))

  Exports ==> CoercibleTo(OutputForm) with
    elt : (%, "index") -> NNI
    elt : (%, "node") -> N
    elt : (%, "children") -> List(%)
    elt : (%, "rule") -> N
    elt : (%, "type") -> N
    setelt! : (%, "index", NNI) -> NNI
    setelt! : (%, "children", List(%)) -> List(%)
    setelt! : (%, "rule", N) -> N
    setelt! : (%, "type", N) -> N

    construct : (NNI, N, N) -> %
    substitute! : (SUBST, %) -> Void
    checkAndMarkIfDone! : % -> Void
    done? : % -> Boolean

  Implementation ==> add
    Rep := Record(ni_index : NNI,
                  ni_node : N,
                  ni_children : List(%),
                  ni_rule : N,
                  ni_type : N,
                  ni_done : Boolean)

    import SpadNode
    import OutputFormExt
    import TypeUnifier

    elt (x, "index") == x.ni_index
    elt (x, "node") == x.ni_node
    elt (x, "children") == x.ni_children
    elt (x, "rule") == x.ni_rule
    elt (x, "type") == x.ni_type

    setelt! (x, "index", i) ==
      x.ni_index := i
    setelt! (x, "children", cl) ==
      x.ni_children := cl
    setelt! (x, "rule", r) ==
      x.ni_rule := r
    setelt! (x, "type", ts) ==
      x.ni_type := ts

    construct (i, n, t) ==
      [i, n, [], emptyNode(), t, false] $ Rep

    substitute! (subst, x) ==
      x.type := substitute(x.type, subst)

    checkAndMarkIfDone! x ==
      import List(N)
      unbound? x.type => false
      x.ni_done := every?(t +-> not unbound? t, [n.type for n in x.children])

    done? x == x.ni_done

    coerce x ==
      p := hconcat([paren(if done? x then "+" :: OF else "-" :: OF),
                    right(number(x.index) :: OF, 4)])
      emptyNode? x.rule =>
        hconcat [p, " is ", x.type :: OF]
      hconcat [p, " <- {", x.rule :: OF, "} is ", x.type :: OF]

)abbrev package TCNA TCNodeArray
TCNodeArray() : Exports == Implementation where
  NNI ==> NonNegativeInteger
  TCN ==> TCNode
  OF ==> OutputForm
  N ==> SpadNode
  APP ==> SpadApply(N)
  ASS ==> SpadAssign(N)
  CN ==> SpadConditional(N)
  ENV ==> SpadEnvironment
  MT ==> SpadMappingType(N)
  MR ==> SpadMarker(N)
  SUBST ==> AssociationList(MR, List(N))
  URES ==> Union(SUBST, "failed")

  Exports ==> CoercibleTo(OutputForm) with
    nodeArray : () -> %
    nodeArray : % -> %
    lastNode : % -> TCN
    lastIndex : % -> NNI
    addNode! : (N, %) -> TCN
    addNode! : (N, N, %) -> TCN
    addNode! : (N, List(N), %) -> TCN
    addTypeVar! : % -> N
    addType! : (TCN, N, %) -> Void
    setType! : (TCN, N, %) -> Boolean

    apply! : (MR, List(N), %) -> Void
    apply! : (SUBST, %) -> Void

    node : (NNI, %) -> TCN

    coerce : AssociationList(MR, List(N)) -> OutputForm
    check : % -> Boolean

  Implementation ==> add
    Rep := Record(nodes : FlexibleArray(TCN),
                  counter : NNI,
                  typevars : AssociationList(MR, List(N)))

    import String
    import TCNode
    import SpadNode
    import TypeUnifier
    import OutputFormExt
    import SpadNodeFactory

    nodeArray () ==
      [flexibleArray [], 0, [[]]]

    nodeArray x ==
      [flexibleArray [], x.counter, [[]]]

    coerce (typevars : AssociationList(MR, List(N))) : OutputForm ==
      format(tvar : MR, types : List(N)) : OF ==
        prefix := hconcat [right(tvar :: OF, 4), " : "]
        ts := if #types = 1 then (first types) :: OF else types :: OF
        hconcat [prefix, ts]
      tvs := [format(tv.key, tv.entry) for tv in reverse entries typevars]
      empty? tvs => "No type variables!"
      pile ["Type variables :", :tvs]

    coerce (x : %) : OutputForm ==
      pile ["Nodes :", :[ni :: OF for ni in entries x.nodes]]

    lastNode x ==
      ns := x.nodes
      ns(#ns)

    lastIndex x == #(x.nodes)

    addNode!(n, x) ==
      addNode! (n, addTypeVar! x, x)

    addNode!(n : N, types : List(N), x : %) : TCN ==
      typevar := addTypeVar! x
      ni := addNode!(n, typevar, x)
      typevars := x.typevars
      typevars(typevar :: MR) := types
      ni

    addNode!(n : N, type : N, x : %) : TCN ==
      ni := [#(x.nodes) + 1, n, type]
      concat!(x.nodes, ni)
      ni

    addTypeVar! x ==
      x.counter := x.counter + 1
      tvar := typeVar(x.counter)
      typevars := x.typevars
      typevars(tvar :: MR) := [emptyNode()]
      tvar

    node (i, x) ==
      (x.nodes)(i)

    emptyType? : List(N) -> Boolean
    emptyType? nl ==
      #nl = 1 and emptyNode?(first nl)

    fetch : (N, %) -> List(N)
    fetch(n, x) ==
      not typeVar? n => [n] 
      nl := (x.typevars)(n :: MR)
      emptyType? nl => [n]
      nl

    unknownType? : (TCN, %) -> Boolean
    unknownType? (n, x) ==
      ++ checks if type attached to the node has form "%a[?]"
      typeVar? n.type and emptyType? fetch(n.type, x)

    typeInferred? : (MR, %) -> Boolean
    typeInferred?(tvar, x) ==
      types := (x.typevars)(tvar)
      #types > 1 => false
      not unbound? types.1

    setType!(n, type, x) ==
      print ["[*]", number(n.index) :: OF, "is of", type :: OF, "type."]
      typeVar? n.type =>
        typevars := x.typevars
        typevars(n.type :: MR) := [type]
        true
      n.type = type

    addType!(n, type, x) ==
      print ["[*] Adding type alternative of", type :: OF, "to node", number(n.index) :: OF]
      not typeVar? n.type =>
        error "addType! works only on type variants"
      typevars := x.typevars
      tvar := n.type :: MR
      emptyType? typevars(tvar) =>
        typevars(tvar) := [type]
      typevars(tvar) := [type, :typevars(tvar)]

    rewriteTypeVars! : (MR, List(N), AssociationList(MR, List(N))) -> Void
    rewriteTypeVars!(var, terms, typevars) ==
      -- if type variable has no value then set it to whatever we've inferred
      emptyType? typevars(var) =>
        typevars(var) := terms

      -- unify proposed values with already stored in the variable
      -- store only matching ones (without performing substitutions)
      types := [t for t in typevars(var) | matches?(t, terms)]
      empty? types =>
        error "rewriteTypeVars: No matches!"
      typevars(var) := types

    apply!(var, terms, x) ==
      print ["[*] Modyfing", var :: OF, "type variable with", terms :: OF]
      rewriteTypeVars!(var, terms, x.typevars)
      if typeInferred?(var, x) then
        for tv in entries x.typevars repeat
          tv.entry := [substitute(t, var, first terms) for t in tv.entry]

    apply!(substitutions, x) ==
      for s in entries substitutions repeat
        apply!(s.key, s.entry, x)

    nodesMatch! : (TCN, TCN, %) -> Boolean
    nodesMatch!(ln, rn, x) ==
      ++ %a[?] ~ %b[?]
      unknownType?(ln, x) and unknownType?(rn, x) =>
        ures := unifyType(ln.type, rn.type)
        failed? ures => false
        apply!(ures :: SUBST, x)
        true
      ++ %a[?] ~ (%b[t1, t2, ...] | T)
      unknownType?(ln, x) and not unknownType?(rn, x) =>
        apply!(ln.type :: MR, [rn.type], x)
        true
      ++ (%a[t1, t2, ...] | T) ~ %b[?]
      not unknownType?(ln, x) and unknownType?(rn, x) =>
        apply!(rn.type :: MR, [ln.type], x)
        true
      ++ (%a[t1, t2, ...] | T) ~ (%b[s1, s2, ...] | S)
      ms := findMatches(fetch(ln.type, x), fetch(rn.type, x))
      empty? ms.terms => false
      if typeVar? ln.type then
        (x.typevars)(ln.type :: MR) := ms.terms
      if typeVar? rn.type then
        (x.typevars)(rn.type :: MR) := ms.terms
      apply!(ms.subst, x)
      true

    nodeType! : (TCN, List(N), %) -> Boolean
    nodeType!(n, types, x) ==
      ++ %a[?] ~ [s1, s2, ...]
      unknownType?(n, x) =>
        apply!(n.type :: MR, types, x)
        true
      ++ (%a[t1, t2, ...] | T) ~ [s1, s2, ...]
      ms := findMatches(fetch(n.type, x), types)
      empty? ms.terms => false
      if typeVar? n.type then
        (x.typevars)(n.type :: MR) := ms.terms
      apply!(ms.subst, x)
      true

    -- rewrite all nodes with type that contains given variable
    rewriteNodes! : (MR, N, FlexibleArray(TCN)) -> Void
    rewriteNodes! (var, term, ns) ==
      nodes := [n for n in entries ns | occurs?(var, n.type)] 
      for n in nodes repeat
        n.type := substitute(n.type, var, term)
        print(["[*] Rewrote", number(n.index) :: OF, "with",
               hconcat ["{", var :: OF, " => ", term :: OF, "}"]])
      for n in nodes repeat
        checkAndMarkIfDone! n

    product : List(List(N)) -> List(List(N))
    product ll ==
      empty? ll => [[]]
      el := first ll
      pl := product(rest ll)
      concat [[cons(e, p) for p in pl] for e in el]

    inferType : (TCN, %) -> Boolean
    inferType(n, x) ==
      emptyNode? n.rule => true

      print ["[*] Run type inference for", number(n.index) :: OF, "of", n.type :: OF, "type."]

      apply? n.rule =>
        nfun := first n.children -- function node
        nargs := rest n.children -- argument nodes
        -- TODO: generate all possible variants
        sigs : List(N) := [[[[narg.type for narg in nargs], n.type]$MT]]
        --print ["(~) sigs1 :", sigs :: OF]
        --argslst := product [fetch(narg.type, x) for narg in nargs]
        --sigs2 : List(N) := [[[args, n.type]$MT] for args in argslst]
        --print ["(~) sigs2 :", sigs2 :: OF]
        nodeType!(nfun, sigs, x)

      assign? n.rule =>
        ln := n.children.1 -- left node
        rn := n.children.2 -- right node
        nodesMatch!(ln, rn, x) and nodesMatch!(ln, n, x)

      conditional? n.rule =>
        cn := n.children.1 -- condition node
        tn := n.children.2 -- true branch node
        fn := n.children.3 -- false branch node
        not nodeType!(cn, [booleanType], x) => false
        if nodesMatch!(tn, fn, x)
          then nodesMatch!(n, tn, x)
          else nodeType!(n, [voidType], x)

      nodeRef? n.rule =>
        mr := n.rule :: MR
        nref := node(mr.id, x) -- referenced node
        nodesMatch!(n, nref, x)

      error "inferType: Unknown rule!"

    countProgress : % -> Record(a : Integer, b : Integer)
    countProgress x ==
      ++ a = number of type variables and nodes to be processed
      ++     (empty type variable counts twice)
      ++ b = sum of types assigned to each type variable
      p := [#(x.typevars), 0]
      for n in entries x.nodes | not done? n repeat
        types : List(N) :=
          not typeVar? n.type => []
          (x.typevars)(n.type :: MR)
        p.a := p.a + 1
        if emptyType? types
          then p.a := p.a + 1
          else p.b := p.b + #types
      p

    check x ==
      q : Queue(TCN) := empty()

      -- initial run => fill up the queue with nodes that aren't done yet
      for n in reverse entries x.nodes repeat 
        checkAndMarkIfDone! n
        if not done? n then
          enqueue!(n, q)

      p := countProgress x
      s := 1 :: NNI

      while p.a > 0 or p.b > 0 repeat
        newQ : Queue(TCN) := empty()

        step := paren(s :: OF)

        ++ perform meta-step
        while not empty? q repeat
          n := dequeue! q
          done? n => "iterate"

          --print([step, "Queue state =>", number(n.index) :: OF, ":",
          --       bracket [number(m.index) :: OF for m in members q]])

          not inferType(n, x) =>
            print (x :: OF)
            print (x.typevars :: OF)
            print ["(!) Failed to infer type for: ", number(n.index) :: OF]
            print box(n.node :: OF)
            return false

          ++ check if we're done with processing type variable tied to this node
          if typeVar? n.type then
            var := n.type :: MR
            if typeInferred?(var, x) then
              term := first(remove!(var, x.typevars) :: List(N))
              print ["[*] Type inferred for node", number(n.index) :: OF, ":", term :: OF]
              rewriteNodes!(var, term, x.nodes)

          ++ if type is inferred for all dependencies the node itself won't change
          checkAndMarkIfDone! n
          if done? n then
            print ["[*] Processing node", number(n.index) :: OF, "completed!"]
          else
            enqueue!(n, newQ)

        ++ check if during meta-step the problem was reduced compared to
        ++ previous meta-step
        newP := countProgress x
        correct :=
          newP.a < p.a => true
          newP.a = p.a and newP.b < p.b => true
          false
        not correct =>
          print (x :: OF)
          print (x.typevars :: OF)
          error "Type checker does not advance by applying known typing rules!"

        ++ setup new meta-step
        p := newP
        q := newQ
        s := s + 1

      print (x :: OF)
      true

)abbrev package STYPCHK SpadTypeChecker
SpadTypeChecker() : Exports == Implementation where
  N ==> SpadNode
  APP ==> SpadApply(N)
  ASS ==> SpadAssign(N)
  CN ==> SpadConditional(N)
  FN ==> SpadFunction(N)
  FT ==> SpadFunctor(N)
  IM ==> SpadImport(N)
  LAM ==> SpadLambda(N)
  LP ==> SpadLoop(N)
  M ==> SpadMacro(N)
  MT ==> SpadMappingType(N)
  NT ==> SpadNamedType(N)
  RT ==> SpadRecordType(N)
  SEG ==> SpadSegment(N)
  SEQ ==> SpadSequence(N)
  ST ==> SpadSumType(N)
  TE ==> SpadTypeExpr(N)
  UT ==> SpadUnionType(N)
  W ==> SpadWhere(N)
  MR ==> SpadMarker(N)

  NNI ==> NonNegativeInteger
  OF ==> OutputForm
  ENV ==> SpadEnvironment
  TCN ==> TCNode
  CTX ==> TCNodeArray
  SUBST ==> AssociationList(MR, List(N))

  Exports ==> with
    walk : (APP, CTX, ENV) -> ENV
    walk : (ASS, CTX, ENV) -> ENV
    walk : (CN, CTX, ENV) -> ENV
    walk : (FN, CTX, ENV) -> ENV
    walk : (FT, CTX, ENV) -> ENV
    walk : (IM, CTX, ENV) -> ENV
    --walk : (LAM, CTX, ENV) -> ENV
    walk : (LP, CTX, ENV) -> ENV
    --walk : (SEG, CTX, ENV) -> ENV
    walk : (SEQ, CTX, ENV) -> ENV
    walk : (DoubleFloat, CTX, ENV) -> ENV
    walk : (Integer, CTX, ENV) -> ENV
    walk : (String, CTX, ENV) -> ENV
    walk : (Symbol, CTX, ENV) -> ENV
    walk : (TE, CTX, ENV) -> ENV

    walk : (N, CTX, ENV) -> ENV
    addChildren : (TCN, List(N), CTX, ENV) -> ENV

  Implementation ==> add
    import SpadEnvironment
    import SExpression
    import String
    import TCNode
    import SpadNode
    import SpadNodeFactory
    import OutputFormExt
    import TypeUnifier

    envAddType : (N, ENV) -> ENV
    envAddType (t : N, env : ENV) : ENV ==
      ++ print ["(e) Adding type", t :: OF, "to the environment."]
      if apply? t then
        app := t :: APP
        env := addDomain(app, env)
        for k in [app.function, :app.args] repeat
          env := envAddType(k, env)
      if mappingType? t then
        mt := t :: MT
        for k in [mt.type, :mt.args] repeat
          env := envAddType(k, env)
      env

    walk (a : APP, ctx : CTX, env : ENV) : ENV ==
      fn := a.function
      args := a.args

      symbol? fn and string(fn :: Symbol) = "return" =>
        print ["[*] Processing return statement."]
        #args ~= 2 => error "malformed return statement"
        node := addNode!([a], ctx)
        env := addChildren(node, [rest args], ctx, env)
        node.children := [node(1, ctx), :node.children]
        nl := [nodeRef(n.index) for n in node.children]
        node.rule := [[nl.1, nl.2]$ASS]
        env

      print ["[*] Processing function application."]
      node := addNode!([a], ctx)
      env := addChildren(node, [fn, :args], ctx, env)
      nl := [nodeRef(n.index) for n in node.children]
      node.rule := [[first nl, rest nl]$APP]
      env

    walk (a : ASS, ctx : CTX, env : ENV) : ENV ==
      -- handle "symbol : Type := value"
      typeExpr? a.lval =>
        te := a.lval :: TE
        env := walk(te, ctx, env)
        walk([te.expr, a.rval]$ASS, ctx, env)
      
      type := addTypeVar! ctx

      if symbol? a.lval then
        s := a.lval :: Symbol
        if emptyNode? getMode(s, env) then
          print ["[*] Processing fresh assignment", string(s) :: OF]
          env := addMode(s, addTypeVar! ctx, env)
        
      node := addNode!([a], type, ctx)
      env := addChildren(node, [a.lval, a.rval], ctx, env)
      nl := [nodeRef(n.index) for n in node.children]
      node.rule := [[nl.1, nl.2]$ASS]
      env

    walk (cn : CN, ctx : CTX, env : ENV) : ENV ==
      print ["[*] Processing conditional expression."]
      node := addNode!([cn], ctx)
      env := addChildren(node, [cn.cond, cn.truebr, cn.falsebr], ctx, env)
      nl := [nodeRef(n.index) for n in node.children]
      node.rule := [[nl.1, nl.2, nl.3]$CN]
      env

    walk (fn : FN, ctx : CTX, env : ENV) : ENV ==
      print ["[*] Processing function", string(fn.name) :: OF]

      fnNode := addNode!([fn], ctx)

      sig := (signature fn).type
      name := funsig(fn.name, #fn.args)

      -- fetch signatures from domain's definition
      mappings : List(N) := [[mm.type] for mm in getModemap(fn.name, env)]
      print(["Found", string(name) :: OF, "with signatures :",
             bracket [t :: OF for t in mappings]])

      -- signature associated with function definition
      mt := sig :: MT
      print ["Signature associated with function definition :", mt :: OF]

      -- prepare function signature for unification
      types : List(N) := []
      for type in [mt.type, :mt.args] for i in 1.. repeat
        if emptyNode? type then
          type := typeVar(i)
        types := [type, :types]
      types := reverse types
      sig := [[rest types, first types]$MT]

      -- calculate eligible signatures
      sigs : List(MT) := []
      for m in mappings repeat
        ures := unifyType(sig, m)
        failed? ures => "iterate"
        sigs := [substitute(sig, ures :: SUBST) :: MT, :sigs]
      sigs := reverse sigs

      empty? sigs =>
        error "No signature corresponding to the function!"

      print ["Eligible signatures :", sigs :: OF]

      -- try to check type for each eligible signature
      for mt in sigs repeat
        print ["[*] Assume", name :: OF, "has type :", mt :: OF]

        env' := envAddType([mt], env)
        for arg in fn.args for argt in mt.args repeat
          env' := addMode((arg :: NT).name, argt, env')

        ctx' := nodeArray ctx
        node := addNode!([mt], mt.type, ctx')
        env' := addChildren(node, [fn.body], ctx', env')
        node.rule := nodeRef(2)

        print "[*] Tree ready for unification : " 
        print (ctx' :: OF)

        not check ctx' => "iterate"

        fnNode.type := [mt]
        return env

      env

    walk (ft : FT, ctx : CTX, env : ENV) : ENV ==
      sig := signature ft
      print ["[*] Processing functor :", sig :: OF]
      self := "$" :: Symbol
      env := addMode(sig.name, sig.type, env)
      env := addMode(self, ft.type, env)
      env := addModemapsFromCategory([self], ft.type, env)

      ++ process functor's arguments
      cat := [[['Category], []]$APP]
      for arg in ft.args repeat
        typ := arg.type :: APP
        env := addModemap(typ.function :: Symbol, typ, [cat], env)
        env := addMode(arg.name, arg.type, env)
        env := addModemapsFromCategory([arg.name], arg.type, env)

      node := addNode!([ft], sig.type, ctx)
      env := addChildren(node, [ft.capsule], ctx, env)
      node.rule := nodeRef(node.index + 1)
      env

    walk (im : IM, ctx : CTX, env : ENV) : ENV ==
      print ["[*] Importing", im.type :: OF]
      env := envAddType(im.type, env)
      addNode!([im], voidType, ctx)
      env

    --walk (l : LAM, ctx : CTX, env : ENV) : ENV ==
    --  node := addNode! ctx
    --  addChildren(node, [l.body], ctx, env)

    walk (lp : LP, ctx : CTX, env : ENV) : ENV ==
      print ["[*] Loop statement."]
      node := addNode!([lp], voidType, ctx)
      not empty? lp.itors =>
        error "Loop iterators not handled yet!"
      print ["[*] Processing", #(lp.guards) :: OF, "guards."]
      env := addChildren(node, lp.guards, ctx, env)
      for guard in node.children repeat
        setType!(guard, booleanType, ctx)
      print ["[*] Processing loop body."]
      addChildren(node, [lp.body], ctx, env)

    --walk (seg : SEG, ctx : CTX, env : ENV) : ENV ==
    --  node := addNode! ctx
    --  addChildren(node, [seg.start, seg.end, seg.step], ctx, env)

    walk (s : SEQ, ctx : CTX, env : ENV) : ENV ==
      print ["[*] Found sequence of", #(s.list) :: OF, "expressions."]
      node := addNode!([s], ctx)
      env := addChildren(node, s.list, ctx, env)
      node.rule := nodeRef((last node.children).index)
      env

    walk (s : Symbol, ctx : CTX, env : ENV) : ENV ==
      print ["[*] Symbol lookup for", string(s) :: OF]
      types : List(N) := [[mm.type] for mm in getModemap(s, env)]
      mode := getMode(s, env)
      if not emptyNode? mode then
        types := [mode, :types]
      ++ BUG: parseTran use true and false as "Boolean" and not as "() -> Boolean"
      ++ workaround for Boolean constants
      if s = 'true or s = 'false then
        types := [booleanType, :types]
      empty? types => error "Undefined symbol!"
      if #types = 1
        then addNode!([s], first types, ctx)
        else addNode!([s], types, ctx)
      print(["Found", string(s) :: OF, "with type :",
            bracket [t :: OF for t in types]])
      env

    walk (te : TE, ctx : CTX, env : ENV) : ENV ==
      te.kind = '_: => 
        print ["[*] Expression", te.expr :: OF, "has type", te.type :: OF]

        not symbol? te.expr =>
          error "Type annotation works only for symbols!"

        -- type definition for a symbol:
        -- add it to the environment or crash if already defined
        s := te.expr :: Symbol
        not emptyNode? getMode(s, env) =>
          print [s :: OF, "already defined as", getMode(s, env) :: OF]
          error "Symbol already defined!"

        addNode!([te], te.type, ctx)
        addMode(s, te.type, env)

      te.kind = '_@ =>
        print ["[*] Expression", te.expr :: OF, "has to return type", te.type :: OF]
        not apply? te.expr =>
          error "Type cut operator works only for function application!"
        env := envAddType(te.type, env)
        next := lastIndex ctx + 1
        env := walk(te.expr, ctx, env)
        setType!(node(next, ctx), te.type, ctx)
        env

      te.kind = '_:_: =>
        print ["[*] Expression", te.expr :: OF, "have to coerce to", te.type :: OF]
        i := lastIndex ctx + 1
        -- convert "::" to "coerce" function call
        env := walk([[['coerce], [te.expr]]$APP], ctx, env)
        -- conversion above almost works, but we need to fix it for identity
        -- coercion by infusing artificial signature "%a -> %a" which is not
        -- always available
        coerceNode := node(i, ctx)
        argType := coerceNode.children.2.type
        idFunType := [[[argType], argType]$MT]
        addType!(coerceNode.children.1, idFunType, ctx)
        env
    
      ++ te.kind = '_$

      error "Not handled!"

    walk (i : Integer, ctx : CTX, env : ENV) : ENV ==
      print ["[*]", i :: OF, "is", integerType :: OF, ":)"]
      addNode!([i], integerType, ctx)
      env

    walk (f : DoubleFloat, ctx : CTX, env : ENV) : ENV ==
      print ["[*]", f :: OF, "is", floatType :: OF, ":)"]
      addNode!([f], floatType, ctx)
      env

    walk (s : String, ctx : CTX, env : ENV) : ENV ==
      print ["[*]", s :: OF, "is", stringType :: OF, ":)"]
      addNode!([s], stringType, ctx)
      env

    walk (n : N, ctx : CTX, env : ENV) : ENV ==
      apply? n => walk(n :: APP, ctx, env)
      assign? n => walk(n :: ASS, ctx, env)
      conditional? n => walk(n :: CN, ctx, env)
      float? n => walk(n :: DoubleFloat, ctx, env)
      functor? n => walk(n :: FT, ctx, env)
      import? n => walk(n :: IM, ctx, env)
      integer? n => walk(n :: Integer, ctx, env)
      --lambda? n => walk(n :: LAM, ctx, env)
      loop? n => walk(n :: LP, ctx, env)
      --segment? n => walk(n :: SEG, ctx, env)
      sequence? n => walk(n :: SEQ, ctx, env)
      string? n => walk(n :: String, ctx, env)
      symbol? n => walk(n :: Symbol, ctx, env)
      typeExpr? n => walk(n :: TE, ctx, env)
      function? n => walk(n :: FN, ctx, env)
      -- namedType, mappingType, recordType, sumType, unionType, macro, where
      if emptyNode? n then
        addNode!(n, voidType, ctx)
      env

    addChildren (parent, nodes, ctx, env) ==
      cl : List(TCN) := []
      for n in nodes repeat
        i := lastIndex ctx + 1
        env := walk(n, ctx, env)
        cl := [node(i, ctx), :cl]
      parent.children := concat(reverse cl, parent.children)
      env
