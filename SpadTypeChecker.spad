)abbrev package SPNFACT SpadNodeFactory
SpadNodeFactory() : Exports == Implementation where
  NNI ==> NonNegativeInteger
  N ==> SpadNode
  MR ==> SpadMarker(N)
  NT ==> SpadNamedType(N)
  MT ==> SpadMappingType(N)
  RT ==> SpadRecordType(N)
  UT ==> SpadUnionType(N)
  mt ==> nodeMappingType

  Exports ==> with
    booleanType : () -> N
    floatType : () -> N
    integerType : () -> N
    outputFormType : () -> N
    stringType : () -> N
    symbolType : () -> N
    voidType : () -> N

    typeAny : () -> N
    typeVar : NNI -> N

    makeRecordFunList : N -> List(NT)
    makeUnionFunList : N -> List(NT)

  Implementation ==> add
    booleanType () == nodeApp(['Boolean], [])
    floatType () == nodeApp(['DoubleFloat], [])
    integerType () == nodeApp(['Integer], [])
    outputFormType () == nodeApp(['OutputForm], [])
    stringType () == nodeApp(['String], [])
    symbolType () == nodeApp(['Symbol], [])
    voidType () == nodeApp(['Void], [])

    typeAny() == [[0, 'typevar]$MR]
    typeVar(i) == [[i, 'typevar]$MR]

    makeRecordFunList n ==
      r := n :: RT
      funs : List(NT) :=
       ([['=, mt([n, n], booleanType())],
         ['~=, mt([n, n], booleanType())],
         ['copy, mt([n], n)],
         ['coerce, mt([n], outputFormType())],
         ['construct, mt([f.type for f in r.fields], n)]
        ])
      for f in r.fields repeat
        s : N := [f.name]
        r : N := f.type
        funs := [['elt, mt([n, s], r)], ['setelt!, mt([n, s, r], r)], :funs]
      funs

    makeUnionFunList n ==
      u := n :: UT
      n := ['%]
      funs : List(NT) :=
       ([['=, mt([n, n], booleanType())],
         ['~=, mt([n, n], booleanType())],
         ['coerce, mt([n], outputFormType())]
        ])
      vs := u.variants
      if not namedType? vs.1 then
        for v in vs repeat
          funs := [['construct, mt([v], n)], ['coerce, mt([n], v)], :funs]
      funs

)abbrev package TUNIFY TypeUnifier
TypeUnifier() : Exports == Implementation where
  PF ==> PrintableForm
  N ==> SpadNode
  APP ==> SpadApply(N)
  MT ==> SpadMappingType(N)
  NT ==> SpadNamedType(N)
  MR ==> SpadMarker(N)
  RT ==> SpadRecordType(N)
  TE ==> SpadTypeExpr(N)
  UT ==> SpadUnionType(N)
  SUBST ==> AssociationList(MR, List(N))
  P ==> Record(t1 : N, t2 : N)
  URES ==> Union(SUBST, "failed")

  Exports ==> with
    failed? : URES -> Boolean 

    occurs? : (MR, N) -> Boolean
    unbound? : N -> Boolean

    freeVars : N -> List(MR)

    substitute : (N, MR, N) -> N
    substitute : (N, SUBST) -> N

    unifyType : (N, N) -> URES
    unifyTypeList : List(P) -> URES

    matches? : (N, List(N)) -> Boolean
    findMatches : (List(N), List(N)) -> Record(terms : List(N), subst : SUBST)

  Implementation ==> add
    import SpadNode
    import Printer
    import SpadNodeFactory
    import Logger('Unify)

    convert : SUBST -> PF
    convert subst ==
      vconcat [spaces [s.key :: PF, "=>" :: PF, bracket [t :: PF for t in s.entry]] for s in entries subst]

    failed? t == t case "failed"

    occurs? (tvar, n) ==
      import List(N)

      symbol? n => false
      typeAny? n => false

      apply? n =>
        app := n :: APP
        any?(m +-> occurs?(tvar, m), [app.function, :app.args])
      mappingType? n =>
        mt := n :: MT
        any?(m +-> occurs?(tvar, m), [mt.type, :mt.args])
      namedType? n =>
        nt := n :: NT
        occurs?(tvar, nt.type)
      recordType? n =>
        rt := n :: RT
        any?(m +-> occurs?(tvar, m), [f.type for f in rt.fields])
      typeOrigin? n =>
        te := n :: TE
        occurs?(tvar, te.expr) or occurs?(tvar, te.type)
      typeVar? n =>
        (n :: MR) = tvar

      fail ["occurs?: case not handled for" :: PF, n :: PF]
      error ""

    unbound? n ==
      import List(N)

      emptyNode? n => true
      symbol? n => false
      typeAny? n => false
      typeVar? n => true

      apply? n =>
        app := n :: APP
        any?(unbound?, [app.function, :app.args])
      namedType? n =>
        nt := n :: NT
        unbound? nt.type
      recordType? n =>
        rt := n :: RT
        any?(unbound?, [f.type for f in rt.fields])
      mappingType? n =>
        mt := n :: MT
        any?(unbound?, [mt.type, :mt.args])
      typeOrigin? n =>
        te := n :: TE
        unbound? te.expr or unbound? te.type

      fail ["unbound?: case not handled for" :: PF, n :: PF]
      error ""

    freeVars n ==
      import List(N)

      apply? n =>
        app := n :: APP
        "concat"/[freeVars i for i in [app.function, :app.args]]
      mappingType? n =>
        mt := n :: MT
        "concat"/[freeVars i for i in [mt.type, :mt.args]]
      typeVar? n => [n :: MR]
      typeExpr? n =>
        te := n :: TE
        concat(freeVars te.type, freeVars te.expr)

      fail ["freeVars: case not handled for" :: PF, n :: PF]
      error ""

    substitute(n : N, var : MR, term : N) : N ==
      emptyNode? n => n
      string? n => n
      symbol? n => n
      typeAny? n => n

      apply? n =>
        app := n :: APP
        lst := [substitute(k, var, term) for k in [app.function, :app.args]]
        nodeApp(first lst, rest lst)
      mappingType? n =>
        mt := n :: MT
        lst := [substitute(k, var, term) for k in [mt.type, :mt.args]]
        nodeMappingType(rest lst, first lst)
      namedType? n =>
        nt := n :: NT
        nodeNamedType(nt.name, substitute(nt.type, var, term))
      recordType? n =>
        rt := n :: RT
        lst := [[f.name, substitute(f.type, var, term)]$NT for f in rt.fields]
        nodeRecordType(lst)
      typeOrigin? n =>
        te := n :: TE
        expr := substitute(te.expr, var, term)
        type := substitute(te.type, var, term)
        nodeTypeExpr(te.kind, expr, type)
      typeVar? n =>
        if (n :: MR) = var then term else n

      fail ["substitute: case not handled for" :: PF, n :: PF]
      error ""

    substitute(n : N, subst : SUBST) : N ==
      for s in entries subst repeat
        var := s.key
        for term in s.entry repeat
          n := substitute(n, var, term)
      n

    mergeSubstitutions : List(SUBST) -> SUBST
    mergeSubstitutions substitutionsList ==
      merged := [[]]
      -- merge list for each valid substitution
      for substitutions in substitutionsList repeat
        for s in entries substitutions repeat
          merged(s.key) := 
            key?(s.key, merged) =>
              concat(s.entry, merged(s.key))
            s.entry
      -- remove duplicates from term lists
      for s in entries merged repeat
        merged(s.key) := removeDuplicates s.entry
      merged

    unifyType(n1 : N, n2 : N) : URES ==
      debug [brace(n1 :: PF), "~" :: PF, brace(n2 :: PF)]

      -- left or right node is a type variable => just generate a substitution
      typeVar? n1 and typeVar? n2 =>
        mr1 := n1 :: MR
        mr2 := n2 :: MR
        mr1 = mr2 => [[]]
        -- always substitute newer variable with older one to avoid (?) cycles
        if mr1.id > mr2.id
          then [[[mr1, [n2]]]]
          else [[[mr2, [n1]]]]
      typeVar? n1 =>
        occurs? (n1 :: MR, n2) => "failed"
        [[[n1 :: MR, [n2]]]]
      typeVar? n2 =>
        occurs? (n2 :: MR, n1) => "failed"
        [[[n2 :: MR, [n1]]]]

      -- type wildcard found? => leave without generating a substitution
      typeAny? n1 or typeAny? n2 => [[]]

      -- both nodes can be represented as lists of terms and variables
      -- so convert them to a pair of lists and perform unification
      mappingType? n1 and mappingType? n2 =>
        mt1 := n1 :: MT
        mt2 := n2 :: MT
        #(mt1.args) ~= #(mt2.args) => "failed"
        pairs : List(P) :=
          [[t1, t2] for t1 in [mt1.type, :mt1.args] for t2 in [mt2.type, :mt2.args]]
        unifyTypeList pairs
      apply? n1 and apply? n2 =>
        app1 := n1 :: APP
        app2 := n2 :: APP
        #(app1.args) ~= #(app2.args) => "failed"
        pairs : List(P) :=
          [[t1, t2] for t1 in [app1.function, :app1.args] for t2 in [app2.function, :app2.args]]
        unifyTypeList pairs
      recordType? n1 and recordType? n2 =>
        r1 := n1 :: RT
        r2 := n2 :: RT
        #(r1.fields) ~= #(r2.fields) => "failed"
        not "and"/[f1.name = f2.name for f1 in r1.fields for f2 in r2.fields] => "failed"
        unifyTypeList [[f1.type, f2.type]$P for f1 in r1.fields for f2 in r2.fields]
      unionType? n1 and unionType? n2 =>
        u1 := n1 :: UT
        u2 := n2 :: UT
        #(u1.variants) ~= #(u2.variants) => "failed"
        unifyTypeList [[v1, v2]$P for v1 in u1.variants for v2 in u2.variants]
      namedType? n1 and namedType? n2 =>
        nt1 := n1 :: NT
        nt2 := n2 :: NT
        nt1.name ~= nt2.name => "failed"
        unifyType(nt1.type, nt2.type)
      typeOrigin? n1 and typeOrigin? n2 =>
        te1 := n1 :: TE
        te2 := n2 :: TE
        unifyTypeList [[te1.type, te2.type]$P, [te1.expr, te2.expr]$P]
      typeOrigin? n1 =>
        te1 := n1 :: TE
        unifyType(te1.expr, n2)
      typeOrigin? n2 =>
        te2 := n2 :: TE
        unifyType(n1, te2.expr)

      -- constants
      symbol? n1 and symbol? n2 and (n1 :: Symbol) = (n2 :: Symbol) => [[]]
      integer? n1 and integer? n2 and (n1 :: Integer) = (n2 :: Integer) => [[]]
      string? n1 and string? n2 and (n1 :: String) = (n2 :: String) => [[]]

      "failed"

    unifyTypeList(pairs : List(P)) : URES ==
      subst : SUBST := [[]]
      while not empty? pairs repeat
        pair := first pairs
        ures := unifyType(pair.t1, pair.t2)
        failed? ures => return "failed"
        subst := concat (subst, ures :: SUBST)
        pairs := [[substitute(pair.t1, subst), substitute(pair.t2, subst)]$P for pair in rest pairs]
      subst

    matches?(term : N, terms : List(N)) : Boolean ==
      any?(t +-> not failed? unifyType(t, term) or term = t, terms)

    findMatches(terms1, terms2) ==
      debug vconcat([pile ["Trying to match:" :: PF, vconcat [t1 :: PF for t1 in terms1]],
                     pile ["with:" :: PF, vconcat [t2 :: PF for t2 in terms2]]])
      terms : List(N) := []
      subst : List(SUBST) := []
      for t1 in terms1 repeat
        for t2 in terms2 repeat
          ures := unifyType(t1, t2)
          failed? ures => "iterate"
          -- prefer concrete type instead of wildcard
          t := if typeAny? t1 then t2 else t1
          terms := [substitute(t, ures :: SUBST), :terms]
          subst := [ures :: SUBST, :subst]
      -- remove wildcard if we have more than one match
      if #terms > 1 then
        terms := [t for t in removeDuplicates terms | not typeAny? t]
      subst' := mergeSubstitutions subst
      --debug pile ["Substitutions:" :: PF, convert(subst')]
      --debug pile ["Terms:" :: PF, :[t :: PF for t in terms]]
      [terms, subst']

)abbrev domain TCNODE TCNode
TCNode() : Exports == Implementation where
  PF ==> PrintableForm
  NNI ==> NonNegativeInteger
  ENV ==> SpadEnvironment
  N ==> SpadNode
  MR ==> SpadMarker(N)
  SUBST ==> AssociationList(MR, List(N))

  Exports ==> CoercibleTo(PrintableForm) with
    elt : (%, "index") -> NNI
    elt : (%, "node") -> N
    elt : (%, "children") -> List(%)
    elt : (%, "rule") -> N
    elt : (%, "type") -> N
    setelt! : (%, "index", NNI) -> NNI
    setelt! : (%, "children", List(%)) -> List(%)
    setelt! : (%, "rule", N) -> N
    setelt! : (%, "type", N) -> N

    construct : (NNI, N, N) -> %
    substitute! : (SUBST, %) -> Void
    checkAndMarkIfDone! : % -> Boolean
    done? : % -> Boolean

  Implementation ==> add
    Rep := Record(ni_index : NNI,
                  ni_node : N,
                  ni_children : List(%),
                  ni_rule : N,
                  ni_type : N,
                  ni_done : Boolean)

    import SpadNode
    import Printer
    import TypeUnifier

    elt (x, "index") == x.ni_index
    elt (x, "node") == x.ni_node
    elt (x, "children") == x.ni_children
    elt (x, "rule") == x.ni_rule
    elt (x, "type") == x.ni_type

    setelt! (x, "index", i) ==
      x.ni_index := i
    setelt! (x, "children", cl) ==
      x.ni_children := cl
    setelt! (x, "rule", r) ==
      x.ni_rule := r
    setelt! (x, "type", ts) ==
      x.ni_type := ts

    construct (i, n, t) ==
      [i, n, [], emptyNode(), t, false] $ Rep

    substitute! (subst, x) ==
      x.type := substitute(x.type, subst)

    checkAndMarkIfDone! x ==
      import List(N)
      unbound? x.type => false
      empty? x.children =>
        x.ni_done := true
      x.ni_done := every?(t +-> not unbound? t, [n.type for n in x.children])

    done? x == x.ni_done

    coerce x ==
      done := if done? x then green("(+)" :: PF) else red("(-)" :: PF)
      p := hconcat [done, right(4, number(x.index) :: PF)]
      cl :=
        empty? x.children and value? x.node => bold(x.node :: PF)
        bracket [number(n.index) :: PF for n in x.children]
      emptyNode? x.rule =>
        spaces [p, cl, "is" :: PF, bold (x.type :: PF)]
      spaces [p, cl, "<-" :: PF, brace (x.rule :: PF), "is" :: PF, bold (x.type :: PF)]

)abbrev package STFITS SpadTreeFillInTypes
SpadTreeFillInTypes(ns : List(N)) : SpadTreeWalkerCategory == Implementation where
  N ==> SpadNode
  APP ==> SpadApply(N)
  TE ==> SpadTypeExpr(N)

  Implementation ==> add
    rewrite (app : APP) : N ==
      -- BUG? | rewrite(app) $ SpadTreeWalkerCategory&
      app := [rewrite app.function, [rewrite arg for arg in app.args]]$APP
      not typeOrigin? app.function => [app]

      -- BUG? | te := app.function :: TE
      te := coerce(app.function)@TE
      nodeApp(rewrite te.expr, [rewrite arg for arg in app.args])

    rewrite (mr : SpadMarker(N)) : N ==
      not mr.kind = 'noderef => [mr]
      t := ns.(mr.id)
      typeOrigin? t =>
        te := coerce(t)@TE
        te.type
      t

)abbrev package TCNA TCNodeArray
TCNodeArray() : Exports == Implementation where
  NNI ==> NonNegativeInteger
  TCN ==> TCNode
  N ==> SpadNode
  APP ==> SpadApply(N)
  ASS ==> SpadAssign(N)
  ENV ==> SpadEnvironment
  MT ==> SpadMappingType(N)
  MR ==> SpadMarker(N)
  TE ==> SpadTypeExpr(N)
  SUBST ==> AssociationList(MR, List(N))
  URES ==> Union(SUBST, "failed")
  PF ==> PrintableForm

  Exports ==> CoercibleTo(PrintableForm) with
    nodeArray : () -> %
    nodeArray : % -> %
    types : % -> List(N)

    lastNode : % -> TCN
    lastIndex : % -> NNI
    addNode! : (N, %) -> TCN
    addNode! : (N, N, %) -> TCN
    addNode! : (N, List(N), %) -> TCN
    addTypeVar! : % -> N
    addType! : (TCN, N, %) -> Void
    setType! : (TCN, N, %) -> Boolean

    apply! : (MR, List(N), %) -> Boolean
    apply! : (SUBST, %) -> Boolean

    node : (NNI, %) -> TCN

    coerce : AssociationList(MR, List(N)) -> PF
    check : % -> Boolean

  Implementation ==> add
    Rep := Record(nodes : FlexibleArray(TCN),
                  counter : NNI,
                  typevars : AssociationList(MR, List(N)))

    import String
    import TCNode
    import SpadNode
    import TypeUnifier
    import SpadNodeFactory
    import Printer
    import Logger('Type)

    nodeArray () ==
      [flexibleArray [], 0, [[]]]

    nodeArray x ==
      [flexibleArray [], x.counter, [[]]]

    types x == [n.type for n in entries x.nodes]

    coerceTypeVar : (MR, List(N)) -> PF
    coerceTypeVar (tvar : MR, types : List(N)) : PF ==
        ts :=
          #types = 1 => (first types) :: PF
          bracket [t :: PF for t in types]
        spaces [right(4, tvar :: PF), ":" :: PF, ts]

    coerce (typevars : AssociationList(MR, List(N))) : PF ==
      tvs := [coerceTypeVar(tv.key, tv.entry) for tv in reverse entries typevars]
      empty? tvs => "No type variables!" :: PF
      pile ["Type variables :" :: PF, :tvs]

    coerce (x : %) : PF ==
      pile ["Nodes :" :: PF, :[ni :: PF for ni in entries x.nodes]]

    lastNode x ==
      ns := x.nodes
      ns(#ns)

    lastIndex x == #(x.nodes)

    addNode!(n, x) ==
      addNode! (n, addTypeVar! x, x)

    addNode!(n : N, types : List(N), x : %) : TCN ==
      typevar := addTypeVar! x
      ni := addNode!(n, typevar, x)
      typevars := x.typevars
      typevars(typevar :: MR) := types
      ni

    addNode!(n : N, type : N, x : %) : TCN ==
      ni := [#(x.nodes) + 1, n, type]
      concat!(x.nodes, ni)
      ni

    addTypeVar! x ==
      x.counter := x.counter + 1
      tvar := typeVar(x.counter)
      typevars := x.typevars
      typevars(tvar :: MR) := [emptyNode()]
      tvar

    node (i, x) ==
      (x.nodes)(i)

    emptyType? : List(N) -> Boolean
    emptyType? nl ==
      #nl = 1 and emptyNode?(first nl)

    fetch : (N, %) -> List(N)
    fetch(n, x) ==
      not typeVar? n => [n] 
      nl := (x.typevars)(n :: MR)
      emptyType? nl => [n]
      nl

    unknownType? : (TCN, %) -> Boolean
    unknownType? (n, x) ==
      ++ checks if type attached to the node has form "%a[?]"
      typeVar? n.type and emptyType? fetch(n.type, x)

    typeInferred? : (MR, %) -> Boolean
    typeInferred?(tvar, x) ==
      types := (x.typevars)(tvar)
      #types > 1 => false
      not unbound? types.1

    setType!(n, type, x) ==
      debug [number(n.index) :: PF, "is of" :: PF, type :: PF, "type." :: PF]
      typeVar? n.type =>
        typevars := x.typevars
        typevars(n.type :: MR) := [type]
        true
      n.type = type

    addType!(n, type, x) ==
      debug ["Adding type alternative of" :: PF, type :: PF, "to node" :: PF, number(n.index) :: PF]
      not typeVar? n.type =>
        fail ("addType! works only on type variants" :: PF)
        error ""
      typevars := x.typevars
      tvar := n.type :: MR
      typevars(tvar) := 
        emptyType? typevars(tvar) => [type]
        [type, :typevars(tvar)]

    rewriteTypeVars! : (MR, List(N), AssociationList(MR, List(N))) -> Boolean
    rewriteTypeVars!(var, terms, typevars) ==
      -- if type variable has no value then set it to whatever we've inferred
      emptyType? typevars(var) =>
        typevars(var) := terms
        true
      -- unify proposed values with already stored in the variable
      -- store only matching ones (without performing substitutions)
      ms := findMatches(typevars(var), terms)
      not empty? ms.terms => 
        typevars(var) := ms.terms
        true
      false

    apply!(var, terms, x) ==
      debug ["Modyfing" :: PF, var :: PF, "type variable with" :: PF, bracket [t :: PF for t in terms]]
      not rewriteTypeVars!(var, terms, x.typevars) => false
      if typeInferred?(var, x) then
        for tv in entries x.typevars repeat
          tv.entry := [substitute(t, var, first terms) for t in tv.entry]
      true

    apply!(substitutions, x) ==
      empty? substitutions => true
      "and"/[apply!(s.key, s.entry, x) for s in entries substitutions]

    nodesMatch! : (TCN, TCN, %) -> Boolean
    nodesMatch!(ln, rn, x) ==
      ++ %a[?] ~ %b[?]
      unknownType?(ln, x) and unknownType?(rn, x) =>
        ures := unifyType(ln.type, rn.type)
        failed? ures => false
        apply!(ures :: SUBST, x)
      ++ %a[?] ~ (%b[t1, t2, ...] | T)
      unknownType?(ln, x) and not unknownType?(rn, x) =>
        apply!(ln.type :: MR, [rn.type], x)
      ++ (%a[t1, t2, ...] | T) ~ %b[?]
      not unknownType?(ln, x) and unknownType?(rn, x) =>
        apply!(rn.type :: MR, [ln.type], x)
      ++ (%a[t1, t2, ...] | T) ~ (%b[s1, s2, ...] | S)
      ms := findMatches(fetch(ln.type, x), fetch(rn.type, x))
      empty? ms.terms => false
      if typeVar? ln.type and ln.type ~= (first ms.terms) then
        (x.typevars)(ln.type :: MR) := ms.terms
      if typeVar? rn.type and rn.type ~= (first ms.terms) then
        (x.typevars)(rn.type :: MR) := ms.terms
      apply!(ms.subst, x)

    nodeType! : (TCN, List(N), %) -> Boolean
    nodeType!(n, types, x) ==
      ++ %a[?] ~ [s1, s2, ...]
      unknownType?(n, x) =>
        apply!(n.type :: MR, types, x)
      ++ (%a[t1, t2, ...] | T) ~ [s1, s2, ...]
      ms := findMatches(fetch(n.type, x), types)
      empty? ms.terms => false
      if typeVar? n.type and n.type ~= (first ms.terms) then
        (x.typevars)(n.type :: MR) := ms.terms
      apply!(ms.subst, x)

    -- rewrite all nodes with type that contains given variable
    rewriteNodes! : (MR, N, FlexibleArray(TCN)) -> Void
    rewriteNodes! (var, term, ns) ==
      nodes := [n for n in entries ns | occurs?(var, n.type)] 
      for n in nodes repeat
        n.type := substitute(n.type, var, term)
        debug (["Rewrote" :: PF, number(n.index) :: PF, "with" :: PF,
                brace spaces [var :: PF, "=>" :: PF, term :: PF]])
      for n in nodes repeat
        checkAndMarkIfDone! n

    rewriteIfInferred! : (TCN, %) -> Boolean
    rewriteIfInferred! (n, x) ==
      not typeVar? n.type => false
      var := n.type :: MR
      not typeInferred?(var, x) => false
      term := first(remove!(var, x.typevars) :: List(N))
      info (["Type inferred for node" :: PF, number(n.index) :: PF,
             ":" :: PF, bold(term :: PF)])
      rewriteNodes!(var, term, x.nodes)
      true

    product : List(List(N)) -> List(List(N))
    product ll ==
      empty? ll => [[]]
      el := first ll
      pl := product(rest ll)
      concat [[cons(e, p) for p in pl] for e in el]

    inferType : (TCN, %) -> Boolean
    inferType(n, x) ==
      emptyNode? n.rule => true

      debug (["Run type inference for" :: PF, number(n.index) :: PF,
              "of" :: PF, n.type :: PF, "type." :: PF])

      apply? n.rule =>
        nfun := first n.children -- function node
        nargs := rest n.children -- argument nodes
        sig := nodeMappingType([narg.type for narg in nargs], n.type)
        --argslst := product [fetch(narg.type, x) for narg in nargs]
        --sigs2 : List(N) := [[[args, n.type]$MT] for args in argslst]
        nodeType!(nfun, [sig], x)

      assign? n.rule =>
        ln := n.children.1 -- left node
        rn := n.children.2 -- right node
        nodesMatch!(ln, rn, x) and nodeType!(n, [ln.type, rn.type], x)

      condExpr? n.rule =>
        cn := n.children.1 -- condition node
        tn := n.children.2 -- true branch node
        fn := n.children.3 -- false branch node
        not nodeType!(cn, [booleanType], x) => false
        if nodesMatch!(tn, fn, x)
          then nodeType!(n, [tn.type, fn.type], x)
          else nodeType!(n, [voidType], x)

      nodeRef? n.rule =>
        mr := n.rule :: MR
        nref := node(mr.id, x) -- referenced node
        nodesMatch!(n, nref, x)

      typeOrigin? n.rule =>
        fun := n.children.1
        nodeType!(n, [fun.type], x)

      fail ["inferType: case not handled for" :: PF, n.rule :: PF]
      error ""

    countProgress : % -> Record(a : Integer, b : Integer)
    countProgress x ==
      ++ a = number of type variables and nodes to be processed
      ++     (empty type variable counts twice)
      ++ b = sum of types assigned to each type variable
      p := [#(x.typevars), 0]
      for n in entries x.nodes | not done? n repeat
        types : List(N) :=
          not typeVar? n.type => []
          (x.typevars)(n.type :: MR)
        p.a := p.a + 1
        if emptyType? types
          then p.a := p.a + 1
          else p.b := p.b + #types
      p

    check x ==
      q : Queue(TCN) := empty()

      -- initial run => fill up the queue with nodes that aren't done yet
      for n in entries x.nodes repeat 
        --BUG: Each rule attached to a node has to be applied at least once!
        --checkAndMarkIfDone! n
        if not done? n then
          enqueue!(n, q)

      p := countProgress x
      s := 1 :: NNI

      while p.a > 0 or p.b > 0 repeat
        newQ : Queue(TCN) := empty()

        step := paren (s :: PF)

        ++ perform meta-step
        while not empty? q repeat
          n := dequeue! q
          done? n => "iterate"

          --debug([step, "Queue state" :: PF, "=>" :: PF, number(n.index) :: PF, ":" :: PF,
          --       bracket [number(m.index) :: PF for m in members q]])

          not inferType(n, x) =>
            for n' in entries x.nodes repeat
              rewriteIfInferred!(n', x)
            fail pile([spaces ["Type error for node:" :: PF, number(n.index) :: PF],
                       red(n.node :: PF)])
            debug (x :: PF)
            debug (x.typevars :: PF)
            return false

          ++ check if we're done with processing type variable tied to this node
          rewriteIfInferred!(n, x)

          ++ if type is inferred for all dependencies the node itself won't change
          if checkAndMarkIfDone! n then
            debug ["Processing node" :: PF, number(n.index) :: PF, "completed!" :: PF]
          else
            enqueue!(n, newQ)

        ++ check if during meta-step the problem was reduced compared to
        ++ previous meta-step
        newP := countProgress x
        correct :=
          newP.a < p.a => true
          newP.a = p.a and newP.b < p.b => true
          false
        not correct =>
          fail ("Type checker does not advance by applying known typing rules!" :: PF)
          debug (x :: PF)
          debug (x.typevars :: PF)
          error ""

        ++ setup new meta-step
        p := newP
        q := newQ
        s := s + 1

      info (x :: PF)
      true

)abbrev package STYPCHK SpadTypeChecker
SpadTypeChecker() : Exports == Implementation where
  N ==> SpadNode
  APP ==> SpadApply(N)
  ASS ==> SpadAssign(N)
  CE ==> SpadCondExpr(N)
  FN ==> SpadFunction(N)
  FT ==> SpadFunctor(N)
  IM ==> SpadImport(N)
  LAM ==> SpadLambda(N)
  IT ==> SpadIterator(N)
  LP ==> SpadLoop(N)
  M ==> SpadMacro(N)
  MT ==> SpadMappingType(N)
  NT ==> SpadNamedType(N)
  RT ==> SpadRecordType(N)
  SEG ==> SpadSegment(N)
  SEQ ==> SpadSequence(N)
  ST ==> SpadSumType(N)
  TE ==> SpadTypeExpr(N)
  UT ==> SpadUnionType(N)
  W ==> SpadWhere(N)
  MR ==> SpadMarker(N)

  NNI ==> NonNegativeInteger
  ENV ==> SpadEnvironment
  TCN ==> TCNode
  CTX ==> TCNodeArray
  SUBST ==> AssociationList(MR, List(N))
  PF ==> PrintableForm
  R ==> Record(node : N, env : ENV)
  RS ==> Record(nodes : List(N), env : ENV)

  Exports ==> with
    walk : (N, CTX, ENV) -> R

  Implementation ==> add
    import SpadEnvironment
    import SExpression
    import String
    import Symbol
    import TCNode
    import SpadNode
    import SpadNodeFactory
    import Printer
    import PrintableForm
    import TypeUnifier
    import Logger('AST)

    addChildren : (TCN, List(N), CTX, ENV) -> RS
    addChildren (parent, nodes, ctx, env) ==
      nl : List(N) := []
      cl : List(TCN) := []
      for n in nodes repeat
        i := lastIndex ctx + 1
        r := walk(n, ctx, env)
        env := r.env
        nl := [r.node, :nl]
        cl := [node(i, ctx), :cl]
      parent.children := concat(parent.children, reverse cl)
      [reverse nl, env]

    envAddType : (N, ENV) -> ENV
    envAddType (t, env) ==
      notice ["Adding type" :: PF, bold(t :: PF), "to the environment." :: PF]
      if apply? t then
        app := t :: APP
        env := addDomain(app, env)
        for k in app.args repeat
          env := envAddType(k, env)
      if mappingType? t then
        mt := t :: MT
        for k in [mt.type, :mt.args] repeat
          env := envAddType(k, env)
      if recordType? t then
        r := t :: RT
        for f in r.fields repeat
          env := envAddType(f.type, env)
        for f in makeRecordFunList t repeat
          mt := (f :: NT).type :: MT
          env := addModemap(f.name, t, [mt.type, :mt.args], env)
      env

    walkApp : (APP, CTX, ENV) -> R
    walkAssign : (ASS, CTX, ENV) -> R
    walkCondExpr : (CE, CTX, ENV) -> R
    walkFun : (FN, CTX, ENV) -> R
    walkFtor : (FT, CTX, ENV) -> R
    walkImport : (IM, CTX, ENV) -> R
    walkLambda : (LAM, CTX, ENV) -> R
    walkLoop : (LP, CTX, ENV) -> R
    walkSeg : (SEG, CTX, ENV) -> R
    walkSeq : (SEQ, CTX, ENV) -> R
    walkSym : (Symbol, CTX, ENV) -> R
    walkTypeExpr : (TE, CTX, ENV) -> R
    walkInt : (Integer, CTX, ENV) -> R
    walkFlt : (DoubleFloat, CTX, ENV) -> R
    walkStr : (String, CTX, ENV) -> R

    walkApp (a, ctx, env) ==
      if symbol? a.function then
        fn := a.function :: Symbol
        if fn = 'QUOTE then
          addNode!([a], symbolType, ctx)
          return [[a], env]
        mode := getMode(fn, env)
        if recordType? mode then
          eltNode := nodeApp(['elt], [a.function, :a.args])
          debug ["Rewrote" :: PF, bold(a :: PF), "to" :: PF, bold(eltNode :: PF), "!" :: PF]
          env := envAddType(mode, env)
          ++ hack that adds record field as a type singleton to the environment
          for sym in a.args | symbol? sym repeat
            env := addMode(sym :: Symbol, sym, env)
          return walk(eltNode, ctx, env)

      debug ["Processing function application." :: PF]
      node := addNode!([a], ctx)
      rs := addChildren(node, [a.function, :a.args], ctx, env)
      ns := [nodeRef(n.index) for n in node.children]
      node.rule := nodeApp(first ns, rest ns)
      fun := first rs.nodes
      args := rest rs.nodes
      if symbol? fun then
        s := fun :: Symbol
        if s = 'return or s = 'error then
          return [nodeApp(fun, args), rs.env]
        fun := nodeTypeExpr('_$, fun, ns.1)
      [nodeTypeExpr('_@, nodeApp(fun, args), nodeRef(node.index)), rs.env]

    walkAssign (a, ctx, env) ==
      typeExpr? a.lval => ++ handle "symbol : Type := value"
        te := a.lval :: TE
        r := walkTypeExpr(te, ctx, env) -- add to context
        te := r.node :: TE
        r := walk(nodeAssign(te.expr, a.rval), ctx, r.env)
        a := r.node :: ASS
        [nodeAssign(nodeTypeExpr('_:, a.lval, te.type), a.rval), r.env]

      if apply? a.lval then
        app := a.lval :: APP
        fn := app.function :: Symbol
        mode := getMode(fn, env)
        if recordType? mode then
          eltNode := nodeApp(['setelt!], [app.function, :app.args, a.rval])
          debug ["Rewrote" :: PF, bold(a :: PF), "to" :: PF, bold(eltNode :: PF), "!" :: PF]
          env := envAddType(mode, env)
          ++ hack that adds record field as a type singleton to the environment
          for sym in app.args | symbol? sym repeat
            env := addMode(sym :: Symbol, sym, env)
          return walk(eltNode, ctx, env)
      
      type := addTypeVar! ctx
      intro := false

      if symbol? a.lval then
        s := a.lval :: Symbol
        if emptyNode? getMode(s, env) then
          debug ["Processing fresh assignment" :: PF, string(s :: PF)]
          env := addMode(s, addTypeVar! ctx, env)
          intro := true
        
      assignNode := addNode!([a], type, ctx)
      i1 := lastIndex ctx + 1
      r1 := walk(a.lval, ctx, env)
      i2 := lastIndex ctx + 1
      r2 := walk(a.rval, ctx, env)
      assignNode.children := [node(i1, ctx), node(i2, ctx)]
      assignNode.rule := nodeAssign(nodeRef(i1), nodeRef(i2))

      ++ Only left-value environment is propagated!
      lval :=
        not intro => r1.node
        nodeTypeExpr('_:, r1.node, nodeRef(i1))
      [nodeAssign(lval, r2.node), r1.env]

    walkCondExpr (ce, ctx, env) ==
      debug ["Processing conditional expression." :: PF]
      exprNode := addNode!([ce], ctx)
      i1 := lastIndex ctx + 1
      r1 := walk(ce.cond, ctx, env)
      i2 := lastIndex ctx + 1
      r2 := walk(ce.truebr, ctx, r1.env)
      i3 := lastIndex ctx + 1
      r3 := walk(ce.falsebr, ctx, r1.env)
      exprNode.children := [node(i1, ctx), node(i2, ctx), node(i3, ctx)]
      exprNode.rule := nodeCondExpr(nodeRef(i1), nodeRef(i2), nodeRef(i3))
      ++ TODO: "r2.env" and "r3.env" should be merged and passed forward
      ++ instead of just "env". Merging means that if the same variable was
      ++ introduced in both branches then it should be present in the final
      ++ environment.
      [nodeCondExpr(r1.node, r2.node, r3.node), env]

    walkFun (fn, ctx, env) ==
      debug ["Processing function" :: PF, string(fn.name :: PF)]

      fnNode := addNode!([fn], ctx)

      sig := (signature fn).type
      name := funsig(fn.name, #fn.args)

      -- fetch signatures from domain's definition
      mappings : List(N) := [[mm.type] for mm in getModemap(fn.name, env)]
      info(["Found" :: PF, string bold(name :: PF), "with signatures :" :: PF,
            bold bracket [t :: PF for t in mappings]])

      -- signature associated with function definition
      mt := sig :: MT
      debug ["Signature associated with function definition :" :: PF, mt :: PF]

      -- prepare function signature for unification
      types : List(N) := []
      for type in [mt.type, :mt.args] for i in 1.. repeat
        if emptyNode? type then
          type := typeVar(i)
        types := [type, :types]
      types := reverse types
      sig := nodeMappingType(rest types, first types)

      -- calculate eligible signatures
      sigs : List(MT) := []
      for m in mappings repeat
        ures := unifyType(sig, m)
        failed? ures => "iterate"
        sigs := [substitute(sig, ures :: SUBST) :: MT, :sigs]
      sigs := reverse sigs

      empty? sigs =>
        fail ("No signature corresponding to the function!" :: PF)
        error ""

      debug ["Eligible signatures :" :: PF, brace [sig :: PF for sig in sigs]]

      -- try to check type for each eligible signature
      for mt in sigs repeat
        info ["Assume" :: PF, name :: PF, "has type :" :: PF, mt :: PF]

        args' : List(N) := []
        env' := envAddType([mt], env)
        for arg in fn.args for argType in mt.args repeat
          argName := (arg :: NT).name
          args' := [nodeNamedType(argName, argType), :args']
          env' := addMode(argName, argType, env')
        args' := reverse args'

        ctx' := nodeArray ctx
        bodyNode := addNode!([mt], mt.type, ctx')
        r := walk(fn.body, ctx', env')
        bodyNode.rule := nodeRef(bodyNode.index + 1)
        bodyNode.children := [node(bodyNode.index + 1, ctx')]

        debug ["Tree ready for unification :" :: PF]
        debug [ctx' :: PF]

        if check ctx' then
          ts := types ctx'
          fnBody := rewrite(r.node)$SpadTreeFillInTypes(ts)
          fnNode.type := [mt]
          return [nodeFun(fn.name, args', mt.type, fnBody), env]

      fail (["No matching signatures for function" :: PF, string bold(fn.name :: PF),
             "found!" :: PF, pile ["Candidates were:" :: PF, :[mt :: PF for mt in sigs]]])
      error ""

    walkFtor (ft, ctx, env) ==
      sig := signature ft
      debug ["Processing functor :" :: PF, sig :: PF]
      self := "$" :: Symbol
      env := addMode(sig.name, sig.type, env)
      env := addMode(self, ft.type, env)
      env := addModemapsFromCategory([self], ft.type, env)

      ++ process functor's arguments
      cat := nodeApp(['Category], [])
      for arg in ft.args repeat
        typ := arg.type :: APP
        env := addModemap(typ.function :: Symbol, [typ], [cat], env)
        env := addMode(arg.name, arg.type, env)
        env := addModemapsFromCategory([arg.name], arg.type, env)

      ftor := addNode!([ft], sig.type, ctx)
      r := walk(ft.capsule, ctx, env)
      ftor.rule := nodeRef(ftor.index + 1)
      ftor.children := [node(ftor.index + 1, ctx)]

      ext := if emptyNode? ft.extends then ['Type] else ft.extends
      [nodeFtor(ft.name, ft.args, ft.type, ext, r.node), env]

    walkImport (im, ctx, env) ==
      debug ["Importing" :: PF, im.type :: PF]
      env := envAddType(im.type, env)
      addNode!([im], voidType, ctx)
      [[im], env]

    walkLambda (lam, ctx, env) ==
      ++ replace unknown types with type variables and add arguments
      ++ to the environment
      argTypes : List(N) := []
      for arg in lam.args repeat
        argType := (emptyNode? arg.type => addTypeVar! ctx; arg.type)
        argTypes := [argType, :argTypes]
        env := addMode(arg.name, argType, env)
      retType := (emptyNode? lam.type => addTypeVar! ctx; lam.type)
      lamType : MT := [reverse argTypes, retType]
      debug ["Lambda expression of type" :: PF, bold(lamType :: PF)]
      ++ add a node with type of the lambda expression just for dependants
      addNode!([lam], [lamType], ctx)
      ++ generate nodes for all types that were assigned type variables
      ++ and prepare lambda's arguments to be filled out in final phase
      args : List(NT) := []
      for argType in argTypes for arg in lam.args repeat
        typeVar? argType =>
          node := addNode!([arg.name], argType, ctx)
          args := [[arg.name, nodeRef(node.index)]$NT, :args]
        args := [arg, :args]
      ++ finally, generate a node with result type
      lamBody := addNode!(emptyNode(), retType, ctx)
      r := walk(lam.body, ctx, env)
      lamBody.rule := nodeRef(lamBody.index + 1)
      lamBody.children := [node(lamBody.index + 1, ctx)]
      [nodeLambda(reverse args, nodeRef(lamBody.index), r.node), env]

    walkLoop (lp, ctx, env) ==
      debug ["Loop statement." :: PF]
      env' := env
      type : N

      loopNode :=
        lp.kind case "collect" =>
          type := addTypeVar! ctx
          addNode!([lp], nodeApp(['List], [type]), ctx)
        addNode!([lp], voidType, ctx)

      debug ["Processing" :: PF, #(lp.itors) :: PF, "iterator(s)." :: PF]
      nItors : List(IT) := []
      for itor in lp.itors repeat
        itorVar := addNode!([itor.var], ctx)
        seqType : List(N) :=
          [nodeApp(['List], [itorVar.type]),
           nodeApp(['UniversalSegment], [itorVar.type])]
        itorSeq := addNode!(itor.seq, seqType, ctx)
        r := walk(itor.seq, ctx, env)
        itorSeq.rule := nodeRef(itorSeq.index + 1)
        itorSeq.children := [node(itorSeq.index + 1, ctx)]
        ++ iterator variable is added to loop's body environment,
        ++ but is also known to guards
        env' := addMode(itor.var, itorVar.type, env')
        nItors := concat(nItors, [itor.var, r.node]$IT)
        loopNode.children := concat(loopNode.children, [itorVar, itorSeq])

      debug ["Processing" :: PF, #(lp.guards) :: PF, "guard(s)." :: PF]
      nGuards : List(N) := []
      for guard in lp.guards repeat
        guardNode := addNode!(guard, booleanType, ctx)
        r := walk(guard, ctx, env')
        guardNode.rule := nodeRef(guardNode.index + 1)
        guardNode.children := [node(guardNode.index + 1, ctx)]
        nGuards := concat(nGuards, r.node)
        loopNode.children := concat(loopNode.children, guardNode)
        ++ Guard may introduce a variable and it must be visible in loop's body!
        env' := r.env

      debug ["Processing loop body." :: PF]
      if lp.kind case "collect" then
        loopBody := addNode!(emptyNode(), type, ctx)
        r := walk(lp.body, ctx, env')
        loopBody.rule := nodeRef(loopBody.index + 1)
        loopBody.children := [node(loopBody.index + 1, ctx)]
        loopNode.children := concat(loopNode.children, loopBody)
      else
        i := lastIndex ctx + 1
        r := walk(lp.body, ctx, env')
        loopNode.children := concat(loopNode.children, node(i, ctx))
      [nodeLoop(lp.kind, nItors, nGuards, r.node), env]

    walkSeg (seg, ctx, env) ==
      debug ["Processing segment:" :: PF, string(seg :: PF)]
      segType := addTypeVar! ctx
      segNode := addNode!([seg], nodeApp(['UniversalSegment], [segType]), ctx)
      segChildren : List(TCN) := []

      segStart := addNode!(emptyNode(), segType, ctx)
      (newStart, env') := walk(seg.start, ctx, env)
      segStart.rule := nodeRef(segStart.index + 1)
      segStart.children := [node(segStart.index + 1, ctx)]
      segNode.children := [segStart]

      newEnd := seg.end
      if not emptyNode? seg.end then
        segEnd := addNode!(emptyNode(), segType, ctx)
        (newEnd, env') := walk(seg.end, ctx, env)
        segEnd.rule := nodeRef(segEnd.index + 1)
        segEnd.children := [node(segEnd.index + 1, ctx)]
        segNode.children := concat(segNode.children, segEnd)

      newStep := seg.step
      if not emptyNode? seg.step then
        segStep := addNode!(emptyNode(), integerType, ctx)
        (newStep, env') := walk(seg.step, ctx, env)
        segStep.rule := nodeRef(segStep.index + 1)
        segStep.children := [node(segStep.index + 1, ctx)]
        segNode.children := concat(segNode.children, segStep)

      [nodeSeg(newStart, newEnd, newStep), env]

    walkSeq (s, ctx, env) ==
      debug ["Found sequence of" :: PF, #(s.list) :: PF, "expressions." :: PF]
      node := addNode!([s], ctx)
      rs := addChildren(node, s.list, ctx, env)
      node.rule := nodeRef((last node.children).index)
      [nodeSeq(s.kind, rs.nodes), rs.env]

    walkSym (s, ctx, env) ==
      debug ["Symbol lookup for" :: PF, string(s :: PF)]
      -- types : List(N) := [[mm.type] for mm in getModemap(s, env)]
      types := [nodeTypeExpr('_$, [mm.type], mm.origin) for mm in getModemap(s, env)]
      mode := getMode(s, env)
      if not emptyNode? mode then
        types := [mode, :types]
      ++ BUG: parseTran use true and false as "Boolean" and not as "() -> Boolean"
      ++ workaround for Boolean constants
      if s = 'true or s = 'false then
        types := [booleanType, :types]
      if s = 'error then
        errorType := nodeMappingType([stringType], typeAny)
        types := [errorType, :types]
      if s = 'return then
        returnType := nodeMappingType([integerType, node(1, ctx).type], typeAny)
        types := [returnType, :types]
      empty? types =>
        fail ["Undefined symbol:" :: PF, bold red string (s :: PF), "!" :: PF]
        error ""
      if #types = 1
        then addNode!([s], first types, ctx)
        else addNode!([s], types, ctx)
      info(["Found" :: PF, string bold(s :: PF), "with type :" :: PF,
            bold bracket [t :: PF for t in types]])
      [[s], env]

    walkTypeExpr (te, ctx, env) ==
      te.kind = '_: => 
        debug ["Expression" :: PF, te.expr :: PF, "has type" :: PF, te.type :: PF]

        not symbol? te.expr =>
          fail ["Type annotation works only for symbols!" :: PF]
          error ""

        -- type definition for a symbol:
        -- add it to the environment or crash if already defined
        s := te.expr :: Symbol
        not emptyNode? getMode(s, env) =>
          warn([bold yellow ("Warning!" :: PF), "Symbol" :: PF, string(s :: PF),
                "already defined as" :: PF, getMode(s, env) :: PF, "!" :: PF])
          [[te], env]

        addNode!([te], te.type, ctx)
        env := addMode(s, te.type, env)
        [[te], env]

      te.kind = '_@ =>
        debug (["[*]" :: PF, "Expression" :: PF, te.expr :: PF,
                 "has to return type" :: PF, te.type :: PF])

        not apply? te.expr =>
          fail ["Type cut operator works only for function application!" :: PF]
          error ""

        env := envAddType(te.type, env)
        next := lastIndex ctx + 1
        r := walk(te.expr, ctx, env)
        setType!(node(next, ctx), te.type, ctx)
        [nodeTypeExpr(te.kind, r.node, te.type), r.env]

      te.kind = '_:_: =>
        debug ["Expression" :: PF, te.expr :: PF, "have to coerce to" :: PF, te.type :: PF]
        i := lastIndex ctx + 1
        -- convert "::" to "coerce" function call
        r := walk(nodeApp(['coerce], [te.expr]), ctx, env)
)if 0
        -- conversion above almost works, but we need to fix it for identity
        -- coercion by infusing artificial signature "%a -> %a" which is not
        -- always available
        coerceNode := node(i, ctx)
        argType := coerceNode.children.2.type
        idFunType := nodeMappingType([argType], argType)
        addType!(coerceNode.children.1, idFunType, ctx)
)endif
        [nodeTypeExpr(te.kind, r.node, te.type), r.env]
    
      te.kind = '_$ =>
        not symbol? te.expr =>
          fail ("Type origin selector works only for symbols!" :: PF)
          error ""

        debug(["Symbol" :: PF, string(te.expr :: PF),
               "must originate from" :: PF, bold(te.type :: PF),
               "type!" :: PF])

        originNode := addNode!([te], ctx)
        env := envAddType(te.type, env)
        i := lastIndex ctx + 1
        r := walk(te.expr, ctx, env)
        originNode.rule := nodeTypeExpr('_$, nodeRef(i), te.type)
        originNode.children := [node(i, ctx)]
        [r.node, r.env]

      fail ["Type expression" :: PF, bold red paren(te :: PF), "not handled yet!" :: PF]
      error ""

    walkInt (i, ctx, env) ==
      debug [i :: PF, "is" :: PF, integerType :: PF, ":)" :: PF]
      addNode!([i], integerType, ctx)
      [[i], env]

    walkFlt (f, ctx, env) ==
      debug [f :: PF, "is" :: PF, floatType :: PF, ":)" :: PF]
      addNode!([f], floatType, ctx)
      [[f], env]

    walkStr (s, ctx, env) ==
      debug [string(s :: PF), "is" :: PF, stringType :: PF, ":)" :: PF]
      addNode!([s], [[string(s :: Symbol)], stringType], ctx)
      [[s], env]

    walk (n : N, ctx : CTX, env : ENV) : R ==
      apply? n => walkApp(n :: APP, ctx, env)
      assign? n => walkAssign(n :: ASS, ctx, env)
      condExpr? n => walkCondExpr(n :: CE, ctx, env)
      float? n => walkFlt(n :: DoubleFloat, ctx, env)
      functor? n => walkFtor(n :: FT, ctx, env)
      import? n => walkImport(n :: IM, ctx, env)
      integer? n => walkInt(n :: Integer, ctx, env)
      lambda? n => walkLambda(n :: LAM, ctx, env)
      loop? n => walkLoop(n :: LP, ctx, env)
      segment? n => walkSeg(n :: SEG, ctx, env)
      sequence? n => walkSeq(n :: SEQ, ctx, env)
      string? n => walkStr(n :: String, ctx, env)
      symbol? n => walkSym(n :: Symbol, ctx, env)
      typeExpr? n => walkTypeExpr(n :: TE, ctx, env)
      function? n => walkFun(n :: FN, ctx, env)
      -- namedType, mappingType, recordType, sumType, unionType, macro, where
      emptyNode? n =>
        addNode!(n, voidType, ctx)
        [n, env]
      fail ["Expression" :: PF, bold red paren(n :: PF), "not handled yet!" :: PF]
      error ""
