)abbrev domain TCRULE TypeCheckerRule
TypeCheckerRule() : Exports == Implementation where
  N ==> SpadNode
  CE ==> SpadCondExpr(N)
  MR ==> SpadMarker(N)

  PF ==> PrintableForm
  NNI ==> NonNegativeInteger

  Exports ==> CoercibleTo(PrintableForm) with
    newRule : () -> %
    newRule : (List(N), N) -> %

    empty? : % -> Boolean
    entries : % -> List(N)
    children : % -> List(NNI)
    children : List(%) -> List(NNI)

    elt : (%, "deps") -> List(N)
    elt : (%, "result") -> N

    setelt! : (%, "deps", List(N)) -> List(N)

  Implementation ==> add
    Rep := Record(r_deps : List(N), r_result : N)

    newRule () == [[], emptyNode()]$Rep
    newRule (deps, res) == [deps, res]$Rep

    empty? x == empty? x.r_deps
    entries x == x.r_deps

    children (x : %) : List(NNI) ==
      [(c :: MR).id for c in x.r_deps | nodeRef? c]

    children (lx : List(%)) : List(NNI) ==
      empty? lx => []
      -- BUG? Parser requires parens around reduce expression.
      removeDuplicates("concat"/[children x for x in lx])

    elt (x, "deps") == x.r_deps
    elt (x, "result") == x.r_result

    setelt!(x, "deps", l) ==
      x.r_deps := l

    coerceSubRule (r : N) : PF ==
      condExpr? r =>
        ce := r :: CE
        spaces(["if" :: PF, ce.cond :: PF,
                "then" :: PF, ce.truebr :: PF,
                "else" :: PF, ce.falsebr :: PF])
      r :: PF

    coerce x ==
      brace [coerceSubRule c for c in x.r_deps]

)abbrev domain TCNODE TypeCheckerNode
TypeCheckerNode() : Exports == Implementation where
  PF ==> PrintableForm
  NNI ==> NonNegativeInteger
  ENV ==> SpadEnvironment
  N ==> SpadNode
  MR ==> SpadMarker(N)
  TE ==> SpadTypeExpr(N)
  FN ==> SpadFunction(N)
  UT ==> SpadUnionType(N)
  SUBST ==> AssociationList(MR, List(N))
  TCR ==> TypeCheckerRule

  Exports ==> CoercibleTo(PrintableForm) with
    elt : (%, "index") -> NNI
    elt : (%, "node") -> N
    elt : (%, "rules") -> List(TCR)
    elt : (%, "type") -> N
    elt : (%, "env") -> ENV
    elt : (%, "done") -> Boolean

    setelt! : (%, "rules", List(TCR)) -> List(TCR)
    setelt! : (%, "type", N) -> N
    setelt! : (%, "node", N) -> N
    setelt! : (%, "env", ENV) -> ENV
    setelt! : (%, "done", Boolean) -> Boolean

    construct : (NNI, N) -> %
    substitute! : (SUBST, %) -> Void
    done? : % -> Boolean

    children : % -> List(NNI)

    nodeRef : % -> N
    typeRef : % -> N

  Implementation ==> add
    Rep := Record(ni_index : NNI,
                  ni_node : N,
                  ni_rules : List(TCR),
                  ni_type : N,
                  ni_env : ENV,
                  ni_done : Boolean)

    import SpadNode
    import Printer
    import TypeUnifier
    import SpadNodeFactory

    elt (x, "index") == x.ni_index
    elt (x, "node") == x.ni_node
    elt (x, "rules") == x.ni_rules
    elt (x, "type") == x.ni_type
    elt (x, "env") == x.ni_env
    elt (x, "done") == x.ni_done

    setelt! (x, "node", n) ==
      x.ni_node := n
    setelt! (x, "rules", r) ==
      x.ni_rules := r
    setelt! (x, "type", ts) ==
      x.ni_type := ts
    setelt! (x, "env", env) ==
      x.ni_env := env
    setelt! (x, "done", d) ==
      x.ni_done := d

    construct (i, n) ==
      [i, n, [], emptyNode(), new(), false] $ Rep

    substitute! (subst, x) ==
      x.type := substitute(x.type, subst)

    done? x ==
      x.ni_done

    children x ==
      children x.rules

    nodeRef x ==
      nodeRef x.index

    typeRef x ==
      typeVar x.index

    coerce x ==
      done := if done? x then green("(+)" :: PF) else red("(-)" :: PF)
      prefix := hconcat [done, right(4, number(x.index) :: PF)]
      not empty? x.rules =>
        r := sepBy(" | " :: PF, [(r :: PF) for r in x.rules])
        spaces([prefix, r, "is" :: PF, bold (x.type :: PF)])
      n :=
        typeOrigin? x.node or typeDecl? x.node => (x.node :: TE).expr
        x.node
      node :=
        value? n or typeVar? n =>
          bold(n :: PF)
        function? n =>
          bold cyan((n :: FN).name :: PF)
        bold ("?" :: PF)
      import? n =>
        spaces [prefix, "import" :: PF, bold (x.type ::PF)]
      spaces [prefix, node, ":" :: PF, bold (x.type :: PF)]

)abbrev package STFITS SpadTreeFillInTypes
SpadTreeFillInTypes(ns : List(TypeCheckerNode)) : SpadTreeWalkerCategory == Implementation where
  PF ==> PrintableForm
  N ==> SpadNode
  APP ==> SpadApply(N)
  TE ==> SpadTypeExpr(N)
  NNI ==> NonNegativeInteger

  Implementation ==> add
    import Logger('Fill)

    rewrite (te : TE) : N ==
      te := [te.kind, rewrite te.expr, rewrite te.type]$TE
      not te.kind = '_$ => [te]
      symbol? te.type and (te.type :: Symbol) = ("%" :: Symbol) => te.expr
      typeAny? te.type => te.expr
      mappingType? te.type => te.expr
      [te]

    rewrite (app : APP) : N ==
      ++ WORKAROUND! Remove origin qualifier from first argument of implicit
      ++ call to 'elt' added in walkApp $ SpadTypeChecker.
      if typeExpr? app.function then
        fun := app.function :: TE
        if fun.expr = ['elt] and #app.args > 0 then
          arg := app.args.1
          typeExpr? arg and (arg :: TE).kind = '_$ =>
            arg := (arg :: TE).expr
            return nodeApp(rewrite app.function, 
                           cons(rewrite arg, [rewrite a for a in rest app.args]))
      nodeApp(rewrite app.function, [rewrite a for a in app.args])

    rewrite (mr : SpadMarker(N)) : N ==
      mr.kind = 'typevar =>
        t := ns(mr.id).type
        typeOrigin? t =>
          te := coerce(t)@TE
          typeOrigin? te.type =>
            te' := coerce(te.type)@TE
            te'.type
          te.type
        t
      mr.kind = 'noderef =>
        rewrite ns(mr.id).node
      error ""

)abbrev package TCNA TypeCheckerNodeArray
TypeCheckerNodeArray() : Exports == Implementation where
  NNI ==> NonNegativeInteger
  TCN ==> TypeCheckerNode
  N ==> SpadNode
  APP ==> SpadApply(N)
  ASS ==> SpadAssign(N)
  CE ==> SpadCondExpr(N)
  ENV ==> SpadEnvironment
  MT ==> SpadMappingType(N)
  MR ==> SpadMarker(N)
  TE ==> SpadTypeExpr(N)
  SEQ ==> SpadSequence(N)
  UT ==> SpadUnionType(N)
  SUBST ==> AssociationList(MR, List(N))
  URES ==> Union(SUBST, "failed")
  TCR ==> TypeCheckerRule
  PF ==> PrintableForm

  Exports ==> CoercibleTo(PrintableForm) with
    nodeArray : () -> %

    addNode! : (%, N) -> TCN
    addNode! : (%, N, ENV) -> TCN
    addTypeVar! : % -> N
    addTypeVar! : (%, List(N)) -> N
    addType! : (MR, N, %) -> Void

    nodes : % -> List(TCN)

    checkAndMarkIfDone! : (TCN, %) -> Boolean

    coerce : SUBST -> PF
    check : % -> Boolean

  Implementation ==> add
    Rep := Record(nodes : FlexibleArray(TCN),
                  counter : NNI,
                  typevars : AssociationList(MR, List(N)))

    import String
    import TypeCheckerRule
    import TypeCheckerNode
    import SpadNode
    import TypeUnifier
    import SpadNodeFactory
    import Printer
    import Logger('Type)

    nodeArray () ==
      [flexibleArray [], 0, [[]]]

    coerceTypeVar (tvar : MR, types : List(N)) : PF ==
        ts :=
          #types = 1 => (first types) :: PF
          bracket [t :: PF for t in types]
        spaces [right(4, tvar :: PF), ":" :: PF, ts]

    coerce (typevars : AssociationList(MR, List(N))) : PF ==
      tvs := [coerceTypeVar(tv.key, tv.entry) for tv in reverse entries typevars]
      empty? tvs => "No type variables!" :: PF
      pile ["Type variables :" :: PF, :tvs]

    coerce (x : %) : PF ==
      pile ["Nodes :" :: PF, :[ni :: PF for ni in entries x.nodes]]

    addNode! (x, n, env) ==
      ni := addNode!(x, n)
      ni.env := env
      ni

    addNode! (x, n) ==
      ni := [#(x.nodes) + 1, n]
      concat!(x.nodes, ni)
      ni

    addTypeVar! (x, types) ==
      empty? types => addTypeVar!(x)
      x.counter := x.counter + 1
      tvar := typeVar(x.counter)
      (x.typevars)(tvar :: MR) := types
      tvar

    addTypeVar! (x) ==
      x.counter := x.counter + 1
      tvar := typeVar(x.counter)
      (x.typevars)(tvar :: MR) := [emptyNode()]
      tvar

    node (i : NNI, x : %) : TCN ==
      (x.nodes)(i)

    nodes x ==
      entries x.nodes

    emptyType? (terms : List(N)) : Boolean ==
      #terms = 1 and emptyNode?(first terms)

    aliasType? (terms : List(N)) : Boolean ==
      #terms = 1 and typeVar?(first terms)

    addType! (var, type, x) ==
      terms := (x.typevars)(var)
      emptyType? terms => error ""
      (x.typevars)(var) := [type, :(x.typevars)(var)]

    fetch (n : N, x : %) : List(N) ==
      not typeVar? n => [n] 
      nl := (x.typevars)(n :: MR)
      emptyType? nl => [n]
      nl

    unknownType? (n : TCN, x : %) : Boolean ==
      ++ checks if type attached to the node has form "%a[?]"
      not typeVar? n.type => false
      emptyType?((x.typevars)(n.type :: MR))

    killNode!(n : TCN, x : %) : Void ==
      info ["Killing" :: PF, number(n.index) :: PF, "node!" :: PF]
      n.done := true
      if typeVar? n.type then
        remove!(n.type :: MR, x.typevars)
        n.type := typeUndef()

    checkAndMarkIfDone! (n, x) ==
      unbound? n.type => false
      empty? n.rules =>
        n.done := true
      ++ We only care about first rule, because it produced actual result.
      rule := first n.rules
      "or"/[unbound? node(j, x).type for j in children rule] => false
      ++ Remove leftovers from other alternative rules.
      for victim in setDifference(children n.rules, children rule) repeat
        killNode!(node(victim, x), x)
      n.node := rule.result
      n.done := true

    rewriteTypevars! (var : MR, term : N, x : %) : Void ==
      debug(["Rewriting" :: PF, bold(var :: PF), "to" :: PF, bold(term :: PF),
             "in all type variables." :: PF])
      for tv in entries x.typevars | not emptyType? tv.entry repeat
        ts : List(N) := []
        for t in tv.entry repeat
          t := substitute(t, var, term)
          ++ Remove duplicates.
          member?(t, ts) => "iterate"
          ++ Avoid ill-formed types (for now only unions).
          emptyNode? t => "iterate"
          ts := [t, :ts]
        tv.entry := reverse ts

    -- rewrite all nodes with type that contains given variable
    rewriteNodes! (var : MR, term : N, x : %) : Void ==
      for n in nodes(x) | occurs?(var, n.type) repeat
        n.type := substitute(n.type, var, term)
        debug (["Rewrote" :: PF, number(n.index) :: PF, "with" :: PF,
                brace spaces [var :: PF, "=>" :: PF, term :: PF]])

    rewriteIfInferred! (n : TCN, x : %) : Boolean ==
      not typeVar? n.type => false
      var := n.type :: MR
      terms := (x.typevars)(var)
      emptyType? terms or #terms > 1 => false
      term := first terms
      rewriteTypevars!(var, term, x)
      debug ["Removing" :: PF, bold(var :: PF), "type variable." :: PF]
      remove!(var, x.typevars)
      info (["Type inferred for node" :: PF, number(n.index) :: PF,
             ":" :: PF, bold(term :: PF)])
      rewriteNodes!(var, term, x)
      true

    removeAlias! (var : MR, alias : N, x : %) : Void ==
      var = (alias :: MR) => void() ++ BUG? Handle degenerate case!
      debug ["Removing alias:" :: PF, var :: PF, "=>" :: PF, alias :: PF]
      rewriteTypevars!(var, alias, x)
      for n in entries(x.nodes) | occurs?(var, n.type) repeat
        n.type := substitute(n.type, var, alias)
        debug (["Rewrote" :: PF, number(n.index) :: PF, "with" :: PF,
                brace spaces [var :: PF, "=>" :: PF, alias :: PF]])
      debug ["Removing" :: PF, bold(var :: PF), "type variable." :: PF]
      remove!(var, x.typevars)

    applyOne! (var : MR, terms : List(N), x : %) : Boolean ==
      debug(["Modyfing" :: PF, bold(var :: PF), "type variable with" :: PF,
             bracket [bold(t :: PF) for t in terms]])
      typevars := x.typevars
      -- 1) typevars(%x) = [?]
      emptyType? typevars(var) =>
        -- a) %x = %y => alias removal
        -- b) %x = [t1, t2, t3, ...]
        if aliasType? terms
          then removeAlias!(var, first terms, x)
          else typevars(var) := terms
        true
      -- 2) typevars(%x) = [s1, s2, s3, ...], %x = [t1, t2, t3, ...]
      -- Unify proposed values with already stored in the variable
      -- store only matching ones (without performing substitutions).
      ms := findMatches(typevars(var), terms)
      not empty? ms.terms =>
        typevars(var) := ms.terms
        true
      -- Unification failed, as a last resort use subtyping.
      for term in terms repeat
        for t in typevars(var) repeat
          if not isSubType(t, term) then
            return false
      typevars(var) := terms
      true

    apply! (substitutions : SUBST, x : %) : Boolean ==
      empty? substitutions => true
      "and"/[applyOne!(s.key, s.entry, x) for s in entries substitutions]

    nodesTypeMatch! (ln : TCN, rn : TCN, x : %) : Boolean ==
      ++ %a[?] ~ %b[?]
      unknownType?(ln, x) and unknownType?(rn, x) =>
        ures := unifyType(ln.type, rn.type)
        failed? ures => false
        apply!(ures :: SUBST, x)
      ++ %a[?] ~ (%b[t1, t2, ...] | T)
      unknownType?(ln, x) and not unknownType?(rn, x) =>
        applyOne!(ln.type :: MR, [rn.type], x)
      ++ (%a[t1, t2, ...] | T) ~ %b[?]
      not unknownType?(ln, x) and unknownType?(rn, x) =>
        applyOne!(rn.type :: MR, [ln.type], x)
      ++ (%a[t1, t2, ...] | T) ~ (%b[s1, s2, ...] | S)
      ms := findMatches(fetch(ln.type, x), fetch(rn.type, x))
      empty? ms.terms => false
      if not aliasType? ms.terms then
        if typeVar? ln.type then
          (x.typevars)(ln.type :: MR) := ms.terms
        if typeVar? rn.type then
          (x.typevars)(rn.type :: MR) := ms.terms
      apply!(ms.subst, x)

    nodeType! (n : TCN, types : List(N), x : %) : Boolean ==
      ++ %a[?] ~ [s1, s2, ...]
      unknownType?(n, x) =>
        applyOne!(n.type :: MR, types, x)
      ++ (%a[t1, t2, ...] | T) ~ [s1, s2, ...]
      ms := findMatches(fetch(n.type, x), types)
      empty? ms.terms => false
      if not aliasType? ms.terms then
        if typeVar? n.type then
          (x.typevars)(n.type :: MR) := ms.terms
      apply!(ms.subst, x)

    ++ With limited knowledge this routine tries to constraint types in given
    ++ nodes to pairs which are (possibly) in subtyping relation.
    nodeSubType! (sn : TCN, tn : TCN, x : %) : Boolean ==
      ++ {%s[s1, s2, ...] | S} <: {%t[?]} or {%s[?]} <: {%t[t1, t2, ...] | T}
      ++ In both cases we can assume nothing... one should just run
      ++ type unification as a fallback.
      unknownType?(sn, x) or unknownType?(tn, x) => false
      ++ {%s[s1, s2, ...] | S} <: {%t[t1, t2, ...] | T}
      sl : List(N) := []
      tl : List(N) := []
      ++ {%s | S} <: {%t[t1, t2, ...] | T}
      ++ Consider subtyping between %s and %t as if structure of %s was unknown
      ++ for the time being.
      for t in fetch(tn.type, x) repeat
        if isSubType(sn.type, t) then
          tl := [t, :tl]
      if not empty? tl then
        sl := fetch(sn.type, x)
      ++ KBa: In %s and %t there are usually some type variables. We could
      ++ start normalizing terms to find out what's their exact structure, but
      ++ I consider it to be dangerous.
      ++ Deal with them later with type unification.
      sl := concat([s for s in fetch(sn.type, x) | unbound? s], sl)
      tl := concat([t for t in fetch(tn.type, x) | unbound? t], tl)
      ++ With terms of known structure we can deal quite well.
      for s in fetch(sn.type, x) | not unbound? s repeat
        for t in fetch(tn.type, x) | not unbound? t repeat
          if isSubType(s, t) then
            sl := [s, :sl]
            tl := [t, :tl]
      empty? sl or empty? tl => false
      if typeVar? sn.type then
        (x.typevars)(sn.type :: MR) := removeDuplicates sl
      if typeVar? tn.type then
        (x.typevars)(tn.type :: MR) := removeDuplicates tl
      true

    nodeSubTypeOfList! (sn : TCN, types : List(N), x : %) : Boolean ==
      ++ {%s[?]} <: [t1, t2, ...]
      unknownType?(sn, x) => false
      ++ {%s[s1, s2, ...] | S} <: [t1, t2, ...]
      sl : List(N) := []
      for s in fetch(sn.type, x) repeat
        for t in types repeat
          if isSubType(s, t) then
            sl := [s, :sl]
      empty? sl => false
      if typeVar? sn.type then
        (x.typevars)(sn.type :: MR) := removeDuplicates sl
      true

    applySubRule(rule : N, n : TCN, x : %) : Boolean ==
      emptyNode? rule => true
      nodeRef? rule => true

      debug (["Run type inference for" :: PF, number(n.index) :: PF,
              "of" :: PF, n.type :: PF, "type." :: PF])

      apply? rule =>
        r := rule :: APP
        nfun := node((r.function :: MR).id, x) -- function node
        nargs := [node((arg :: MR).id, x) for arg in r.args] -- argument nodes

        sigs : List(N) := []
        substList : List(SUBST) := []
        for t in fetch(nfun.type, x) repeat
          ++ 1) Consider signature types with correct number of arguments.
          t' := (typeOrigin? t => (t :: TE).expr; t)
          not mappingType? t' => "iterate"
          sig := t' :: MT
          #sig.args ~= #nargs => "iterate"
          debug ["Checking signature:" :: PF, bold(t :: PF)]
          ++ 2) Check if arguments can be applied to function of given
          ++    signature.
          argsOk? := true
          for arg in sig.args for narg in nargs | argsOk? repeat
            argTypes := fetch(narg.type, x)
            ures := unifyType(arg, argTypes)
            ures case SUBST =>
              substList := [ures :: SUBST, :substList]
            "or"/[isSubType(argType, arg) for argType in argTypes] => "iterate"
            argsOk? := false
          not argsOk? => "iterate"
          ++ 3) Check if result type is correct for given signature.
          ures := unifyType(sig.result, fetch(n.type, x))
          ures case "failed" => "iterate"
          ++ 4) Collect variable substitutions and valid signature.
          substList := [ures :: SUBST, :substList]
          sigs := [t, :sigs]
        subst := mergeSubstitutions(substList)

        empty? sigs => false

        if typeVar? nfun.type then
          applyOne!(nfun.type :: MR, sigs, x)

        for s in entries subst repeat
          applyOne!(s.key, s.entry, x)

        ++ Fetch all inferred mappings.
        mappings : List(MT) := []
        for t in sigs repeat
          if typeOrigin? t then
            t := (t :: TE).expr
          not mappingType? t => "iterate"
          mappings := [t :: MT, :mappings]
        ++ Propagate function arguments and return type down the tree.
        for i in 1..#nargs for narg in nargs repeat
          nodeType!(narg, [(mt.args)(i) for mt in mappings], x)
        nodeType!(n, [mt.result for mt in mappings], x) 
        true

      assign? rule =>
        r := rule :: ASS
        ln := node((r.lval :: MR).id, x) -- left node
        rn := node((r.rval :: MR).id, x) -- right node
        not (nodeSubType!(rn, ln, x) or nodesTypeMatch!(ln, rn, x)) => false
        nodeType!(n, [ln.type], x)

      condExpr? rule =>
        r := rule :: CE
        cn := node((r.cond :: MR).id, x) -- condition node
        tn := node((r.truebr :: MR).id, x) -- true branch node
        fn := node((r.falsebr :: MR).id, x) -- false branch node
        not nodeType!(cn, [booleanType], x) => false
        nodeSubType!(tn, n, x) and nodeSubType!(fn, n, x) => true
        nodesTypeMatch!(n, tn, x) and nodesTypeMatch!(n, fn, x) => true
        typeUndef? tn.type and nodeType!(fn, [typeAny], x) =>
          killNode!(n, x)
          true
        typeUndef? fn.type and nodeType!(tn, [typeAny], x) =>
          killNode!(n, x)
          true
        false

      subType? rule =>
        te := rule :: TE
        mr1 := te.expr :: MR
        mr2 := te.type :: MR
        n1 := node(mr1.id, x)
        n2 := node(mr2.id, x)
        nodesTypeMatch!(n1, n2, x) or nodeSubType!(n1, n2, x)

      typeOrigin? rule =>
        te := rule :: TE
        fun := node((te.expr :: MR).id, x)
        nodeType!(n, [fun.type], x)

      fail ["applySubRule: case not handled for" :: PF, rule :: PF]
      error ""

    applyRule(r : TCR, n : TCN, x : %) : Boolean ==
      "and"/[applySubRule(c, n, x) for c in entries r]

    applyAnyRule(n : TCN, x : %) : Boolean ==
      rules := n.rules
      empty? rules => true
      while not empty? rules and not applyRule(first rules, n, x) repeat
        rules := rest rules
      empty? rules => false
      ++ Immediately remove rules that fail to apply.
      for victim in setDifference(children n.rules, children rules) repeat
        killNode!(node(victim, x), x)
      n.rules := rules
      true

    countProgress (x : %) : Record(a : Integer, b : Integer) ==
      ++ a = number of type variables and nodes to be processed
      ++     (empty type variable counts twice)
      ++ b = sum of types assigned to each type variable
      p := [#(x.typevars), 0]
      for n in entries x.nodes | not done? n repeat
        types : List(N) :=
          not typeVar? n.type => []
          (x.typevars)(n.type :: MR)
        p.a := p.a + 1
        if emptyType? types
          then p.a := p.a + 1
          else p.b := p.b + #types
      p

    walkPostOrder(n : TCN, x : %) : List(TCN) ==
      lst := [walkPostOrder(node(i, x), x) for i in children(n)]
      "concat"/concat(lst, [n])

    check x ==
      q : Queue(TCN) := empty()

      for n in walkPostOrder(x.nodes.1, x) repeat 
        rewriteIfInferred!(n, x)
        enqueue!(n, q)

      info vconcat(["Tree ready for type checking..." :: PF,
                    x :: PF, x.typevars :: PF])

      p := countProgress x
      s := 1 :: NNI

      while p.a > 0 or p.b > 0 repeat
        newQ : Queue(TCN) := empty()

        ++ perform meta-step
        while not empty? q repeat
          n := dequeue! q
          done? n => "iterate"

          --debug([number(s) :: PF, "Queue state" :: PF, "=>" :: PF,
          --       number(n.index) :: PF, ":" :: PF,
          --       bracket [number(m.index) :: PF for m in members q]])

          not applyAnyRule(n, x) =>
            fail pile([spaces ["Type error for node:" :: PF, number(n.index) :: PF],
                       red(n.node :: PF)])
            debug (x :: PF)
            debug (x.typevars :: PF)
            return false

          ++ Check if we're done with processing type variable tied to this node.
          rewriteIfInferred!(n, x)

          ++ If type is inferred for all dependencies the node itself won't change
          checkAndMarkIfDone!(n, x) =>
            debug ["Processing node" :: PF, number(n.index) :: PF, "completed!" :: PF]

          enqueue!(n, newQ)

        ++ check if during meta-step the problem was reduced compared to
        ++ previous meta-step
        newP := countProgress x
        correct :=
          newP.a < p.a => true
          newP.a = p.a and newP.b < p.b => true
          false
        not correct =>
          fail ("Type checker does not advance by applying known typing rules!" :: PF)
          debug (x :: PF)
          debug (x.typevars :: PF)
          error ""

        ++ setup new meta-step
        p := newP
        q := newQ
        s := s + 1

      info (x :: PF)

      ++ Rewrite the tree if succeeded !
      ns := nodes(x)
      root := first ns
      root.node := rewrite(root.node)$SpadTreeFillInTypes(ns)

      true

)abbrev package TCRFACT TypeCheckerRuleFactory
TypeCheckerRuleFactory() : Exports == Implementation where
  N ==> SpadNode
  FT ==> SpadFunctor(N)
  TCR ==> TypeCheckerRule
  TCN ==> TypeCheckerNode
  OTCN ==> Union(TCN, "none")

  Exports ==> with
    assignRule : (TCN, TCN) -> TCR
    applyRule : (TCN, List(TCN)) -> TCR
    condExprRule : (TCN, TCN, TCN) -> TCR
    ftorRule : (FT, TCN) -> TCR
    loopIterRule : (TCN, TCN, TCN) -> TCR
    loopRule :
      (Union("loop", "collect", "repeat"), List(TCN), List(TCN), TCN) -> TCR
    segRule : (TCN, OTCN, OTCN) -> TCR
    seqRule :
      (Union("Capsule", "Sequence", "Tuple"), TCN, List(TCN)) -> TCR
    typeOriginRule : (TCN, N) -> TCR
    subTypeRule : (TCN, TCN) -> TCR
    superTypeRule : (TCN, TCN) -> TCR

  Implementation ==> add
    import SpadNode

    assignRule (left, right) ==
      deps : List(N) := [nodeRef(left), nodeRef(right),
                         nodeAssign(nodeRef(left), nodeRef(right))]
      node := nodeAssign(nodeRef(left), nodeRef(right))
      newRule(deps, node)

    applyRule (fun, args) ==
      deps := cons(nodeRef(fun), [nodeRef(arg) for arg in args])
      deps := concat(deps, nodeApp(first deps, rest deps))
      node := nodeApp(nodeRef(fun), [nodeRef(arg) for arg in args])
      newRule(deps, node)

    condExprRule (cond, truebr, falsebr) ==
      deps : List(N) :=
        [nodeRef(cond), nodeRef(truebr), nodeRef(falsebr),
         nodeCondExpr(nodeRef(cond), nodeRef(truebr), nodeRef(falsebr))]
      node := nodeCondExpr(nodeRef(cond), nodeRef(truebr), nodeRef(falsebr))
      newRule(deps, node)

    loopIterRule (var, seq, iter) == 
      deps : List(N) :=
        [nodeRef(var), nodeRef(seq), nodeSubType(nodeRef(seq), nodeRef(iter))]
      newRule(deps, nodeIterator(var.node :: Symbol, nodeRef(seq)))

    loopRule (kind, itors, guards, body) ==
      deps : List(N) := [nodeRef(x) for x in [:itors, :guards, body]]
      itors' := [nodeRef(itor) for itor in itors]
      guards' := [nodeRef(guard) for guard in guards]
      newRule(deps, nodeLoop(kind, itors', guards', nodeRef(body)))

    ftorRule (ft, body) ==
      extendType := if emptyNode? ft.extends then ['Type] else ft.extends
      node := nodeFtor(ft.name, ft.args, ft.type, extendType, nodeRef(body))
      newRule([nodeRef(body)], node)

    segRule (start, end, step) ==
      startNode := nodeRef(start)
      endNode := emptyNode()
      stepNode := emptyNode()
      deps : List(N) := []
      if step case TCN then
        stepNode := nodeRef(step)
        deps := [nodeRef(step), :deps]
      if end case TCN then
        endNode := nodeRef(end)
        deps := [nodeRef(end), :deps]
      deps := [nodeRef(start), :deps]
      newRule(reverse deps, nodeSeg(startNode, endNode, stepNode))

    seqRule (kind, seq, exprList) ==
      deps : List(N) := [nodeRef(expr) for expr in exprList]
      deps := concat(deps, nodeSubType(nodeRef(last exprList), nodeRef(seq)))
      node := nodeSeq(kind, [nodeRef(expr) for expr in exprList])
      newRule(deps, node)

    typeOriginRule (expr, origin) ==
      deps : List(N) :=
        [nodeRef(expr), nodeTypeExpr('_$, nodeRef(expr), origin)]
      newRule(deps, nodeTypeExpr('_$, nodeRef(expr), origin))

    subTypeRule (subtype, type) ==
      deps : List(N) :=
        [nodeRef(subtype), nodeSubType(nodeRef(subtype), nodeRef(type))]
      newRule(deps, nodeRef(subtype))

    superTypeRule (super, type) ==
      deps : List(N) :=
        [nodeRef(type), nodeSubType(nodeRef(super), nodeRef(type))]
      newRule(deps, nodeRef(type))

)abbrev package STYPCHK SpadTypeChecker
SpadTypeChecker() : Exports == Implementation where
  N ==> SpadNode
  APP ==> SpadApply(N)
  ASS ==> SpadAssign(N)
  CE ==> SpadCondExpr(N)
  FN ==> SpadFunction(N)
  FT ==> SpadFunctor(N)
  IM ==> SpadImport(N)
  LAM ==> SpadLambda(N)
  IT ==> SpadIterator(N)
  LP ==> SpadLoop(N)
  M ==> SpadMacro(N)
  MT ==> SpadMappingType(N)
  NT ==> SpadNamedType(N)
  RT ==> SpadRecordType(N)
  SEG ==> SpadSegment(N)
  SEQ ==> SpadSequence(N)
  TE ==> SpadTypeExpr(N)
  UT ==> SpadUnionType(N)
  W ==> SpadWhere(N)
  MR ==> SpadMarker(N)

  NNI ==> NonNegativeInteger
  ENV ==> SpadEnvironment
  TCN ==> TypeCheckerNode
  CTX ==> TypeCheckerNodeArray
  SUBST ==> AssociationList(MR, List(N))
  PF ==> PrintableForm

  Exports ==> with
    walk : (N, CTX, ENV) -> TCN

  Implementation ==> add
    import SpadEnvironment
    import SExpression
    import String
    import Symbol
    import TypeCheckerRule
    import TypeCheckerNode
    import TypeCheckerRuleFactory
    import SpadNode
    import SpadNodeFactory
    import Printer
    import PrintableForm
    import TypeUnifier
    import Logger('AST)

    envAddType (t : N, env : ENV) : ENV ==
      notice ["Adding type" :: PF, bold(t :: PF), "to the environment." :: PF]
      if apply? t then
        app := t :: APP
        env := addDomain(app, env)
        for k in app.args repeat
          env := envAddType(k, env)
      if mappingType? t then
        mt := t :: MT
        for k in [mt.result, :mt.args] repeat
          env := envAddType(k, env)
      if recordType? t then
        r := t :: RT
        for f in r.fields repeat
          env := envAddType(f.type, env)
        for f in makeRecordFunList t repeat
          mt := (f :: NT).type :: MT
          env := addModemap(f.name, t, [mt.result, :mt.args], env)
      if unionType? t then
        ut := t :: UT
        for v in ut.variants repeat
          env := envAddType(v, env)
        for f in makeUnionFunList t repeat
          mt := (f :: NT).type :: MT
          env := addModemap(f.name, t, [mt.result, :mt.args], env)
      env

    walkApp (a : APP, ctx : CTX, env : ENV) : TCN ==
      ++ rewrite QUOTE(symbol) to value 'symbol
      a.function = ['QUOTE] and #a.args = 1 =>
        this := addNode!(ctx, first a.args, env)
        this.type := symbolType
        this

      debug ["Processing function application." :: PF]

      this := addNode!(ctx, [a], env)
      this.type := addTypeVar!(ctx)

      ++ First case: just a function call.
      funExpr := walk(a.function, ctx, env)
      argExprList := [walk(arg, ctx, env) for arg in a.args]

      ++ Second case: element indexing or record field access.
      eltFunList : List(N) := []
      if not unify?(a.function, ['elt]) then
        for mm in getModemap('elt, env) repeat
          n := qualifiedType(mm)
          eltFun := (n :: TE).expr :: MT
          if #eltFun.args = #a.args + 1 then
            eltFunList := [n, :eltFunList]

      if not empty? eltFunList then
        argExprList' := [funExpr, :argExprList]
        eltFunExpr := addNode!(ctx, ['elt], env)
        eltFunExpr.type := addTypeVar!(ctx, eltFunList)
        eltFunExpr.node := nodeTypeExpr('_$, eltFunExpr.node, typeRef(eltFunExpr))
        this.rules := [applyRule(eltFunExpr, argExprList'), :this.rules]

      ++ Add origin to function expression.
      if not(funExpr.node = ['return] or funExpr.node = ['error]) then
        funExpr.node := nodeTypeExpr('_$, funExpr.node, typeRef(funExpr))

      ++ First case with a twist: arbitrary list construction.
      if unify?(a.function, ['construct]) then
        var := addTypeVar!(ctx, [argExpr.type for argExpr in argExprList])
        item := addNode!(ctx, var, env)
        item.type := var
        constructSig :=
          nodeMappingType([var for i in 1..#a.args], nodeApp(['List], [var]))
        addType!(funExpr.type :: MR, constructSig, ctx)
        rule := applyRule(funExpr, argExprList)
        rule.deps := [nodeRef(item), :rule.deps]
        this.rules := [rule, :this.rules]
      else
        this.rules := [applyRule(funExpr, argExprList), :this.rules]
      this

    walkAssign (a : ASS, ctx : CTX, env : ENV) : TCN ==
      apply? a.lval =>
        app := a.lval :: APP
        this := walk(nodeApp(['setelt!], [app.function, :app.args, a.rval]), ctx, env)
        this.node := [a]
        this

      this := addNode!(ctx, [a])
      this.type := addTypeVar!(ctx)

      varIntro? : Boolean := false
      if symbol? a.lval then
        s := a.lval :: Symbol
        if emptyNode? getMode(s, env) then
          debug ["Processing fresh assignment" :: PF, string(s :: PF)]
          env := addMode(s, addTypeVar!(ctx), env)
          varIntro? := true

      left := walk(a.lval, ctx, env)
      right := walk(a.rval, ctx, env)

      if varIntro? then
        left.node := nodeTypeExpr('_:, left.node, typeRef(left))

      ++ Only left-value environment is propagated!
      this.env := left.env
      this.rules := [assignRule(left, right)]
      this

    walkCondExpr (ce : CE, ctx : CTX, env : ENV) : TCN ==
      debug ["Processing conditional expression." :: PF]
      this := addNode!(ctx, [ce])

      cond := walk(ce.cond, ctx, env)
      truebr := walk(ce.truebr, ctx, cond.env)
      falsebr := walk(ce.falsebr, ctx, (caseExpr? ce.cond => env; cond.env))

      this.type := addTypeVar!(ctx,
        [truebr.type, falsebr.type,
         nodeUnionType [truebr.type, falsebr.type],
         nodeUnionType [falsebr.type, truebr.type]])

      ++ TODO: "truebr.env" and "falsebr.env" should be merged and passed
      ++ forward instead of just "env". Merging means that if the same variable
      ++ was introduced in both branches then it should be present in the final
      ++ environment.
      ++
      ++ Q: What if a variable "x : T" is defined only in one branch?
      ++ A: In merged envrionment introduce "x" with type Union(T, "undefined"),
      ++    and emit a warning when subtyping rule is applied.
      this.env := env
      this.rules := [condExprRule(cond, truebr, falsebr)]
      this

    walkFun (fn : FN, ctx : CTX, env : ENV) : TCN ==
      debug ["Processing function" :: PF, string(fn.name :: PF)]

      fnType : MT := signature fn

      ++ Take the type of function and replace those components, that were not
      ++ specified, with type variables.
      typeList : List(N) :=
        ([(emptyNode?(t) => typeVar(i); t)
          for i in 1.. for t in [fnType.result, :fnType.args]])

      fnType' := nodeMappingType(rest typeList, first typeList)

      debug(["Signature associated with function definition :" :: PF,
             fnType' :: PF])

      ++ Fetch signatures from the environment, including those defined by
      ++ the domain / package / function. Filter out those that don't match
      ++ the type calculated above.
      candidateList : List(MT) := []
      for mm in getModemap(fn.name, env) repeat
        te := qualifiedType(mm) :: TE
        if te.type = ["%" :: Symbol] then
          candidate := te.expr
          ures := unifyType(fnType', candidate)
          failed? ures => "iterate"
          candidate := substitute(fnType', ures :: SUBST)
          candidateList := [candidate :: MT, :candidateList]

      ++ TODO: Filter out function which have been already defined.

      if not empty? candidateList then
        info(["Environment contains" :: PF, string bold(fn.name :: PF),
              "with signatures:" :: PF,
              bold bracket [c :: PF for c in candidateList]])
      else
        info(["Considering" :: PF, string bold(fn.name :: PF),
              "of type" :: PF, bold(fnType :: PF),
              "to be a local function!" :: PF])
        candidateList := [fnType]

      debug(["Will perform type check for" :: PF, string bold(fn.name :: PF),
             "function with following candidate signatures:" :: PF,
             brace [c :: PF for c in candidateList]])

      ++ Perform a type check for each candidate signature.
      for candidate in candidateList repeat
        info ["Assume" :: PF, fn.name :: PF, "has type :" :: PF, candidate :: PF]

        ctx' := nodeArray()
        env' := env

        this := addNode!(ctx', [fn], env)

        ++ It's vitally important that result type is represented by "%1" type
        ++ variable (e.g. 'return' refers to "%1").
        resType :=
          emptyNode? candidate.result => addTypeVar!(ctx')
          addTypeVar!(ctx', [candidate.result])

        ++ For each undefined argument type, add a node with type variable.
        deps : List(N) := []
        argList : List(N) := []
        argTypeList : List(N) := []

        for n in fn.args for t in candidate.args repeat
          if not emptyNode? t then
            env' := envAddType(t, env')
          ++ Augment the environment if argument type is known upfront.
          argName := (n :: NT).name
          argType :=
            arg := addNode!(ctx', n, env)
            arg.type :=
              not emptyNode? t =>
                addTypeVar!(ctx', [t])
              addTypeVar!(ctx')
            arg.node := [argName]
            deps := [nodeRef(arg), :deps]
            typeRef(arg)
          argList := [nodeNamedType(argName, argType), :argList]
          argTypeList := [t, :argTypeList]
          ++ Make the argument visible inside function body.
          debug(["Function argument" :: PF, string bold(argName :: PF),
                 "has type" :: PF, bold(t :: PF)])
          env' := addMode(argName, t, env')

        ++ Add a node that represents the type of function body, always.
        fnRes := addNode!(ctx', fn.result, env)
        fnRes.type := resType
        fnRes.node := typeRef(fnRes)

        ++ Augment the environment if result type is known upfront.
        if not emptyNode? candidate.result then
          env' := envAddType(candidate.result, env')
        deps := [nodeRef(fnRes), :deps]

        fnBody := walk(fn.body, ctx', env')

        fnRes.rules := [subTypeRule(fnBody, fnRes)]

        this.type := nodeMappingType(reverse argTypeList, fnRes.type)
        this.rules := ([newRule(
          reverse deps,
          nodeFun(fn.name, reverse argList, typeRef(fnRes), nodeRef(fnBody)))])

        if check ctx' then
          this' := addNode!(ctx, [fn], env)
          this'.type := this.type
          this'.node := this.node
          return this'

      fail (["No matching type for function" :: PF, string bold(fn.name :: PF),
             "found!" :: PF, pile(["Candidates were:" :: PF,
                                   :[c :: PF for c in candidateList]])])
      error ""

    walkFtor (ft : FT, ctx : CTX, env : ENV) : TCN ==
      sig := signature ft

      debug ["Processing functor :" :: PF, sig :: PF]
      env := addMode(sig.name, sig.type, env)
      env := addMode("$" :: Symbol, ft.type, env)
      env := addModemapsFromCategory(["$" :: Symbol], ft.type, env)

      ++ process functor's arguments
      for arg in ft.args repeat
        env := addModemap(arg.name :: Symbol, arg.type, [categoryType], env)
        env := addMode(arg.name, arg.type, env)
        env := addModemapsFromCategory([arg.name], arg.type, env)

      this := addNode!(ctx, [ft], env)

      ftorBody := walk(ft.capsule, ctx, env)
      extendType := if emptyNode? ft.extends then ['Type] else ft.extends

      this.type := sig.type
      this.rules := ([newRule(
        [nodeRef(ftorBody)],
        nodeFtor(ft.name, ft.args, ft.type, extendType, nodeRef(ftorBody)))])
      this

    walkImport (im : IM, ctx : CTX, env : ENV) : TCN ==
      debug ["Importing" :: PF, im.type :: PF]
      env := envAddType(im.type, env)
      this := addNode!(ctx, [im], env)
      this.type := im.type
      this

    walkLambda (lam : LAM, ctx : CTX, env : ENV) : TCN ==
      this := addNode!(ctx, [lam], env)
      deps : List(N) := []

      ++ Replace unknown types with type variables and add arguments to the
      ++ environment. Rewrite those lambda arguments that miss the type.
      argList : List(NT) := []
      argTypeList : List(N) := []

      for arg in lam.args repeat
        if emptyNode? arg.type then
          argType := addTypeVar! ctx

          lamArg := addNode!(ctx, [arg], env)
          lamArg.type := argType
          lamArg.node := [arg.name]
          deps := [nodeRef(lamArg), :deps]

          arg := [arg.name, typeRef(lamArg)]$NT
        else
          argType := arg.type
        argList := [arg, :argList]
        argTypeList := [argType, :argTypeList]
        env := addMode(arg.name, argType, env)

      argList := reverse argList
      argTypeList := reverse argTypeList

      retType := (emptyNode? lam.type => addTypeVar! ctx; lam.type)
      lamType := [argTypeList, retType]$MT

      debug ["Lambda expression of type" :: PF, bold(lamType :: PF)]

      ++ generate a node with result type
      lamBodyType := addNode!(ctx, lam.type, env)
      lamBody := walk(lam.body, ctx, env)
      lamBodyType.type := retType
      lamBodyType.rules := [subTypeRule(lamBody, lamBodyType)]

      deps := concat(reverse deps, nodeRef(lamBodyType))

      ++ add a node with type of the lambda expression just for dependants
      this.type := [lamType]
      this.rules := ([newRule(
        deps, nodeLambda(argList, typeRef(lamBodyType), nodeRef(lamBody)))])
      this

    walkLoop (lp : LP, ctx : CTX, env : ENV) : TCN ==
      debug ["Loop statement." :: PF]
      this := addNode!(ctx, [lp], env)
      deps : List(N) := []
      env' := env
      type : N

      if lp.kind case "collect" then
        type := addTypeVar!(ctx)
        this.type := nodeApp(['List], [type])
      else
        this.type := voidType

      debug ["Processing" :: PF, #(lp.itors) :: PF, "iterator(s)." :: PF]
      itorList : List(TCN) := []
      for n in lp.itors repeat
        itor := n :: IT

        varType := addTypeVar!(ctx)

        ++ Iterator variable is added to loop's body environment,
        ++ but is also known to guards.
        env' := addMode(itor.var, varType, env')

        itorExpr := addNode!(ctx, n, env)
        itorExpr.type :=
          addTypeVar!(ctx,
            [nodeApp(['List], [varType]),
             nodeApp(['UniversalSegment], [varType])])
        varExpr := walk([itor.var], ctx, env')
        seqExpr := walk(itor.seq, ctx, env)
        itorExpr.rules := [loopIterRule(varExpr, seqExpr, itorExpr)]
        itorList := [itorExpr, :itorList]

      debug ["Processing" :: PF, #(lp.guards) :: PF, "guard(s)." :: PF]
      guardList : List(TCN) := []
      for guard in lp.guards repeat
        guardType := addNode!(ctx, guard, env')
        guardType.type := booleanType
        guardExpr := walk(guard, ctx, env')
        guardType.rules := [subTypeRule(guardExpr, guardType)]
        guardList := [guardType, :guardList]

      debug ["Processing loop body." :: PF]
      body :=
        lp.kind case "collect" =>
          bodyType := addNode!(ctx, lp.body, env')
          bodyType.type := type
          bodyExpr := walk(lp.body, ctx, env')
          bodyType.rules := [subTypeRule(bodyExpr, bodyType)]
          bodyType
        walk(lp.body, ctx, env')

      this.rules := [loopRule(lp.kind, itorList, guardList, body)]
      this

    walkSeg (seg : SEG, ctx : CTX, env : ENV) : TCN ==
      debug ["Processing segment:" :: PF, string(seg :: PF)]
      segType := addTypeVar! ctx

      this := addNode!(ctx, [seg], env)

      startType := addNode!(ctx, seg.start, env)
      startExpr := walk(seg.start, ctx, env)
      startType.type := segType
      startType.rules := [subTypeRule(startExpr, startType)]

      endType' : Union(TCN, "none") :=
        not emptyNode? seg.end =>
          endType := addNode!(ctx, seg.end, env)
          endExpr := walk(seg.end, ctx, env)
          endType.type := segType
          endType.rules := [subTypeRule(endExpr, endType)]
          endType
        "none"

      stepType' : Union(TCN, "none") :=
        not emptyNode? seg.step =>
          stepType := addNode!(ctx, seg.step, env)
          stepExpr := walk(seg.step, ctx, env)
          stepType.type := integerType
          stepType.rules := [subTypeRule(stepExpr, stepType)]
          stepType
        "none"

      this.type := nodeApp(['UniversalSegment], [segType])
      this.rules := [segRule(startType, endType', stepType')]
      this

    walkSeq (s : SEQ, ctx : CTX, env : ENV) : TCN ==
      import List(TCN)

      debug ["Found sequence of" :: PF, #(s.list) :: PF, "expressions." :: PF]
      this := addNode!(ctx, [s])
      this.type := addTypeVar!(ctx)

      exprList := [(n := walk(e, ctx, env); env := n.env; n) for e in s.list]

      this.rules := [seqRule(s.kind, this, exprList)]
      this.env := (last exprList).env
      this

    walkSym (s : Symbol, ctx : CTX, env : ENV) : TCN ==
      debug ["Symbol lookup for" :: PF, string(s :: PF)]
      types := [qualifiedType(mm) for mm in getModemap(s, env)]
      mode := getMode(s, env)
      if not emptyNode? mode then
        types := [mode, :types]
      ++ BUG: parseTran use true and false as "Boolean" and not as "() -> Boolean"
      ++ workaround for Boolean constants
      if s = 'true or s = 'false then
        types := [booleanType, :types]
      if s = '_$NoValue then
        types := [voidType, :types]
      if s = 'leave then
        leaveType := nodeMappingType([integerType, voidType], typeAny) 
        types := [leaveType, :types]
      if s = 'error then
        errorType := nodeMappingType([stringType], typeAny)
        types := [errorType, :types]
      if s = 'return then
        returnType := nodeMappingType([integerType, typeVar(1)], typeAny)
        types := [returnType, :types]
      empty? types =>
        fail ["Undefined symbol:" :: PF, bold red string (s :: PF), "!" :: PF]
        error ""
      info(["Found" :: PF, string bold(s :: PF), "with type :" :: PF,
            bold bracket [t :: PF for t in types]])
      this := addNode!(ctx, [s], env)
      this.type :=
        #types = 1 and typeVar? types.1 => types.1
        addTypeVar!(ctx, types)
      this 

    walkTypeExpr (te : TE, ctx : CTX, env : ENV) : TCN ==
      te.kind = '_: => 
        debug(["Expression" :: PF, te.expr :: PF, "has type" :: PF, te.type :: PF])

        not symbol? te.expr =>
          fail ["Type annotation works only for symbols!" :: PF]
          error ""

        -- Type definition for a symbol:
        -- add it to the environment or crash if already defined
        s := te.expr :: Symbol
        t := getMode(s, env)

        (not emptyNode? t) and (t ~= te.type) =>
          fail([bold red ("Error!" :: PF), "Symbol" :: PF, string(s :: PF),
                "already defined as" :: PF, getMode(s, env) :: PF, "!" :: PF])
          error ""

        env := addMode(s, te.type, env)

        this := addNode!(ctx, [te], env)
        this.type := te.type
        this

      te.kind = '_@ =>
        debug(["Expression" :: PF, te.expr :: PF,
               "has to return type" :: PF, te.type :: PF])

        not apply? te.expr =>
          fail ["Type cut operator works only for function application!" :: PF]
          error ""

        env := envAddType(te.type, env)
        this := addNode!(ctx, [te], env)
        expr := walk(te.expr, ctx, env)

        this.type := te.type
        this.rules := [subTypeRule(expr, this)]
        this

      te.kind = '_:_: =>
        debug ["Expression" :: PF, te.expr :: PF, "have to coerce to" :: PF, te.type :: PF]
        env := envAddType(te.type, env)

        this := addNode!(ctx, [te], env)
        this.type := addTypeVar!(ctx, [te.type])

        expr := walk(te.expr, ctx, env)
        coerceFun := walk(['coerce], ctx, env)
        this.rules := [subTypeRule(expr, this), applyRule(coerceFun, [expr])]
        this
    
      te.kind = '_$ =>
        not symbol? te.expr =>
          fail ("Type origin selector works only for symbols!" :: PF)
          error ""

        debug(["Symbol" :: PF, string(te.expr :: PF),
               "must originate from" :: PF, bold(te.type :: PF),
               "type!" :: PF])

        env := envAddType(te.type, env)
        this := addNode!(ctx, [te], env)
        this.type := addTypeVar!(ctx)

        expr := walk(te.expr, ctx, env)

        this.rules := [typeOriginRule(expr, te.type)]
        this

      te.kind = 'case =>
        env := envAddType(te.type, env)

        this := addNode!(ctx, [te], env)
        this.type := addTypeVar!(ctx, [booleanType])

        if symbol? te.expr then
          this.env := addMode(te.expr :: Symbol, te.type, env)

        exprType := addNode!(ctx, te.type, env)
        exprType.type := te.type

        expr := walk(te.expr, ctx, env)
        exprType.rules := [superTypeRule(exprType, expr)]

        this.rules := [newRule([nodeRef(exprType)], [te])]
        this

      fail ["Type expression" :: PF, bold red paren(te :: PF), "not handled yet!" :: PF]
      error ""

    walkInt (i : Integer, ctx : CTX, env : ENV) : TCN ==
      debug [i :: PF, "is" :: PF, integerType :: PF, ":)" :: PF]
      this := addNode!(ctx, [i], env)
      this.type := integerType
      this

    walkFlt (f : DoubleFloat, ctx : CTX, env : ENV) : TCN ==
      debug [f :: PF, "is" :: PF, floatType :: PF, ":)" :: PF]
      this := addNode!(ctx, [f], env)
      this.type := floatType
      this

    walkStr (s : String, ctx : CTX, env : ENV) : TCN ==
      debug [string(s :: PF), "is" :: PF, stringType :: PF, ":)" :: PF]
      this := addNode!(ctx, [s], env)
      this.type := addTypeVar!(ctx, [[string(s :: Symbol)], stringType])
      this

    walkEmpty (e : N, ctx : CTX, env : ENV) : TCN ==
      this := addNode!(ctx, e, env)
      this.type := typeUndef
      this

    walk (n, ctx, env) ==
      apply? n => walkApp(n :: APP, ctx, env)
      assign? n => walkAssign(n :: ASS, ctx, env)
      condExpr? n => walkCondExpr(n :: CE, ctx, env)
      float? n => walkFlt(n :: DoubleFloat, ctx, env)
      functor? n => walkFtor(n :: FT, ctx, env)
      import? n => walkImport(n :: IM, ctx, env)
      integer? n => walkInt(n :: Integer, ctx, env)
      lambda? n => walkLambda(n :: LAM, ctx, env)
      loop? n => walkLoop(n :: LP, ctx, env)
      segment? n => walkSeg(n :: SEG, ctx, env)
      sequence? n => walkSeq(n :: SEQ, ctx, env)
      string? n => walkStr(n :: String, ctx, env)
      symbol? n => walkSym(n :: Symbol, ctx, env)
      typeExpr? n => walkTypeExpr(n :: TE, ctx, env)
      function? n => walkFun(n :: FN, ctx, env)
      emptyNode? n => walkEmpty(n, ctx, env)
      -- namedType, mappingType, recordType, sumType, unionType, macro, where
      fail ["Expression" :: PF, bold red paren(n :: PF), "not handled yet!" :: PF]
      error ""
