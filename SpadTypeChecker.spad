)abbrev domain TCRULE TypeCheckerRule
TypeCheckerRule() : Exports == Implementation where
  N ==> SpadNode
  CE ==> SpadCondExpr(N)
  MR ==> SpadMarker(N)
  SEQ ==> SpadSequence(N)

  PF ==> PrintableForm
  NNI ==> NonNegativeInteger

  Exports ==> CoercibleTo(PrintableForm) with
    newRule : () -> %
    newRule : (List(N), N) -> %

    empty? : % -> Boolean
    entries : % -> List(N)
    children : % -> List(NNI)
    children : List(%) -> List(NNI)

    elt : (%, "deps") -> List(N)
    elt : (%, "result") -> N

    setelt! : (%, "deps", List(N)) -> List(N)

  Implementation ==> add
    Rep := Record(r_deps : List(N), r_result : N)

    newRule () == [[], emptyNode()]$Rep
    newRule (deps, res) == [deps, res]$Rep

    empty? x == empty? x.r_deps
    entries x == x.r_deps

    children (x : %) : List(NNI) ==
      [(c :: MR).id for c in x.r_deps | nodeRef? c]

    children (lx : List(%)) : List(NNI) ==
      empty? lx => []
      -- BUG? Parser requires parens around reduce expression.
      removeDuplicates("concat"/[children x for x in lx])

    elt (x, "deps") == x.r_deps
    elt (x, "result") == x.r_result

    setelt!(x, "deps", l) ==
      x.r_deps := l

    coerceSubRule (r : N) : PF ==
      condExpr? r =>
        ce := r :: CE
        spaces(["if" :: PF, ce.cond :: PF,
                "then" :: PF, ce.truebr :: PF,
                "else" :: PF, ce.falsebr :: PF])
      sequence? r =>
        seq := r :: SEQ
        paren sepBy("; " :: PF, [n :: PF for n in seq.list])
      r :: PF

    coerce x ==
      brace [coerceSubRule c for c in x.r_deps]

)abbrev domain TCNODE TypeCheckerNode
TypeCheckerNode() : Exports == Implementation where
  PF ==> PrintableForm
  NNI ==> NonNegativeInteger
  ENV ==> SpadEnvironment
  N ==> SpadNode
  MR ==> SpadMarker(N)
  TE ==> SpadTypeExpr(N)
  FN ==> SpadFunction(N)
  UT ==> SpadUnionType(N)
  SUBST ==> AssociationList(MR, List(N))
  TCR ==> TypeCheckerRule

  Exports ==> CoercibleTo(PrintableForm) with
    elt : (%, "index") -> NNI
    elt : (%, "node") -> N
    elt : (%, "rules") -> List(TCR)
    elt : (%, "type") -> N
    elt : (%, "env") -> ENV
    elt : (%, "done") -> Boolean

    setelt! : (%, "rules", List(TCR)) -> List(TCR)
    setelt! : (%, "type", N) -> N
    setelt! : (%, "node", N) -> N
    setelt! : (%, "env", ENV) -> ENV
    setelt! : (%, "done", Boolean) -> Boolean

    construct : (NNI, N) -> %
    substitute! : (SUBST, %) -> Void
    done? : % -> Boolean

    children : % -> List(NNI)

    nodeRef : % -> N
    typeRef : % -> N

  Implementation ==> add
    Rep := Record(ni_index : NNI,
                  ni_node : N,
                  ni_rules : List(TCR),
                  ni_type : N,
                  ni_env : ENV,
                  ni_done : Boolean)

    import SpadNode
    import Printer
    import TypeUnifier
    import SpadNodeFactory

    elt (x, "index") == x.ni_index
    elt (x, "node") == x.ni_node
    elt (x, "rules") == x.ni_rules
    elt (x, "type") == x.ni_type
    elt (x, "env") == x.ni_env
    elt (x, "done") == x.ni_done

    setelt! (x, "node", n) ==
      x.ni_node := n
    setelt! (x, "rules", r) ==
      x.ni_rules := r
    setelt! (x, "type", ts) ==
      x.ni_type := ts
    setelt! (x, "env", env) ==
      x.ni_env := env
    setelt! (x, "done", d) ==
      x.ni_done := d

    construct (i, n) ==
      [i, n, [], emptyNode(), new(), false] $ Rep

    substitute! (subst, x) ==
      x.type := substitute(x.type, subst)

    done? x ==
      x.ni_done

    children x ==
      children x.rules

    nodeRef x ==
      nodeRef x.index

    typeRef x ==
      typeVar x.index

    coerce x ==
      done := if done? x then green("(+)" :: PF) else red("(-)" :: PF)
      prefix := hconcat [done, right(4, number(x.index) :: PF)]
      not empty? x.rules =>
        r := sepBy(" | " :: PF, [(r :: PF) for r in x.rules])
        spaces([prefix, r, "is" :: PF, bold (x.type :: PF)])
      import? x.node or typeDecl? x.node =>
        spaces [prefix, bold ("()" :: PF), white(x.node :: PF)]
      n := (typeOrigin? x.node => (x.node :: TE).expr; x.node)
      node :=
        value? n or typeVar? n =>
          symbol? n => bold cyan(n :: PF)
          bold(n :: PF)
        function? n =>
          bold cyan((n :: FN).name :: PF)
        sequence? n =>
          bold("(...)" :: PF)
        bold yellow("?" :: PF)
      spaces [prefix, node, ":" :: PF, bold (x.type :: PF)]

)abbrev package STFITS SpadTreeFillInTypes
SpadTreeFillInTypes(ns : List(TypeCheckerNode)) : SpadTreeWalkerCategory == Implementation where
  PF ==> PrintableForm
  N ==> SpadNode
  APP ==> SpadApply(N)
  TE ==> SpadTypeExpr(N)
  NNI ==> NonNegativeInteger

  Implementation ==> add
    import Logger('Fill)

    rewrite (te : TE) : N ==
      te := [te.kind, rewrite te.expr, rewrite te.type]$TE
      not te.kind = '_$ => [te]
      symbol? te.type and (te.type :: Symbol) = ("$" :: Symbol) => te.expr
      typeAny? te.type => te.expr
      mappingType? te.type => te.expr
      [te]

    rewrite (app : APP) : N ==
      ++ WORKAROUND! Remove origin qualifier from first argument of implicit
      ++ call to 'elt' added in walkApp $ SpadTypeChecker.
      if typeExpr? app.function then
        fun := app.function :: TE
        if fun.expr = ['elt] and #app.args > 0 then
          arg := app.args.1
          typeExpr? arg and (arg :: TE).kind = '_$ =>
            arg := (arg :: TE).expr
            return nodeApp(rewrite app.function, 
                           cons(rewrite arg, [rewrite a for a in rest app.args]))
      nodeApp(rewrite app.function, [rewrite a for a in app.args])

    rewrite (mr : SpadMarker(N)) : N ==
      mr.kind = 'typevar =>
        t := ns(mr.id).type
        typeOrigin? t =>
          te := coerce(t)@TE
          typeOrigin? te.type =>
            te' := coerce(te.type)@TE
            te'.type
          te.type
        t
      mr.kind = 'noderef =>
        n := ns(mr.id).node
        n = [mr] =>
          fail pile ["Self reference detected:" :: PF, ns(mr.id) :: PF]
          error ""
        rewrite n
      error ""

)abbrev package TCNA TypeCheckerNodeArray
TypeCheckerNodeArray() : Exports == Implementation where
  NNI ==> NonNegativeInteger
  TCN ==> TypeCheckerNode
  N ==> SpadNode
  APP ==> SpadApply(N)
  ASS ==> SpadAssign(N)
  CE ==> SpadCondExpr(N)
  ENV ==> SpadEnvironment
  MT ==> SpadMappingType(N)
  MR ==> SpadMarker(N)
  TE ==> SpadTypeExpr(N)
  SEQ ==> SpadSequence(N)
  UT ==> SpadUnionType(N)
  SUBST ==> AssociationList(MR, List(N))
  URES ==> Union(SUBST, "failed")
  TCR ==> TypeCheckerRule
  PF ==> PrintableForm

  Exports ==> CoercibleTo(PrintableForm) with
    nodeArray : () -> %

    addNode! : (%, N) -> TCN
    addNode! : (%, N, ENV) -> TCN
    addTypeVar! : % -> N
    addTypeVar! : (%, List(N)) -> N
    addMinorTypeVar! : % -> N
    addMinorTypeVar! : (%, List(N)) -> N
    addType! : (MR, N, %) -> Void

    nodes : % -> List(TCN)

    checkAndMarkIfDone! : (TCN, %) -> Boolean

    coerce : SUBST -> PF
    check : % -> Boolean

  Implementation ==> add
    Rep := Record(nodes : FlexibleArray(TCN),
                  major : NNI, minor : NNI,
                  typevars : AssociationList(MR, List(N)))

    import String
    import TypeCheckerRule
    import TypeCheckerNode
    import SpadNode
    import TypeUnifier
    import SpadNodeFactory
    import Printer
    import Logger('Type)

    nodeArray () ==
      [flexibleArray [], 0, 0, [[]]]

    coerceTypeVar (tvar : MR, types : List(N)) : PF ==
        ts :=
          #types = 1 => (first types) :: PF
          bracket [t :: PF for t in types]
        spaces [right(4, tvar :: PF), ":" :: PF, ts]

    coerce (typevars : AssociationList(MR, List(N))) : PF ==
      tvs := [coerceTypeVar(tv.key, tv.entry) for tv in reverse entries typevars]
      empty? tvs => "No type variables!" :: PF
      pile ["Type variables :" :: PF, :tvs]

    coerce (x : %) : PF ==
      pile ["Nodes :" :: PF, :[ni :: PF for ni in entries x.nodes], x.typevars :: PF]

    addNode! (x, n, env) ==
      ni := addNode!(x, n)
      ni.env := env
      ni

    addNode! (x, n) ==
      ni := [#(x.nodes) + 1, n]
      concat!(x.nodes, ni)
      ni

    addTypeVar! (x, types) ==
      if empty? types then 
        types := [emptyNode()]
      x.major := x.major + 1
      x.minor := 0
      tvar := typeVar(x.major, x.minor)
      (x.typevars)(tvar :: MR) := types
      tvar

    addTypeVar! x == addTypeVar!(x, [])

    addMinorTypeVar! (x, types) ==
      if empty? types then 
        types := [emptyNode()]
      x.minor := x.minor + 1
      tvar := typeVar(x.major, x.minor)
      (x.typevars)(tvar :: MR) := types
      tvar

    addMinorTypeVar! x == addMinorTypeVar!(x, [])

    node (i : NNI, x : %) : TCN ==
      (x.nodes)(i)

    nodes x ==
      entries x.nodes

    emptyType? (terms : List(N)) : Boolean ==
      #terms = 1 and emptyNode?(first terms)

    aliasType? (terms : List(N)) : Boolean ==
      #terms = 1 and typeVar?(first terms)

    addType! (var, type, x) ==
      terms := (x.typevars)(var)
      emptyType? terms => error ""
      (x.typevars)(var) := [type, :terms]

    fetch (n : N, x : %) : List(N) ==
      not typeVar? n => [n] 
      nl := (x.typevars)(n :: MR)
      emptyType? nl => [n]
      nl

    unknownType? (n : TCN, x : %) : Boolean ==
      ++ checks if type attached to the node has form "%a[?]"
      not typeVar? n.type => false
      emptyType?((x.typevars)(n.type :: MR))

    killNode!(n : TCN, x : %) : Void ==
      info ["Killing" :: PF, number(n.index) :: PF, "node!" :: PF]
      n.done := true
      if typeVar? n.type then
        remove!(n.type :: MR, x.typevars)
        n.type := typeUndef()

    checkAndMarkIfDone! (n, x) ==
      unbound? n.type => false
      empty? n.rules =>
        n.done := true
      -- We only care about first rule, because it produced actual result.
      rule := first n.rules
      for j in children rule repeat
        cn := node(j, x)
        import? cn.node or typeDecl? cn.node => "iterate"
        if unbound? cn.type then
          return false
      -- Remove leftovers from other alternative rules.
      for victim in setDifference(children n.rules, children rule) repeat
        killNode!(node(victim, x), x)
      n.node := rule.result
      n.done := true

    rewriteTypevars! (var : MR, term : N, x : %) : Void ==
      debug(["Rewriting" :: PF, bold(var :: PF), "to" :: PF, bold(term :: PF),
             "in all type variables." :: PF])
      for tv in entries x.typevars | not emptyType? tv.entry repeat
        ts : List(N) := []
        for t in tv.entry repeat
          t := substitute(t, var, term)
          ++ Remove duplicates.
          member?(t, ts) => "iterate"
          ++ Avoid ill-formed types (for now only unions).
          emptyNode? t => "iterate"
          ts := [t, :ts]
        tv.entry := reverse ts

    -- rewrite all nodes with type that contains given variable
    rewriteNodes! (var : MR, term : N, x : %) : Void ==
      for n in nodes(x) | occurs?(var, n.type) repeat
        n.type := substitute(n.type, var, term)
        debug (["Rewrote" :: PF, number(n.index) :: PF, "with" :: PF,
                brace spaces [var :: PF, "=>" :: PF, term :: PF]])

    rewriteIfInferred! (n : TCN, x : %) : Boolean ==
      not typeVar? n.type => false
      var := n.type :: MR
      terms := (x.typevars)(var)
      emptyType? terms or #terms > 1 => false
      term := first terms
      rewriteTypevars!(var, term, x)
      debug ["Removing" :: PF, bold(var :: PF), "type variable." :: PF]
      remove!(var, x.typevars)
      info (["Type inferred for node" :: PF, number(n.index) :: PF,
             ":" :: PF, bold(term :: PF)])
      rewriteNodes!(var, term, x)
      true

    removeAlias! (var : MR, alias : N, x : %) : Void ==
      var = (alias :: MR) => void() ++ BUG? Handle degenerate case!
      debug ["Removing alias:" :: PF, var :: PF, "=>" :: PF, alias :: PF]
      rewriteTypevars!(var, alias, x)
      for n in entries(x.nodes) | occurs?(var, n.type) repeat
        n.type := substitute(n.type, var, alias)
        debug (["Rewrote" :: PF, number(n.index) :: PF, "with" :: PF,
                brace spaces [var :: PF, "=>" :: PF, alias :: PF]])
      debug ["Removing" :: PF, bold(var :: PF), "type variable." :: PF]
      remove!(var, x.typevars)

    applyOne! (var : MR, terms : List(N), x : %) : Boolean ==
      debug(["Modyfing" :: PF, bold(var :: PF), "type variable with" :: PF,
             bracket [bold(t :: PF) for t in terms]])
      typevars := x.typevars
      -- 1) typevars(%x) = [?]
      emptyType? typevars(var) =>
        -- a) %x = %y => alias removal
        -- b) %x = [t1, t2, t3, ...]
        if aliasType? terms
          then removeAlias!(var, first terms, x)
          else typevars(var) := terms
        true
      -- 2) typevars(%x) = [s1, s2, s3, ...], %x = [t1, t2, t3, ...]
      -- Unify proposed values with already stored in the variable
      -- store only matching ones (without performing substitutions).
      ms := findMatches(typevars(var), terms)
      not empty? ms.terms =>
        typevars(var) := ms.terms
        true
      -- Unification failed, as a last resort use subtyping.
      for term in terms repeat
        for t in typevars(var) repeat
          if not isSubType(t, term) then
            return false
      typevars(var) := terms
      true

    apply! (substitutions : SUBST, x : %) : Boolean ==
      empty? substitutions => true
      "and"/[applyOne!(s.key, s.entry, x) for s in entries substitutions]

    nodesTypeMatch! (ln : TCN, rn : TCN, x : %) : Boolean ==
      ++ %a[?] ~ %b[?]
      unknownType?(ln, x) and unknownType?(rn, x) =>
        ures := unifyType(ln.type, rn.type)
        failed? ures => false
        apply!(ures :: SUBST, x)
      ++ %a[?] ~ (%b[t1, t2, ...] | T)
      unknownType?(ln, x) and not unknownType?(rn, x) =>
        applyOne!(ln.type :: MR, [rn.type], x)
      ++ (%a[t1, t2, ...] | T) ~ %b[?]
      not unknownType?(ln, x) and unknownType?(rn, x) =>
        applyOne!(rn.type :: MR, [ln.type], x)
      ++ (%a[t1, t2, ...] | T) ~ (%b[s1, s2, ...] | S)
      ms := findMatches(fetch(ln.type, x), fetch(rn.type, x))
      empty? ms.terms => false
      if not aliasType? ms.terms then
        if typeVar? ln.type then
          (x.typevars)(ln.type :: MR) := ms.terms
        if typeVar? rn.type then
          (x.typevars)(rn.type :: MR) := ms.terms
      apply!(ms.subst, x)

    nodeType! (n : TCN, types : List(N), x : %) : Boolean ==
      ++ %a[?] ~ [s1, s2, ...]
      unknownType?(n, x) =>
        applyOne!(n.type :: MR, types, x)
      ++ (%a[t1, t2, ...] | T) ~ [s1, s2, ...]
      ms := findMatches(fetch(n.type, x), types)
      empty? ms.terms => false
      if not aliasType? ms.terms then
        if typeVar? n.type then
          (x.typevars)(n.type :: MR) := ms.terms
      apply!(ms.subst, x)

    -- With limited knowledge this routine tries to constraint types in given
    -- nodes to pairs which are (possibly) in subtyping relation.
    nodeSubType! (sn : TCN, tn : TCN, x : %) : Boolean ==
      -- In both cases we can assume nothing...
      -- a) {%s[s1, s2, ...] | S} <: {%t[?]}
      -- b) {%s[?]} <: {%t[t1, t2, ...] | T}
      unknownType?(sn, x) or unknownType?(tn, x) => true
      -- We're left with: {%s[s1, s2, ...] | S} <: {%t[t1, t2, ...] | T}
      sl : List(N) := []
      tl : List(N) := []
      -- In %s and %t there are usually some type variables. We could
      -- start normalizing terms to find out what's their exact structure, but
      -- I consider it to be dangerous. Deal with them later...
      sl := concat([s for s in fetch(sn.type, x) | unbound? s], sl)
      tl := concat([t for t in fetch(tn.type, x) | unbound? t], tl)
      -- With terms of known structure we can deal quite well.
      for s in fetch(sn.type, x) | not unbound? s repeat
        for t in fetch(tn.type, x) | not unbound? t repeat
          if isSubType(s, t) then
            sl := [s, :sl]
            tl := [t, :tl]
      empty? sl or empty? tl => false
      if typeVar? sn.type then
        (x.typevars)(sn.type :: MR) := removeDuplicates sl
      if typeVar? tn.type then
        (x.typevars)(tn.type :: MR) := removeDuplicates tl
      true

    nodeSubTypeOfList! (sn : TCN, types : List(N), x : %) : Boolean ==
      -- {%s[?]} <: [t1, t2, ...]
      unknownType?(sn, x) => false
      -- {%s[s1, s2, ...] | S} <: [t1, t2, ...]
      sl : List(N) := []
      for s in fetch(sn.type, x) repeat
        for t in types repeat
          if isSubType(s, t) then
            sl := [s, :sl]
      empty? sl => false
      if typeVar? sn.type then
        (x.typevars)(sn.type :: MR) := removeDuplicates sl
      true

    -- evaluates single rule; note that it can happen that nothing was changed
    -- even if no type error was detected (result "true" means yes or maybe)
    applySubRule(rule : N, n : TCN, x : %) : Boolean ==
      emptyNode? rule => true
      nodeRef? rule => true

      debug (["Run type inference for" :: PF, number(n.index) :: PF,
              "of" :: PF, n.type :: PF, "type." :: PF])
      --debug(x :: PF)
      --debug(x.typevars :: PF)

      apply? rule =>
        r := rule :: APP
        nfun := node((r.function :: MR).id, x) -- function node
        nargs := [node((arg :: MR).id, x) for arg in r.args] -- argument nodes

        sigs : List(N) := []
        substList : List(SUBST) := []
        for t in fetch(nfun.type, x) repeat
          ++ 1) Consider signature types with correct number of arguments.
          t' := (typeOrigin? t => (t :: TE).expr; t)
          not mappingType? t' => "iterate"
          sig := t' :: MT
          #sig.args ~= #nargs => "iterate"
          debug ["Checking signature:" :: PF, bold(t :: PF)]
          ++ 2) Check if arguments can be applied to function of given
          ++    signature.
          argsOk? := true
          for arg in sig.args for narg in nargs | argsOk? repeat
            argTypes := fetch(narg.type, x)
            ures := unifyType(arg, argTypes)
            ures case SUBST =>
              substList := [ures :: SUBST, :substList]
            "or"/[isSubType(argType, arg) for argType in argTypes] => "iterate"
            argsOk? := false
          not argsOk? => "iterate"
          ++ 3) Check if result type is correct for given signature.
          ures := unifyType(sig.result, fetch(n.type, x))
          ures case "failed" => "iterate"
          ++ 4) Collect variable substitutions and valid signature.
          substList := [ures :: SUBST, :substList]
          sigs := [t, :sigs]
        subst := mergeSubstitutions(substList)

        empty? sigs => false

        if typeVar? nfun.type then
          applyOne!(nfun.type :: MR, sigs, x)

        for s in entries subst repeat
          applyOne!(s.key, s.entry, x)

        ++ Fetch all inferred mappings.
        mappings : List(MT) := []
        for t in sigs repeat
          if typeOrigin? t then
            t := (t :: TE).expr
          not mappingType? t => "iterate"
          mappings := [t :: MT, :mappings]
        ++ Propagate function arguments and return type down the tree.
        for i in 1..#nargs for narg in nargs repeat
          nodeType!(narg, [(mt.args)(i) for mt in mappings], x)
        nodeType!(n, [mt.result for mt in mappings], x) 
        true

      assign? rule =>
        r := rule :: ASS
        ln := node((r.lval :: MR).id, x) -- left node
        rn := node((r.rval :: MR).id, x) -- right node
        -- a) {%s[?]} := {%t[t1, t2, ...] | T}
        -- given a type information flows from nodes above during TCNA
        -- construction and we don't know anything, let's accept types
        -- from below
        unknownType?(ln, x) => nodeType!(ln, [rn.type], x)
        -- b) {%s[s1, s2, ...] | S} := {%t[?]}
        -- we simply don't know, wait for types to flow from below
        unknownType?(rn, x) => true
        -- c) {%s[s1, s2, ...] | S} := {%t[t1, t2, ...] | T}
        -- now it's easy...
        not nodeSubType!(rn, ln, x) and not nodesTypeMatch!(ln, rn, x) => false
        nodeType!(n, [ln.type], x)

      condExpr? rule =>
        r := rule :: CE
        cn := node((r.cond :: MR).id, x) -- condition node
        tn := node((r.truebr :: MR).id, x) -- true branch node
        fn := node((r.falsebr :: MR).id, x) -- false branch node
        not nodeType!(cn, [booleanType], x) => false
        nodeSubType!(tn, n, x) and nodeSubType!(fn, n, x) => true
        nodesTypeMatch!(n, tn, x) and nodesTypeMatch!(n, fn, x) => true
        typeUndef? tn.type and nodeType!(fn, [typeAny], x) =>
          killNode!(n, x)
          true
        typeUndef? fn.type and nodeType!(tn, [typeAny], x) =>
          killNode!(n, x)
          true
        false

      subType? rule =>
        te := rule :: TE
        mr1 := te.expr :: MR
        mr2 := te.type :: MR
        n1 := node(mr1.id, x)
        n2 := node(mr2.id, x)
        nodeSubType!(n1, n2, x)

      typeOrigin? rule =>
        te := rule :: TE
        fun := node((te.expr :: MR).id, x)
        nodeType!(n, [fun.type], x)

      capsule? rule =>
        items := (rule :: SEQ).list
        types : List(N) := []
        for item in items repeat
          tcn := node((item :: MR).id, x)
          if not done? tcn then
            return true
          if function? tcn.node then
            types := [nodeNamedType((tcn.node :: FN).name, tcn.type), :types]
        nodeType!(n, [nodeSeq("Capsule", types)], x)

      fail ["applySubRule: case not handled for" :: PF, rule :: PF]
      error ""

    ruleApply(r : TCR, n : TCN, x : %) : Boolean ==
      "and"/[applySubRule(c, n, x) for c in entries r]

    applyAnyRule(n : TCN, x : %) : Boolean ==
      rules := n.rules
      empty? rules => true
      while not empty? rules and not ruleApply(first rules, n, x) repeat
        rules := rest rules
      empty? rules => false
      -- Immediately remove rules that fail to apply.
      for victim in setDifference(children n.rules, children rules) repeat
        killNode!(node(victim, x), x)
      n.rules := rules
      true

    countProgress (x : %) : Record(a : Integer, b : Integer) ==
      -- a = number of type variables and nodes to be processed
      --     (empty type variable counts twice)
      -- b = sum of types assigned to each type variable
      p := [#(x.typevars), 0]
      for n in entries x.nodes | not done? n repeat
        types : List(N) :=
          not typeVar? n.type => []
          (x.typevars)(n.type :: MR)
        p.a := p.a + 1
        if emptyType? types
          then p.a := p.a + 1
          else p.b := p.b + #types
      p

    walkPostOrder(n : TCN, x : %) : List(TCN) ==
      lst := [walkPostOrder(node(i, x), x) for i in children(n)]
      "concat"/concat(lst, [n])

    check x ==
      q : Queue(TCN) := empty()

      for n in walkPostOrder(x.nodes.1, x) repeat 
        rewriteIfInferred!(n, x)
        enqueue!(n, q)

      info vconcat(["Tree ready for type checking..." :: PF,
                    x :: PF, x.typevars :: PF])

      p := countProgress x
      s := 1 :: NNI

      while p.a > 0 or p.b > 0 repeat
        newQ : Queue(TCN) := empty()

        -- perform meta-step
        while not empty? q repeat
          n := dequeue! q
          done? n => "iterate"

          --debug([number(s) :: PF, "Queue state" :: PF, "=>" :: PF,
          --       number(n.index) :: PF, ":" :: PF,
          --       bracket [number(m.index) :: PF for m in members q]])

          not applyAnyRule(n, x) =>
            fail pile([spaces ["Type error for node:" :: PF, number(n.index) :: PF],
                       red(n.node :: PF)])
            debug (x :: PF)
            debug (x.typevars :: PF)
            return false

          -- Check if we're done with processing type variable tied to this node.
          rewriteIfInferred!(n, x)

          -- If type is inferred for all dependencies the node itself won't change
          checkAndMarkIfDone!(n, x) =>
            debug ["Processing node" :: PF, number(n.index) :: PF, "completed!" :: PF]

          enqueue!(n, newQ)

        -- check if during meta-step the problem was reduced compared to
        -- previous meta-step
        newP := countProgress x
        correct :=
          newP.a < p.a => true
          newP.a = p.a and newP.b < p.b => true
          false
        not correct =>
          fail ("Type checker does not advance by applying known typing rules!" :: PF)
          debug (x :: PF)
          debug (x.typevars :: PF)
          error ""

        -- setup new meta-step
        p := newP
        q := newQ
        s := s + 1

      info (x :: PF)

      -- Rewrite the tree if succeeded !
      ns := nodes(x)
      root := first ns
      root.node := rewrite(root.node)$SpadTreeFillInTypes(ns)

      true

)abbrev package TCRFACT TypeCheckerRuleFactory
TypeCheckerRuleFactory() : Exports == Implementation where
  N ==> SpadNode
  FT ==> SpadFunctor(N)
  TCR ==> TypeCheckerRule
  TCN ==> TypeCheckerNode
  OTCN ==> Union(TCN, "none")

  Exports ==> with
    ruleAssign : (TCN, TCN) -> TCR
    ruleApply : (TCN, List(TCN)) -> TCR
    ruleCondExpr : (TCN, TCN, TCN) -> TCR
    ruleFtor : (FT, TCN) -> TCR
    ruleLoopIter : (TCN, TCN, TCN) -> TCR
    ruleLoop :
      (Union("loop", "collect", "repeat"), List(TCN), List(TCN), TCN) -> TCR
    ruleSeg : (TCN, OTCN, OTCN) -> TCR
    ruleSeq :
      (Union("Domain", "Package", "Join", "Capsule", "Sequence", "Tuple", "Body"), TCN, List(TCN)) -> TCR
    ruleTypeOrigin : (TCN, N) -> TCR
    ruleSubType : (TCN, TCN) -> TCR
    ruleSuperType : (TCN, TCN) -> TCR

  Implementation ==> add
    import SpadNode

    ruleAssign (left, right) ==
      deps : List(N) := [nodeRef(left), nodeRef(right),
                         nodeAssign(nodeRef(left), nodeRef(right))]
      node := nodeAssign(nodeRef(left), nodeRef(right))
      newRule(deps, node)

    ruleApply (fun, args) ==
      deps := cons(nodeRef(fun), [nodeRef(arg) for arg in args])
      deps := concat(deps, nodeApp(first deps, rest deps))
      node := nodeApp(nodeRef(fun), [nodeRef(arg) for arg in args])
      newRule(deps, node)

    ruleCondExpr (cond, truebr, falsebr) ==
      deps : List(N) :=
        [nodeRef(cond), nodeRef(truebr), nodeRef(falsebr),
         nodeCondExpr(nodeRef(cond), nodeRef(truebr), nodeRef(falsebr))]
      node := nodeCondExpr(nodeRef(cond), nodeRef(truebr), nodeRef(falsebr))
      newRule(deps, node)

    ruleLoopIter (var, seq, iter) == 
      deps : List(N) :=
        [nodeRef(var), nodeRef(seq), nodeSubType(nodeRef(seq), nodeRef(iter))]
      newRule(deps, nodeIterator(var.node :: Symbol, nodeRef(seq)))

    ruleLoop (kind, itors, guards, body) ==
      deps : List(N) := [nodeRef(x) for x in [:itors, :guards, body]]
      itors' := [nodeRef(itor) for itor in itors]
      guards' := [nodeRef(guard) for guard in guards]
      newRule(deps, nodeLoop(kind, itors', guards', nodeRef(body)))

    ruleFtor (ft, body) ==
      extendType := if emptyNode? ft.extends then ['Type] else ft.extends
      node := nodeFtor(ft.name, ft.args, ft.type, extendType, nodeRef(body))
      newRule([nodeRef(body)], node)

    ruleSeg (start, end, step) ==
      startNode := nodeRef(start)
      endNode := emptyNode()
      stepNode := emptyNode()
      deps : List(N) := []
      if step case TCN then
        stepNode := nodeRef(step)
        deps := [nodeRef(step), :deps]
      if end case TCN then
        endNode := nodeRef(end)
        deps := [nodeRef(end), :deps]
      deps := [nodeRef(start), :deps]
      newRule(reverse deps, nodeSeg(startNode, endNode, stepNode))

    ruleSeq (kind, seq, exprList) ==
      deps : List(N) := [nodeRef(expr) for expr in exprList]
      deps :=
        kind case "Capsule" => concat(deps, nodeSeq(kind, [nodeRef(expr) for expr in exprList]))
        concat(deps, nodeSubType(nodeRef(last exprList), nodeRef(seq)))
      node := nodeSeq(kind, [nodeRef(expr) for expr in exprList])
      newRule(deps, node)

    ruleTypeOrigin (expr, origin) ==
      deps : List(N) :=
        [nodeRef(expr), nodeTypeExpr('_$, nodeRef(expr), origin)]
      newRule(deps, nodeTypeExpr('_$, nodeRef(expr), origin))

    ruleSubType (subtype, type) ==
      deps : List(N) :=
        [nodeRef(subtype), nodeSubType(nodeRef(subtype), nodeRef(type))]
      newRule(deps, nodeRef(subtype))

    ruleSuperType (super, type) ==
      deps : List(N) :=
        [nodeRef(type), nodeSubType(nodeRef(super), nodeRef(type))]
      newRule(deps, nodeRef(type))

)abbrev package STYPCHK SpadTypeChecker
SpadTypeChecker() : Exports == Implementation where
  N ==> SpadNode
  APP ==> SpadApply(N)
  ASS ==> SpadAssign(N)
  CE ==> SpadCondExpr(N)
  FN ==> SpadFunction(N)
  FT ==> SpadFunctor(N)
  IM ==> SpadImport(N)
  LAM ==> SpadLambda(N)
  IT ==> SpadIterator(N)
  LP ==> SpadLoop(N)
  M ==> SpadMacro(N)
  MT ==> SpadMappingType(N)
  NT ==> SpadNamedType(N)
  RT ==> SpadRecordType(N)
  SEG ==> SpadSegment(N)
  SEQ ==> SpadSequence(N)
  TE ==> SpadTypeExpr(N)
  UT ==> SpadUnionType(N)
  W ==> SpadWhere(N)
  MR ==> SpadMarker(N)

  NNI ==> NonNegativeInteger
  ENV ==> SpadEnvironment
  TCN ==> TypeCheckerNode
  CTX ==> TypeCheckerNodeArray
  SUBST ==> AssociationList(MR, List(N))
  PF ==> PrintableForm

  Exports ==> with
    walk : (N, CTX, ENV) -> TCN

  Implementation ==> add
    import SpadDatabase
    import SpadEnvironment
    import SExpression
    import String
    import Symbol
    import TypeCheckerRule
    import TypeCheckerNode
    import TypeCheckerRuleFactory
    import TypeInfo
    import SpadNode
    import SpadNodeFactory
    import Printer
    import PrintableForm
    import TypeUnifier
    import Logger('AST)

    envAddType (t : N, env : ENV) : ENV ==
      notice ["Adding type" :: PF, bold(t :: PF), "to the environment." :: PF]
      if apply? t then
        app := t :: APP
        env := addDomain(env, app)
        for k in app.args repeat
          env := envAddType(k, env)
      if mappingType? t then
        mt := t :: MT
        for k in [mt.result, :mt.args] repeat
          env := envAddType(k, env)
      if recordType? t then
        r := t :: RT
        for f in r.fields repeat
          env := envAddType(f.type, env)
        for f in makeRecordFunList t repeat
          env(f.name) := nodeTypeExpr('_$, f.type, t)
      if unionType? t then
        ut := t :: UT
        for v in ut.variants repeat
          env := envAddType(v, env)
        for f in makeUnionFunList t repeat
          env(f.name) := nodeTypeExpr('_$, f.type, t)
      env

    walkApp (a : APP, ctx : CTX, env : ENV) : TCN ==
      -- rewrite QUOTE(symbol) to value 'symbol
      a.function = ['QUOTE] and #a.args = 1 =>
        this := addNode!(ctx, first a.args, env)
        this.type := symbolType
        this

      debug ["Processing function application." :: PF]

      this := addNode!(ctx, [a], env)
      this.type := addTypeVar!(ctx)

      -- First case: just a function call.
      funExpr := walk(a.function, ctx, env)
      argExprList := [walk(arg, ctx, env) for arg in a.args]

      -- Second case: element indexing or record field access.
      eltFunList : List(N) := []
      if not unify?(a.function, ['elt]) then
        for n in env('elt) repeat
          eltFun := (n :: TE).expr :: MT
          if #eltFun.args = #a.args + 1 then
            eltFunList := [n, :eltFunList]

      if not empty? eltFunList then
        argExprList' := [funExpr, :argExprList]
        eltFunExpr := addNode!(ctx, ['elt], env)
        eltFunExpr.type := addTypeVar!(ctx, eltFunList)
        eltFunExpr.node := nodeTypeExpr('_$, eltFunExpr.node, typeRef(eltFunExpr))
        this.rules := [ruleApply(eltFunExpr, argExprList'), :this.rules]

      -- Add origin to function expression.
      if not(funExpr.node = ['return] or funExpr.node = ['error]) then
        funExpr.node := nodeTypeExpr('_$, funExpr.node, typeRef(funExpr))

      -- First case with a twist: arbitrary list construction.
      if unify?(a.function, ['construct]) then
        var := addTypeVar!(ctx, [argExpr.type for argExpr in argExprList])
        item := addNode!(ctx, var, env)
        item.type := var
        constructSig :=
          nodeMappingType([var for i in 1..#a.args], nodeApp(['List], [var]))
        addType!(funExpr.type :: MR, constructSig, ctx)
        rule := ruleApply(funExpr, argExprList)
        rule.deps := [nodeRef(item), :rule.deps]
        this.rules := [rule, :this.rules]
      else
        this.rules := [ruleApply(funExpr, argExprList), :this.rules]
      this

    walkAssign (a : ASS, ctx : CTX, env : ENV) : TCN ==
      apply? a.lval =>
        app := a.lval :: APP
        this := walk(nodeApp(['setelt!], [app.function, :app.args, a.rval]), ctx, env)
        this.node := [a]
        this

      this := addNode!(ctx, [a])
      this.type := addTypeVar!(ctx)

      newVar := emptyNode()
      if symbol? a.lval then
        s := a.lval :: Symbol
        if empty? env(s) then
          debug ["Processing fresh assignment" :: PF, string(s :: PF)]
          newVar := addTypeVar!(ctx)
          env(s) := newVar

      left := walk(a.lval, ctx, env)
      -- we know the type of left-value while checking right-value (!?)
      right := walk(a.rval, ctx, env)

      if not emptyNode? newVar then
        left.node := nodeTypeExpr('_:, left.node, typeRef(left))

      -- Only left-value environment is propagated!
      this.env := left.env
      this.rules := [ruleAssign(left, right)]
      this

    walkCondExpr (ce : CE, ctx : CTX, env : ENV) : TCN ==
      debug ["Processing conditional expression." :: PF]
      this := addNode!(ctx, [ce])

      cond := walk(ce.cond, ctx, env)
      truebr := walk(ce.truebr, ctx, cond.env)
      falsebr := walk(ce.falsebr, ctx, (caseExpr? ce.cond => env; cond.env))

      this.type := addTypeVar!(ctx,
        [truebr.type, falsebr.type,
         nodeUnionType [truebr.type, falsebr.type],
         nodeUnionType [falsebr.type, truebr.type]])

      -- TODO: "truebr.env" and "falsebr.env" should be merged and passed
      -- forward instead of just "env". Merging means that if the same variable
      -- was introduced in both branches then it should be present in the final
      -- environment.
      --
      -- Q: What if a variable "x : T" is defined only in one branch?
      -- A: In merged envrionment introduce "x" with type Union(T, "undefined"),
      --    and emit a warning when subtyping rule is applied.
      this.env := env
      this.rules := [ruleCondExpr(cond, truebr, falsebr)]
      this

    walkFun (fn : FN, ctx : CTX, env : ENV) : TCN ==
      debug ["Processing function" :: PF, string(fn.name :: PF)]

      fnType : MT := signature fn

      -- Take the type of function and replace those components, that were not
      -- specified, with type variables.
      typeList : List(N) :=
        ([(emptyNode?(t) => typeVar(i, 1); t)
          for i in 1.. for t in [fnType.result, :fnType.args]])

      fnType' := nodeMappingType(rest typeList, first typeList)

      debug(["Signature associated with function definition :" :: PF,
             fnType' :: PF])

      -- Fetch signatures from the environment, including those defined by
      -- the domain / package / function. Filter out those that don't match
      -- the type calculated above.
      candidateList : List(MT) := []
      for n in env(fn.name) repeat
        candidate := emptyNode()

        if typeExpr? n then
          te := n :: TE
          if te.type = ["$" :: Symbol] or emptyNode? te.type then
            candidate := te.expr
        if mappingType? n then
          candidate := n

        if not emptyNode? candidate then
          ures := unifyType(fnType', candidate)
          failed? ures => "iterate"
          candidate := substitute(fnType', ures :: SUBST)
          candidateList := [candidate :: MT, :candidateList]

      -- TODO: Filter out function which have been already defined.

      if not empty? candidateList then
        info(["Environment contains" :: PF, string bold(fn.name :: PF),
              "from" :: PF, bold("$" :: PF), "with signatures:" :: PF,
              bold bracket [c :: PF for c in candidateList]])
      else
        info(["Considering" :: PF, string bold(fn.name :: PF),
              "of type" :: PF, bold(fnType :: PF),
              "to be a local function!" :: PF])
        candidateList := [fnType]

      debug(["Will perform type check for" :: PF, string bold(fn.name :: PF),
             "function with following candidate signatures:" :: PF,
             brace [c :: PF for c in candidateList]])

      fnNode := addNode!(ctx, [fn], env)
      fnNode.type := addTypeVar!(ctx, [[c] for c in candidateList])
      return fnNode

      -- Perform a type check for each candidate signature.
      for candidate in candidateList repeat
        info ["Assume" :: PF, fn.name :: PF, "has type :" :: PF, candidate :: PF]

        ctx' := nodeArray()
        env' := env

        this := addNode!(ctx', [fn], env)

        ++ It's vitally important that result type is represented by "%1" type
        ++ variable (e.g. 'return' refers to "%1").
        resType :=
          emptyNode? candidate.result => addTypeVar!(ctx')
          addTypeVar!(ctx', [candidate.result])

        ++ For each undefined argument type, add a node with type variable.
        deps : List(N) := []
        argList : List(N) := []
        argTypeList : List(N) := []

        for n in fn.args for t in candidate.args repeat
          if not emptyNode? t then
            env' := envAddType(t, env')
          ++ Augment the environment if argument type is known upfront.
          argName := (n :: NT).name
          argType :=
            arg := addNode!(ctx', n, env)
            arg.type :=
              not emptyNode? t =>
                addTypeVar!(ctx', [t])
              addTypeVar!(ctx')
            arg.node := [argName]
            deps := [nodeRef(arg), :deps]
            typeRef(arg)
          argList := [nodeNamedType(argName, argType), :argList]
          argTypeList := [t, :argTypeList]
          ++ Make the argument visible inside function body.
          debug(["Function argument" :: PF, string bold(argName :: PF),
                 "has type" :: PF, bold(t :: PF)])
          env'(argName) := t

        ++ Add a node that represents the type of function body, always.
        fnRes := addNode!(ctx', fn.result, env)
        fnRes.type := resType
        fnRes.node := typeRef(fnRes)

        ++ Augment the environment if result type is known upfront.
        if not emptyNode? candidate.result then
          env' := envAddType(candidate.result, env')
        deps := [nodeRef(fnRes), :deps]

        fnBody := walk(fn.body, ctx', env')

        fnRes.rules := [ruleSubType(fnBody, fnRes)]

        this.type := nodeMappingType(reverse argTypeList, fnRes.type)
        this.rules := ([newRule(
          reverse deps,
          nodeFun(fn.name, reverse argList, typeRef(fnRes), nodeRef(fnBody)))])

        if check ctx' then
          this' := addNode!(ctx, [fn], env)
          this'.type := this.type
          this'.node := this.node
          return this'

      fail (["No matching type for function" :: PF, string bold(fn.name :: PF),
             "found!" :: PF, pile(["Candidates were:" :: PF,
                                   :[c :: PF for c in candidateList]])])
      error ""

    walkFtor (ft : FT, ctx : CTX, env : ENV) : TCN ==
      sig := signature ft
      -- sig is unchecked and may contain invalid types
      ftorApp := nodeApp([ft.name], [[nt] for nt in ft.args])

      debug pile([spaces ["Processing functor" :: PF, bold(ftorApp :: PF), "with:" :: PF],
                 ft.type :: PF])

      this := addNode!(ctx, [ft.name], env)

      argSub := [[]]$AssociationList(Symbol, N)
      argLst : List(N) := []
      ftDeps : List(N) := []

      ++ process functor's arguments
      for arg in ft.args repeat
        argType := addTypeVar!(ctx, [arg.type])
        argNode := addNode!(ctx, [arg.name], env)
        argNode.type := argType
        ftDeps := [nodeRef(argNode), :ftDeps]
        env(arg.name :: Symbol) := argType
        warn [arg.name :: PF, "=>" :: PF, argType :: PF]
        argSub(arg.name) := argType
        argLst := [argType, :argLst]

      argLst := reverse argLst
      ftorResNode := addNode!(ctx, ft.type, env)
      ftorResNode.type := addTypeVar!(ctx, [ft.type])
      ftDeps := [nodeRef(ftorResNode), :ftDeps]

      this.type := addTypeVar!(ctx, [nodeMappingType(argLst, ftorResNode.type)])

      env("$" :: Symbol) := nodeApp([ft.name], argLst)

      ++ process functor's body
      for n in (ft.type :: SEQ).list | namedType? n repeat
        nt := n :: NT
        env(nt.name :: Symbol) := nodeTypeExpr('_$, nt.type, ["$" :: Symbol])

      ftorBody := walk(ft.capsule, ctx, env)
      extendType := if emptyNode? ft.extends then ['Type] else ft.extends

      this.rules := ([newRule(
        reverse [nodeSubType(nodeRef(ftorBody), nodeRef(ftorResNode)), nodeRef(ftorBody), :ftDeps],
        nodeFtor(ft.name, ft.args, ft.type, extendType, nodeRef(ftorBody)))])

      check ctx =>
        this

      error ""

    walkImport (im : IM, ctx : CTX, env : ENV) : TCN ==
      debug ["Importing" :: PF, im.type :: PF]
      env := envAddType(im.type, env)
      this := addNode!(ctx, [im], env)
      this.done := true
      this

    walkLambda (lam : LAM, ctx : CTX, env : ENV) : TCN ==
      this := addNode!(ctx, [lam], env)
      deps : List(N) := []

      ++ Replace unknown types with type variables and add arguments to the
      ++ environment. Rewrite those lambda arguments that miss the type.
      argList : List(NT) := []
      argTypeList : List(N) := []

      for arg in lam.args repeat
        if emptyNode? arg.type then
          argType := addTypeVar! ctx

          lamArg := addNode!(ctx, [arg], env)
          lamArg.type := argType
          lamArg.node := [arg.name]
          deps := [nodeRef(lamArg), :deps]

          arg := [arg.name, typeRef(lamArg)]$NT
        else
          argType := arg.type
        argList := [arg, :argList]
        argTypeList := [argType, :argTypeList]
        env(arg.name) := argType

      argList := reverse argList
      argTypeList := reverse argTypeList

      retType := (emptyNode? lam.type => addTypeVar! ctx; lam.type)
      lamType := [argTypeList, retType]$MT

      debug ["Lambda expression of type" :: PF, bold(lamType :: PF)]

      ++ generate a node with result type
      lamBodyType := addNode!(ctx, lam.type, env)
      lamBody := walk(lam.body, ctx, env)
      lamBodyType.type := retType
      lamBodyType.rules := [ruleSubType(lamBody, lamBodyType)]

      deps := concat(reverse deps, nodeRef(lamBodyType))

      ++ add a node with type of the lambda expression just for dependants
      this.type := [lamType]
      this.rules := ([newRule(
        deps, nodeLambda(argList, typeRef(lamBodyType), nodeRef(lamBody)))])
      this

    walkLoop (lp : LP, ctx : CTX, env : ENV) : TCN ==
      debug ["Loop statement." :: PF]
      this := addNode!(ctx, [lp], env)
      deps : List(N) := []
      env' := env
      type : N

      if lp.kind case "collect" then
        type := addTypeVar!(ctx)
        this.type := nodeApp(['List], [type])
      else
        this.type := voidType

      debug ["Processing" :: PF, #(lp.itors) :: PF, "iterator(s)." :: PF]
      itorList : List(TCN) := []
      for n in lp.itors repeat
        itor := n :: IT

        varType := addTypeVar!(ctx)

        ++ Iterator variable is added to loop's body environment,
        ++ but is also known to guards.
        env'(itor.var) := varType

        itorExpr := addNode!(ctx, n, env)
        itorExpr.type :=
          addTypeVar!(ctx,
            [nodeApp(['List], [varType]),
             nodeApp(['UniversalSegment], [varType])])
        varExpr := walk([itor.var], ctx, env')
        seqExpr := walk(itor.seq, ctx, env)
        itorExpr.rules := [ruleLoopIter(varExpr, seqExpr, itorExpr)]
        itorList := [itorExpr, :itorList]

      debug ["Processing" :: PF, #(lp.guards) :: PF, "guard(s)." :: PF]
      guardList : List(TCN) := []
      for guard in lp.guards repeat
        guardType := addNode!(ctx, guard, env')
        guardType.type := booleanType
        guardExpr := walk(guard, ctx, env')
        guardType.rules := [ruleSubType(guardExpr, guardType)]
        guardList := [guardType, :guardList]

      debug ["Processing loop body." :: PF]
      body :=
        lp.kind case "collect" =>
          bodyType := addNode!(ctx, lp.body, env')
          bodyType.type := type
          bodyExpr := walk(lp.body, ctx, env')
          bodyType.rules := [ruleSubType(bodyExpr, bodyType)]
          bodyType
        walk(lp.body, ctx, env')

      this.rules := [ruleLoop(lp.kind, itorList, guardList, body)]
      this

    walkSeg (seg : SEG, ctx : CTX, env : ENV) : TCN ==
      debug ["Processing segment:" :: PF, string(seg :: PF)]
      segType := addTypeVar! ctx

      this := addNode!(ctx, [seg], env)

      startType := addNode!(ctx, seg.start, env)
      startExpr := walk(seg.start, ctx, env)
      startType.type := segType
      startType.rules := [ruleSubType(startExpr, startType)]

      endType' : Union(TCN, "none") :=
        not emptyNode? seg.end =>
          endType := addNode!(ctx, seg.end, env)
          endExpr := walk(seg.end, ctx, env)
          endType.type := segType
          endType.rules := [ruleSubType(endExpr, endType)]
          endType
        "none"

      stepType' : Union(TCN, "none") :=
        not emptyNode? seg.step =>
          stepType := addNode!(ctx, seg.step, env)
          stepExpr := walk(seg.step, ctx, env)
          stepType.type := integerType
          stepType.rules := [ruleSubType(stepExpr, stepType)]
          stepType
        "none"

      this.type := nodeApp(['UniversalSegment], [segType])
      this.rules := [ruleSeg(startType, endType', stepType')]
      this

    walkSeq (s : SEQ, ctx : CTX, env : ENV) : TCN ==
      import List(TCN)

      debug ["Found sequence of" :: PF, #(s.list) :: PF, "expressions." :: PF]
      this := addNode!(ctx, [s])
      this.type := addTypeVar!(ctx)

      exprList : List(TCN) := [(n := walk(e, ctx, env); env := n.env; n) for e in s.list]

      this.rules := [ruleSeq(s.kind, this, exprList)]
      this.env := (last exprList).env
      this

    walkSym (s : Symbol, ctx : CTX, env : ENV) : TCN ==
      debug ["Symbol lookup for" :: PF, string(s :: PF)]

      this := addNode!(ctx, [s], env)

      types := env(s)
      ++ BUG: parseTran uses true and false as "Boolean" and not as "() -> Boolean"
      ++ workaround for Boolean constants
      if s = 'true or s = 'false then
        types := [booleanType, :types]
      if s = '_$NoValue then
        types := [voidType, :types]
      if s = 'leave then
        leaveType := nodeMappingType([integerType, voidType], typeAny) 
        types := [leaveType, :types]
      if s = 'error then
        errorType := nodeMappingType([stringType], typeAny)
        types := [errorType, :types]
      if s = 'return then
        returnType := nodeMappingType([integerType, typeVar(1)], typeAny)
        types := [returnType, :types]

      -- handle a symbol which is a type constructor
      if inDatabase? s then
        ti := getTypeInfo([[s], [emptyNode()]]$APP)

        ftorArgList : List(N) := []
        ftorArgNodeList : List(TCN) := []
        ftorArgRenames : SUBST := empty()

        for arg in ti.args repeat
          ftorArg := arg.expr
          ftorArgType := arg.type

          if typeVar? ftorArg then
            origFtorArg := ftorArg
            ftorArgType := substitute(ftorArgType, ftorArgRenames)

            ftorArgTypeNode := addNode!(ctx, ftorArgType, env)
            ftorArgTypeNode.type := addTypeVar!(ctx, [ftorArgType])

            ftorArg := addMinorTypeVar!(ctx)
            ftorArgRenames(origFtorArg :: MR) := [ftorArg]

            ftorArgNode := addNode!(ctx, ftorArg, env)
            ftorArgNode.type := ftorArg
            ftorArgNodeList := [ftorArgNode, :ftorArgNodeList]
            ftorArgNode.rules := [ruleSuperType(ftorArgNode, ftorArgTypeNode)]

          ftorArgList := [ftorArg, :ftorArgList]

        --ftorResType := substitute(ti.type, ftorArgRenames)
        ftorResType := nodeApp(['Type], [])
        ftorType := nodeMappingType(reverse ftorArgList, ftorResType)
        env(s) := ftorType
        types := [ftorType, :types]
        
        if not empty? ftorArgNodeList then
          this.rules := [newRule([nodeRef(n) for n in ftorArgNodeList], [s])]

      empty? types =>
        fail ["Undefined symbol:" :: PF, bold red string (s :: PF), "!" :: PF]
        error ""
      
      info(["Found" :: PF, string bold(s :: PF), "with type :" :: PF,
            bold bracket [t :: PF for t in types]])
      this.type :=
        #types = 1 and typeVar? types.1 => types.1
        addTypeVar!(ctx, types)
      this 

    walkTypeExpr (te : TE, ctx : CTX, env : ENV) : TCN ==
      te.kind = '_: => 
        debug(["Expression" :: PF, te.expr :: PF, "has type" :: PF, te.type :: PF])

        not symbol? te.expr =>
          fail ["Type annotation works only for symbols!" :: PF]
          error ""

        -- Type definition for a symbol:
        -- add it to the environment or crash if already defined
        s := te.expr :: Symbol
        ts := env(s)

        (not empty? ts) and (first ts ~= te.type) =>
          fail([bold red ("Error!" :: PF), "Symbol" :: PF, string(s :: PF),
                "already defined as" :: PF, spaces[t :: PF for t in ts], "!" :: PF])
          error ""

        env(s) := te.type
        this := addNode!(ctx, [te], env)
        this.done := true
        this

      te.kind = '_@ =>
        debug(["Expression" :: PF, te.expr :: PF,
               "has to return type" :: PF, te.type :: PF])

        not apply? te.expr =>
          fail ["Type cut operator works only for function application!" :: PF]
          error ""

        env := envAddType(te.type, env)
        this := addNode!(ctx, [te], env)
        expr := walk(te.expr, ctx, env)

        this.type := te.type
        this.rules := [ruleSubType(expr, this)]
        this

      te.kind = '_:_: =>
        debug ["Expression" :: PF, te.expr :: PF, "have to coerce to" :: PF, te.type :: PF]
        env := envAddType(te.type, env)

        this := addNode!(ctx, [te], env)
        this.type := addTypeVar!(ctx, [te.type])

        expr := walk(te.expr, ctx, env)
        coerceFun := walk(['coerce], ctx, env)
        this.rules := [ruleSubType(expr, this), ruleApply(coerceFun, [expr])]
        this
    
      te.kind = '_$ =>
        not symbol? te.expr =>
          fail ("Type origin selector works only for symbols!" :: PF)
          error ""

        debug(["Symbol" :: PF, string(te.expr :: PF),
               "must originate from" :: PF, bold(te.type :: PF),
               "type!" :: PF])

        env := envAddType(te.type, env)
        this := addNode!(ctx, [te], env)
        this.type := addTypeVar!(ctx)

        expr := walk(te.expr, ctx, env)

        this.rules := [ruleTypeOrigin(expr, te.type)]
        this

      te.kind = 'case =>
        env := envAddType(te.type, env)

        this := addNode!(ctx, [te], env)
        this.type := addTypeVar!(ctx, [booleanType])

        if symbol? te.expr then
          this.env := (env(te.expr :: Symbol) := te.type)

        exprType := addNode!(ctx, te.type, env)
        exprType.type := te.type

        expr := walk(te.expr, ctx, env)
        exprType.rules := [ruleSuperType(exprType, expr)]

        this.rules := [newRule([nodeRef(exprType)], [te])]
        this

      fail ["Type expression" :: PF, bold red paren(te :: PF), "not handled yet!" :: PF]
      error ""

    walkInt (i : Integer, ctx : CTX, env : ENV) : TCN ==
      debug [i :: PF, "is" :: PF, integerType :: PF, ":)" :: PF]
      this := addNode!(ctx, [i], env)
      this.type := integerType
      this

    walkFlt (f : DoubleFloat, ctx : CTX, env : ENV) : TCN ==
      debug [f :: PF, "is" :: PF, floatType :: PF, ":)" :: PF]
      this := addNode!(ctx, [f], env)
      this.type := floatType
      this

    walkStr (s : String, ctx : CTX, env : ENV) : TCN ==
      debug [string(s :: PF), "is" :: PF, stringType :: PF, ":)" :: PF]
      this := addNode!(ctx, [s], env)
      this.type := addTypeVar!(ctx, [[string(s :: Symbol)], stringType])
      this

    walkEmpty (e : N, ctx : CTX, env : ENV) : TCN ==
      this := addNode!(ctx, e, env)
      this.type := typeUndef
      this

    walk (n, ctx, env) ==
      apply? n => walkApp(n :: APP, ctx, env)
      assign? n => walkAssign(n :: ASS, ctx, env)
      condExpr? n => walkCondExpr(n :: CE, ctx, env)
      float? n => walkFlt(n :: DoubleFloat, ctx, env)
      functor? n => walkFtor(n :: FT, ctx, env)
      import? n => walkImport(n :: IM, ctx, env)
      integer? n => walkInt(n :: Integer, ctx, env)
      lambda? n => walkLambda(n :: LAM, ctx, env)
      loop? n => walkLoop(n :: LP, ctx, env)
      segment? n => walkSeg(n :: SEG, ctx, env)
      sequence? n => walkSeq(n :: SEQ, ctx, env)
      string? n => walkStr(n :: String, ctx, env)
      symbol? n => walkSym(n :: Symbol, ctx, env)
      typeExpr? n => walkTypeExpr(n :: TE, ctx, env)
      function? n => walkFun(n :: FN, ctx, env)
      emptyNode? n => walkEmpty(n, ctx, env)
      -- namedType, mappingType, recordType, sumType, unionType, macro, where
      fail ["Expression" :: PF, bold red paren(n :: PF), "not handled yet!" :: PF]
      error ""
