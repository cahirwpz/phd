)abbrev package STFITS SpadTreeFillInTypes
SpadTreeFillInTypes(findTypeNode : (PI, PI) -> TN) : SpadTreeWalkerCategory == Implementation where
  PF ==> PrintableForm
  PI ==> PositiveInteger
  N ==> SpadNode
  APP ==> SpadApply(N)
  NR ==> SpadNodeRef(N)
  TE ==> SpadTypeExpr(N)
  TV ==> SpadTypeVar(N)
  TN ==> SpadTypeNode

  Implementation ==> add
    import Logger('Fill)

    rewrite (te : TE) : N ==
      te := [te.kind, rewrite te.expr, rewrite te.type]$TE
      not te.kind = '_$ => [te]
      symbol? te.type and (te.type :: Symbol) = ("$" :: Symbol) => te.expr
      typeAny? te.type => te.expr
      mappingType? te.type => te.expr
      [te]

    rewrite (app : APP) : N ==
      -- WORKAROUND! Remove origin qualifier from first argument of implicit
      -- call to 'elt' added in walkApp $ SpadTypeChecker.
      if typeExpr? app.function then
        fun := app.function :: TE
        if fun.expr = ['elt] and #app.args > 0 then
          arg := app.args.1
          typeExpr? arg and (arg :: TE).kind = '_$ =>
            arg := (arg :: TE).expr
            return nodeApp(rewrite app.function, 
                           cons(rewrite arg, [rewrite a for a in rest app.args]))
      nodeApp(rewrite app.function, [rewrite a for a in app.args])

    rewrite (tv : TV) : N ==
      tn := findTypeNode(tv.major :: PI, tv.minor :: PI)
      t := tn.type
      typeOrigin? t =>
        te := coerce(t)@TE
        typeOrigin? te.type =>
          te' := coerce(te.type)@TE
          te'.type
        te.type
      t

    rewrite (nr : NR) : N ==
      tn := findTypeNode(nr.major :: PI, nr.minor :: PI)
      tn.node = [nr] =>
        fail pile ["Self reference detected:" :: PF, tn :: PF]
        error ""
      rewrite tn.node

)abbrev package STTCHECK SpadTypeTreeChecker
SpadTypeTreeChecker() : Exports == Implementation where
  NNI ==> NonNegativeInteger
  PF ==> PrintableForm
  PI ==> PositiveInteger

  N ==> SpadNode
  APP ==> SpadApply(N)
  ASS ==> SpadAssign(N)
  CE ==> SpadCondExpr(N)
  ENV ==> SpadEnvironment
  FN ==> SpadFunction(N)
  MT ==> SpadMappingType(N)
  NR ==> SpadNodeRef(N)
  SEQ ==> SpadSequence(N)
  TE ==> SpadTypeExpr(N)
  TV ==> SpadTypeVar(N)
  UT ==> SpadUnionType(N)

  SUBST ==> AssociationList(TV, List(N))
  URES ==> Union(SUBST, "failed")

  TT ==> SpadTypeTree
  TN ==> SpadTypeNode
  TR ==> SpadTypeRule

  Exports ==> with
    walk : TT -> Boolean

  Implementation ==> add
    import Logger('Check)
    import TypeUnifier
    import SpadNodeFactory
    import SpadTypeNode
    import SpadTypeTree

    evalApply(r : APP, n : TN, x : TT) : Boolean ==
      nfun := node(x, r.function) -- function node
      nargs := [node(x, arg) for arg in r.args] -- argument nodes

      sigs : List(N) := []
      substList : List(SUBST) := []
      for t in typeOf(x, nfun) repeat
        -- 1) Consider signature types with correct number of arguments.
        t' := stripOriginIfCan t
        not mappingType? t' => "iterate"
        sig := t' :: MT
        #sig.args ~= #nargs => "iterate"
        debug ["Checking signature:" :: PF, bold(t :: PF)]
        -- 2) Check if arguments can be applied to function of given
        --    signature.
        argsOk? := true
        for arg in sig.args for narg in nargs | argsOk? repeat
          argTypes := typeOf(x, narg)
          ures := unifyType(arg, argTypes)
          ures case SUBST =>
            substList := [ures :: SUBST, :substList]
          "or"/[isSubType(argType, arg) for argType in argTypes] => "iterate"
          argsOk? := false
        not argsOk? => "iterate"
        -- 3) Check if result type is correct for given signature.
        ures := unifyType(sig.result, typeOf(x, n))
        ures case "failed" => "iterate"
        -- 4) Collect variable substitutions and valid signature.
        substList := [ures :: SUBST, :substList]
        sigs := [t, :sigs]
      subst := mergeSubstitutions(substList)

      empty? sigs => false

      if typeVar? nfun.type then
        limitTypeVar!(x, nfun.type :: TV, sigs)

      for s in entries subst repeat
        limitTypeVar!(x, s.key, s.entry)

      -- Fetch all inferred mappings.
      mappings : List(MT) := []
      for t in sigs repeat
        t := stripOriginIfCan t
        not mappingType? t => "iterate"
        mappings := [t :: MT, :mappings]
      -- Propagate function arguments and return type down the tree.
      for i in 1..#nargs for narg in nargs repeat
        limitNodeType!(x, narg, [(mt.args)(i) for mt in mappings])
      limitNodeType!(x, n, [mt.result for mt in mappings]) 
      true

    evalAssign(r : ASS, n : TN, x : TT) : Boolean ==
      ln := node(x, r.lval) -- left node
      rn := node(x, r.rval) -- right node
      -- a) {%s[?]} := {%t[t1, t2, ...] | T}
      -- given a type information flows from nodes above during TT
      -- construction and we don't know anything, let's accept types
      -- from below
      hasUnknownType?(x, ln) => limitNodeType!(x, ln, [rn.type])
      -- b) {%s[s1, s2, ...] | S} := {%t[?]}
      -- we simply don't know, wait for types to flow from below
      hasUnknownType?(x, rn) => true
      -- c) {%s[s1, s2, ...] | S} := {%t[t1, t2, ...] | T}
      -- now it's easy...
      not nodeSubType!(x, rn, ln) and not nodesTypeMatch!(x, ln, rn) => false
      limitNodeType!(x, n, [ln.type])

    evalCondExpr(r : CE, n : TN, x : TT) : Boolean ==
      cn := node(x, r.cond) -- condition node
      tn := node(x, r.truebr) -- true branch node
      fn := node(x, r.falsebr) -- false branch node
      not limitNodeType!(x, cn, [booleanType]) => false
      nodeSubType!(x, tn, n) and nodeSubType!(x, fn, n) => true
      nodesTypeMatch!(x, n, tn) and nodesTypeMatch!(x, n, fn) => true
      typeUndef? tn.type and limitNodeType!(x, fn, [typeAny]) =>
        killNode!(x, n)
        true
      typeUndef? fn.type and limitNodeType!(x, tn, [typeAny]) =>
        killNode!(x, n)
        true
      false

    evalSubType(r : TE, n : TN, x : TT) : Boolean ==
      n1 := node(x, r.expr)
      n2 := node(x, r.type)
      nodeSubType!(x, n1, n2)

    evalTypeOrigin(r : TE, n : TN, x : TT) : Boolean ==
      fun := node(x, r.expr)
      limitNodeType!(x, n, [fun.type])

    evalCapsule(r : SEQ, n : TN, x : TT) : Boolean ==
      items := r.list
      types : List(N) := []
      for item in items repeat
        tn := node(x, item)
        not done? tn => return true
        if function? tn.node then
          types := [nodeNamedType((tn.node :: FN).name, tn.type), :types]
      limitNodeType!(x, n, [nodeSeq("Join", reverse types)])

    -- evaluates single rule; note that it can happen that nothing was changed
    -- even if no type error was detected (result "true" means yes or maybe)
    evalFormula(f : N, n : TN, x : TT) : Boolean ==
      emptyNode? f => true
      nodeRef? f => true

      debug (["Running type inference for" :: PF, n.index :: PF,
              "of" :: PF, n.type :: PF, "type." :: PF])

      apply? f => evalApply(f :: APP, n, x)
      assign? f => evalAssign(f :: ASS, n, x)
      condExpr? f => evalCondExpr(f :: CE, n, x)
      subType? f => evalSubType(f :: TE, n, x)
      typeOrigin? f => evalTypeOrigin(f :: TE, n, x)
      capsule? f => evalCapsule(f :: SEQ, n, x)

      fail ["evalFormula: case not handled for" :: PF, f :: PF]
      error "Internal error!"

    evalAnyRule(n : TN, x : TT) : Boolean ==
      rules := n.rules
      empty? rules => true
      while not empty? rules repeat
        fs := (first rules).formulas
        "and"/[evalFormula(f, n, x) for f in fs] => break
        rules := rest rules
      empty? rules => false
      -- Immediately remove rules that fail to apply.
      for victim in setDifference(references n.rules, references rules) repeat
        killNode!(x, victim)
      n.rules := rules
      true

    checkAndMarkIfDone! (x : TT, n : TN) : Boolean ==
      unbound? n.type => false
      if not empty? n.rules then
        -- We only care about first rule, because it produced actual solution.
        rule := first n.rules
        for ref in references rule repeat
          cn := node(x, ref)
          import? cn.node or typeDecl? cn.node => "iterate"
          if unbound? cn.type then
            return false
        -- Remove leftovers from other alternative rules.
        for victim in setDifference(references n.rules, references rule) repeat
          killNode!(x, victim)
        n.node := rule.solution
      done! n; true

    countProgress (x : TT) : Record(a : NNI, b : NNI) ==
      -- a = number of type variables and nodes to be processed
      --     (empty type variable counts twice)
      -- b = sum of types assigned to each type variable
      p := [typeVarCount(x), 0]
      for n in nodeList(x) | not done? n repeat
        p.a := p.a + 1
        if hasUnknownType?(x, n)
          then p.a := p.a + 1
          else p.b := p.b + #typeOf(x, n)
      p

    walkPostOrder(n : TN, x : TT) : List(TN) ==
      lst := [walkPostOrder(node(x, i), x) for i in references(n)]
      "concat"/concat(lst, [n])

    walk x ==
      q : Queue(TN) := empty()

      for n in walkPostOrder(root(x), x) repeat 
        rewriteIfInferred!(x, n)
        enqueue!(n, q)

      info vconcat ["Tree ready for type checking..." :: PF, x :: PF]
      info ["Processing order:" :: PF, bracket [n.index :: PF for n in members q]]

      p := countProgress x
      s := 1 :: NNI

      while p.a > 0 or p.b > 0 repeat
        newQ : Queue(TN) := empty()

        -- perform meta-step
        while not empty? q repeat
          n := dequeue! q
          done? n => "iterate"

          --debug([number(s) :: PF, "Queue state" :: PF, "=>" :: PF,
          --       n.index :: PF, ":" :: PF,
          --       bracket [m.index :: PF for m in members q]])

          not evalAnyRule(n, x) =>
            fail pile([spaces ["Type error for node:" :: PF, n.index :: PF],
                       red(n.node :: PF)])
            debug (x :: PF)
            return false

          -- Check if we're done with processing type variable tied to this node.
          rewriteIfInferred!(x, n)

          -- If type is inferred for all formulas the node itself won't change
          checkAndMarkIfDone!(x, n) =>
            debug ["Processing node" :: PF, n.index :: PF, "completed!" :: PF]

          enqueue!(n, newQ)

        -- check if during meta-step the problem was reduced compared to
        -- previous meta-step
        newP := countProgress x
        correct :=
          newP.a < p.a => true
          newP.a = p.a and newP.b < p.b => true
          false
        not correct =>
          fail ("Type checker does not advance by applying known typing rules!" :: PF)
          debug (x :: PF)
          return false

        -- setup new meta-step
        p := newP
        q := newQ
        s := s + 1

      info (x :: PF)

      -- Rewrite the tree if succeeded !

      -- capture x in closure, so that we don't need to expose TCNA type to
      -- SpadTreeFillInTypes
      findTypeNode := ((i : PI, j : PI) : TN +-> node(x, [i, j]$NR))

      r := root(x)
      r.node := rewrite(r.node)$SpadTreeFillInTypes(findTypeNode)

      true
