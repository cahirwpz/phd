)abbrev domain STRULE SpadTypeRule
SpadTypeRule() : Exports == Implementation where
  N ==> SpadNode
  APP ==> SpadApply(N)
  ASS ==> SpadAssign(N)
  CE ==> SpadCondExpr(N)
  MP ==> SpadMarkerPath
  MR ==> SpadMarker(N)
  TE ==> SpadTypeExpr(N)
  SEQ ==> SpadSequence(N)

  PF ==> PrintableForm
  PI ==> PositiveInteger

  Exports ==> CoercibleTo(PrintableForm) with
    construct : (List(N), N) -> %

    elt : (%, "formulas") -> List(N)
    elt : (%, "solution") -> N

    references : % -> List(MP)
    references : List(%) -> List(MP)

  Implementation ==> add
    import Logger('Rule)

    Rep := Record(r_formulas : List(N), r_solution : N)

    construct (fs, s) == [fs, s]$Rep

    elt (x, "formulas") == x.r_formulas
    elt (x, "solution") == x.r_solution

    references (x : %) : List(MP) ==
      [(f :: MR).path for f in x.formulas | nodeRef? f]

    references (lx : List(%)) : List(MP) ==
      empty? lx => []
      -- PARSER BUG? Parens are required around reduce expression.
      removeDuplicates("concat"/[references x for x in lx])

    coerce x ==
      pfs : List(PF) := []

      for f in x.r_formulas repeat
        pf :=
          condExpr? f =>
            ce := f :: CE
            spaces(["if" :: PF, ce.cond :: PF,
                    "then" :: PF, ce.truebr :: PF,
                    "else" :: PF, ce.falsebr :: PF])
          sequence? f =>
            seq := f :: SEQ
            paren sepBy("; " :: PF, [n :: PF for n in seq.list])
          f :: PF
        pfs := [pf, :pfs]

      brace reverse pfs

)abbrev domain STNODE SpadTypeNode
SpadTypeNode() : Exports == Implementation where
  PF ==> PrintableForm
  MP ==> SpadMarkerPath
  TR ==> SpadTypeRule
  ENV ==> SpadEnvironment
  N ==> SpadNode
  MR ==> SpadMarker(N)
  TE ==> SpadTypeExpr(N)
  FN ==> SpadFunction(N)
  SUBST ==> AssociationList(MR, List(N))

  Exports ==> CoercibleTo(PF) with
    construct : (MP, N) -> %

    elt : (%, "path") -> MP
    elt : (%, "node") -> N
    elt : (%, "rules") -> List(TR)
    elt : (%, "type") -> N
    elt : (%, "env") -> ENV

    setelt! : (%, "rules", List(TR)) -> List(TR)
    setelt! : (%, "type", N) -> N
    setelt! : (%, "node", N) -> N
    setelt! : (%, "env", ENV) -> ENV

    done? : % -> Boolean
    done! : % -> %

    references : % -> List(MP)

    nodeRef : % -> N
    typeRef : % -> N

  Implementation ==> add
    import SpadNode
    import Printer
    import TypeUnifier
    import SpadNodeFactory

    Rep := Record(ni_path : MP,
                  ni_node : N,
                  ni_rules : List(TR),
                  ni_type : N,
                  ni_env : ENV,
                  ni_done : Boolean)

    construct (p, n) ==
      [p, n, [], emptyNode(), new(), false]$Rep

    elt (x, "path") == x.ni_path
    elt (x, "node") == x.ni_node
    elt (x, "rules") == x.ni_rules
    elt (x, "type") == x.ni_type
    elt (x, "env") == x.ni_env

    setelt! (x, "node", n) ==
      x.ni_node := n
    setelt! (x, "rules", r) ==
      x.ni_rules := r
    setelt! (x, "type", ts) ==
      x.ni_type := ts
    setelt! (x, "env", env) ==
      x.ni_env := env

    done? x ==
      x.ni_done

    done! x ==
      x.ni_done := true
      x

    references x ==
      references x.rules

    nodeRef x ==
      nodeRef x.path

    typeRef x ==
      typeVar x.path

    coerce x ==
      done := if done? x then green("(+)" :: PF) else red("(-)" :: PF)
      prefix := hconcat [done, right(4, x.path:: PF)]
      not empty? x.rules =>
        r := sepBy(" | " :: PF, [(r :: PF) for r in x.rules])
        spaces([prefix, r, "is" :: PF, bold (x.type :: PF)])
      import? x.node or typeDecl? x.node =>
        spaces [prefix, bold ("()" :: PF), white(x.node :: PF)]
      n := (typeOrigin? x.node => (x.node :: TE).expr; x.node)
      node :=
        value? n or typeVar? n =>
          symbol? n => bold cyan(n :: PF)
          bold(n :: PF)
        function? n =>
          bold cyan((n :: FN).name :: PF)
        sequence? n =>
          bold("(...)" :: PF)
        bold yellow("?" :: PF)
      spaces [prefix, node, ":" :: PF, bold (x.type :: PF)]

)abbrev package STNA SpadTypeNodeArray
SpadTypeNodeArray() : Exports == Implementation where
  PI ==> PositiveInteger
  NNI ==> NonNegativeInteger
  MP ==> SpadMarkerPath
  TN ==> SpadTypeNode
  N ==> SpadNode
  APP ==> SpadApply(N)
  ASS ==> SpadAssign(N)
  CE ==> SpadCondExpr(N)
  ENV ==> SpadEnvironment
  FN ==> SpadFunction(N)
  MT ==> SpadMappingType(N)
  MR ==> SpadMarker(N)
  TE ==> SpadTypeExpr(N)
  SEQ ==> SpadSequence(N)
  UT ==> SpadUnionType(N)
  SUBST ==> AssociationList(MR, List(N))
  URES ==> Union(SUBST, "failed")
  TR ==> SpadTypeRule
  PF ==> PrintableForm

  Exports ==> CoercibleTo(PF) with
    construct : MP -> %

    node : (%, PI) -> TN
    node : (%, MP) -> TN
    node : (%, N) -> TN
    addNode! : (%, N) -> TN
    addNode! : (%, N, ENV) -> TN
    killNode! : (%, MP) -> Void
    killNode! : (%, TN) -> Void

    hasUnknownType? : (%, TN) -> Boolean

    typeVar : (%, N) -> List(N)
    addTypeVar! : % -> N
    addTypeVar! : (%, List(N)) -> N
    addType! : (%, MR, N) -> Void

    limitTypeVar! : (%, MR, List(N)) -> Boolean
    limitTypeVar! : (%, SUBST) -> Boolean
    limitNodeType! : (%, TN, List(N)) -> Boolean

    nodeSubType! : (%, TN, TN) -> Boolean
    nodesTypeMatch! : (%, TN, TN) -> Boolean 

    rewriteIfInferred! : (%, TN) -> Boolean

    countProgress : % -> Record(a : Integer, b : Integer)

  Implementation ==> add
    Rep := Record(root : SpadMarkerPath,
                  nextNode : SpadMarkerPath,
                  nextTypeVar : SpadMarkerPath,
                  nodes : FlexibleArray(TN),
                  typevars : SUBST)

    import SpadNode
    import TypeUnifier
    import SpadNodeFactory
    import Printer
    import Logger('Tree)

    construct root ==
      [root, addLevel root, addLevel root, flexibleArray [], [[]]]

    node (x : %, i : PI) ==
      (x.nodes)(i)

    node (x : %, path : MP) == 
      maybeI := indexOf(x.root, path)
      maybeI case PI => node(x, maybeI :: PI)
      error "BUG: invalid node path!"

    node (x : %, n : N) ==
      not nodeRef? n => error "BUG: nodeRef expected!"
      node(x, (n :: MR).path)

    addNode! (x, n, env) ==
      ni := addNode!(x, n)
      ni.env := env
      ni

    addNode! (x, n) ==
      ni := [x.nextNode, n]
      concat!(x.nodes, ni)
      x.nextNode := makeSucc x.nextNode
      ni

    killNode! (x : %, p : MP) ==
      killNode!(x, node(x, p))

    killNode! (x : %, n : TN) ==
      info ["Killing" :: PF, n.path :: PF, "node!" :: PF]
      if typeVar? n.type then
        remove!(n.type :: MR, x.typevars)
        n.type := typeUndef()
      done! n

    emptyType? (terms : List(N)) : Boolean ==
      #terms = 1 and emptyNode?(first terms)

    aliasType? (terms : List(N)) : Boolean ==
      #terms = 1 and typeVar?(first terms)

    hasUnknownType? (x, n) ==
      -- checks if type attached to the node has form "%a[?]"
      not typeVar? n.type => false
      emptyType?((x.typevars)(n.type :: MR))

    addTypeVar! (x, types) ==
      if empty? types then 
        types := [emptyNode()]
      if x.nextTypeVar < x.nextNode then
        x.nextTypeVar := copy x.nextNode
      tvar := typeVar x.nextTypeVar
      (x.typevars)(tvar :: MR) := types
      x.nextTypeVar := makeSucc x.nextTypeVar
      tvar

    addTypeVar! x == addTypeVar!(x, [])

    addType! (x, var, type) ==
      terms := (x.typevars)(var)
      emptyType? terms => error ""
      (x.typevars)(var) := [type, :terms]

    typeVar (x : %, n : N) ==
      not typeVar? n => [n] 
      nl := (x.typevars)(n :: MR)
      emptyType? nl => [n]
      nl

    rewriteTypeVars! (x : %, var : MR, term : N) : Void ==
      debug(["Rewriting" :: PF, bold(var :: PF), "to" :: PF, bold(term :: PF),
             "in all type variables." :: PF])
      for tv in entries x.typevars | not emptyType? tv.entry repeat
        ts : List(N) := []
        for t in tv.entry repeat
          t := substitute(t, var, term)
          -- Remove duplicates.
          member?(t, ts) => "iterate"
          -- Avoid ill-formed types (for now only unions).
          emptyNode? t => "iterate"
          ts := [t, :ts]
        tv.entry := reverse ts

    -- rewrite all nodes with type that contains given variable
    rewriteNodes! (x : %, var : MR, term : N) : Void ==
      for n in entries x.nodes | occurs?(var, n.type) repeat
        n.type := substitute(n.type, var, term)
        debug (["Rewrote" :: PF, n.path :: PF, "with" :: PF,
                brace spaces [var :: PF, "=>" :: PF, term :: PF]])

    rewriteIfInferred! (x : %, n : TN) : Boolean ==
      not typeVar? n.type => false
      var := n.type :: MR
      terms := (x.typevars)(var)
      emptyType? terms or #terms > 1 => false
      term := first terms
      rewriteTypeVars!(x, var, term)
      debug ["Removing" :: PF, bold(var :: PF), "type variable." :: PF]
      remove!(var, x.typevars)
      info (["Type inferred for node" :: PF, n.path :: PF,
             ":" :: PF, bold(term :: PF)])
      rewriteNodes!(x, var, term)
      true

    removeAlias! (x : %, var : MR, alias : N) : Void ==
      var = (alias :: MR) => void() -- BUG? Handle degenerate case!
      debug ["Removing alias:" :: PF, var :: PF, "=>" :: PF, alias :: PF]
      rewriteTypeVars!(x, var, alias)
      for n in entries x.nodes | occurs?(var, n.type) repeat
        n.type := substitute(n.type, var, alias)
        debug (["Rewrote" :: PF, n.path :: PF, "with" :: PF,
                brace spaces [var :: PF, "=>" :: PF, alias :: PF]])
      debug ["Removing" :: PF, bold(var :: PF), "type variable." :: PF]
      remove!(var, x.typevars)

    limitTypeVar! (x : %, var : MR, terms : List(N)) : Boolean ==
      debug(["Modyfing" :: PF, bold(var :: PF), "type variable with" :: PF,
             bracket [bold(t :: PF) for t in terms]])
      typevars := x.typevars
      -- 1) typevars(%x) = [?]
      emptyType? typevars(var) =>
        -- a) %x = %y => alias removal
        -- b) %x = [t1, t2, t3, ...]
        if aliasType? terms
          then removeAlias!(x, var, first terms)
          else typevars(var) := terms
        true
      -- 2) typevars(%x) = [s1, s2, s3, ...], %x = [t1, t2, t3, ...]
      -- Unify proposed values with already stored in the variable
      -- store only matching ones (without performing substitutions).
      ms := findMatches(typevars(var), terms)
      not empty? ms.terms =>
        typevars(var) := ms.terms
        true
      -- Unification failed, as a last resort use subtyping.
      for term in terms repeat
        for t in typevars(var) repeat
          if not isSubType(t, term) then
            return false
      typevars(var) := terms
      true

    limitTypeVar! (x : %, substitutions : SUBST) : Boolean ==
      empty? substitutions => true
      "and"/[limitTypeVar!(x, s.key, s.entry) for s in entries substitutions]

    nodesTypeMatch! (x : %, ln : TN, rn : TN) : Boolean ==
      -- %a[?] ~ %b[?]
      hasUnknownType?(x, ln) and hasUnknownType?(x, rn) =>
        ures := unifyType(ln.type, rn.type)
        failed? ures => false
        limitTypeVar!(x, ures :: SUBST)
      -- %a[?] ~ (%b[t1, t2, ...] | T)
      hasUnknownType?(x, ln) and not hasUnknownType?(x, rn) =>
        limitTypeVar!(x, ln.type :: MR, [rn.type])
      -- (%a[t1, t2, ...] | T) ~ %b[?]
      not hasUnknownType?(x, ln) and hasUnknownType?(x, rn) =>
        limitTypeVar!(x, rn.type :: MR, [ln.type])
      -- (%a[t1, t2, ...] | T) ~ (%b[s1, s2, ...] | S)
      ms := findMatches(typeVar(x, ln.type), typeVar(x, rn.type))
      empty? ms.terms => false
      if not aliasType? ms.terms then
        if typeVar? ln.type then
          (x.typevars)(ln.type :: MR) := ms.terms
        if typeVar? rn.type then
          (x.typevars)(rn.type :: MR) := ms.terms
      limitTypeVar!(x, ms.subst)

    limitNodeType! (x : %, n : TN, types : List(N)) : Boolean ==
      -- %a[?] ~ [s1, s2, ...]
      hasUnknownType?(x, n) =>
        limitTypeVar!(x, n.type :: MR, types)
      -- (%a[t1, t2, ...] | T) ~ [s1, s2, ...]
      ms := findMatches(typeVar(x, n.type), types)
      empty? ms.terms => false
      if not aliasType? ms.terms then
        if typeVar? n.type then
          (x.typevars)(n.type :: MR) := ms.terms
      limitTypeVar!(x, ms.subst)

    -- With limited knowledge this routine tries to constraint types in given
    -- nodes to pairs which are (possibly) in subtyping relation.
    nodeSubType! (x : %, sn : TN, tn : TN) : Boolean ==
      -- In both cases we can assume nothing...
      -- a) {%s[s1, s2, ...] | S} <: {%t[?]}
      -- b) {%s[?]} <: {%t[t1, t2, ...] | T}
      hasUnknownType?(x, sn) or hasUnknownType?(x, tn) => true
      -- We're left with: {%s[s1, s2, ...] | S} <: {%t[t1, t2, ...] | T}
      sl : List(N) := []
      tl : List(N) := []
      -- In %s and %t there are usually some type variables. We could
      -- start normalizing terms to find out what's their exact structure, but
      -- I consider it to be dangerous. Deal with them later...
      sl := concat([s for s in typeVar(x, sn.type) | unbound? s], sl)
      tl := concat([t for t in typeVar(x, tn.type) | unbound? t], tl)
      -- With terms of known structure we can deal quite well.
      for s in typeVar(x, sn.type) | not unbound? s repeat
        for t in typeVar(x, tn.type) | not unbound? t repeat
          if isSubType(s, t) then
            sl := [s, :sl]
            tl := [t, :tl]
      empty? sl or empty? tl => false
      if typeVar? sn.type then
        (x.typevars)(sn.type :: MR) := removeDuplicates sl
      if typeVar? tn.type then
        (x.typevars)(tn.type :: MR) := removeDuplicates tl
      true

    nodeSubTypeOfList! (x : %, sn : TN, types : List(N)) : Boolean ==
      -- {%s[?]} <: [t1, t2, ...]
      hasUnknownType?(x, sn) => false
      -- {%s[s1, s2, ...] | S} <: [t1, t2, ...]
      sl : List(N) := []
      for s in typeVar(x, sn.type) repeat
        for t in types repeat
          if isSubType(s, t) then
            sl := [s, :sl]
      empty? sl => false
      if typeVar? sn.type then
        (x.typevars)(sn.type :: MR) := removeDuplicates sl
      true

    countProgress (x : %) : Record(a : Integer, b : Integer) ==
      -- a = number of type variables and nodes to be processed
      --     (empty type variable counts twice)
      -- b = sum of types assigned to each type variable
      p := [#(x.typevars), 0]
      for n in entries x.nodes | not done? n repeat
)if 0
        types : List(N) :=
          not typeVar? n.type => []
          (x.typevars)(n.type :: MR)
)endif
        types := typeVar(x, n.type)
        p.a := p.a + 1
        if emptyType? types
          then p.a := p.a + 1
          else p.b := p.b + #types
      p

    coerce (x : %) : PF ==
      pns := pile concat("Nodes :" :: PF, [n :: PF for n in entries x.nodes])
      ptvs :=
        empty? x.typevars =>
          "No type variables!" :: PF
        pss : List(PF) := []
        for e in entries x.typevars repeat
          (var, types) := (e.key, e.entry)
          pt :=
            #types = 1 => (first types) :: PF
            bracket [t :: PF for t in types]
          ps := spaces [right(4, var :: PF), ":" :: PF, pt]
          pss := [ps, :pss]
        pile concat("Type variables :" :: PF, pss)
      vconcat [pns, ptvs]

)abbrev package STFITS SpadTreeFillInTypes
SpadTreeFillInTypes(findTypeNode : MP -> TN) : SpadTreeWalkerCategory == Implementation where
  STNACAT ==> SpadTypeNodeArrayCategory
  PF ==> PrintableForm
  N ==> SpadNode
  APP ==> SpadApply(N)
  TE ==> SpadTypeExpr(N)
  TN ==> SpadTypeNode
  MP ==> SpadMarkerPath
  MR ==> SpadMarker(N)

  Implementation ==> add
    import Logger('Fill)

    rewrite (te : TE) : N ==
      te := [te.kind, rewrite te.expr, rewrite te.type]$TE
      not te.kind = '_$ => [te]
      symbol? te.type and (te.type :: Symbol) = ("$" :: Symbol) => te.expr
      typeAny? te.type => te.expr
      mappingType? te.type => te.expr
      [te]

    rewrite (app : APP) : N ==
      -- WORKAROUND! Remove origin qualifier from first argument of implicit
      -- call to 'elt' added in walkApp $ SpadTypeChecker.
      if typeExpr? app.function then
        fun := app.function :: TE
        if fun.expr = ['elt] and #app.args > 0 then
          arg := app.args.1
          typeExpr? arg and (arg :: TE).kind = '_$ =>
            arg := (arg :: TE).expr
            return nodeApp(rewrite app.function, 
                           cons(rewrite arg, [rewrite a for a in rest app.args]))
      nodeApp(rewrite app.function, [rewrite a for a in app.args])

    rewrite (mr : MR) : N ==
      mr.kind = 'typevar =>
        t := findTypeNode(mr.path).type
        typeOrigin? t =>
          te := coerce(t)@TE
          typeOrigin? te.type =>
            te' := coerce(te.type)@TE
            te'.type
          te.type
        t
      mr.kind = 'noderef =>
        n := findTypeNode(mr.path).node
        n = [mr] =>
          fail pile ["Self reference detected:" :: PF, findTypeNode(mr.path) :: PF]
          error ""
        rewrite n
      error ""

)abbrev package STTCHECK SpadTypeTreeChecker
SpadTypeTreeChecker() : Exports == Implementation where
  NNI ==> NonNegativeInteger
  MP ==> SpadMarkerPath
  N ==> SpadNode
  APP ==> SpadApply(N)
  ASS ==> SpadAssign(N)
  CE ==> SpadCondExpr(N)
  ENV ==> SpadEnvironment
  FN ==> SpadFunction(N)
  MT ==> SpadMappingType(N)
  MR ==> SpadMarker(N)
  TE ==> SpadTypeExpr(N)
  SEQ ==> SpadSequence(N)
  UT ==> SpadUnionType(N)
  SUBST ==> AssociationList(MR, List(N))
  URES ==> Union(SUBST, "failed")
  TN ==> SpadTypeNode
  TNA ==> SpadTypeNodeArray
  TR ==> SpadTypeRule
  PF ==> PrintableForm

  Exports ==> with
    walk : TNA -> Boolean

  Implementation ==> add
    import Logger('Check)
    import TypeUnifier
    import SpadNodeFactory
    import SpadTypeNode
    import SpadTypeNodeArray

    evalApply(r : APP, n : TN, x : TNA) : Boolean ==
      nfun := node(x, r.function) -- function node
      nargs := [node(x, arg) for arg in r.args] -- argument nodes

      sigs : List(N) := []
      substList : List(SUBST) := []
      for t in typeVar(x, nfun.type) repeat
        -- 1) Consider signature types with correct number of arguments.
        t' := stripOriginIfCan t
        not mappingType? t' => "iterate"
        sig := t' :: MT
        #sig.args ~= #nargs => "iterate"
        debug ["Checking signature:" :: PF, bold(t :: PF)]
        -- 2) Check if arguments can be applied to function of given
        --    signature.
        argsOk? := true
        for arg in sig.args for narg in nargs | argsOk? repeat
          argTypes := typeVar(x, narg.type)
          ures := unifyType(arg, argTypes)
          ures case SUBST =>
            substList := [ures :: SUBST, :substList]
          "or"/[isSubType(argType, arg) for argType in argTypes] => "iterate"
          argsOk? := false
        not argsOk? => "iterate"
        -- 3) Check if result type is correct for given signature.
        ures := unifyType(sig.result, typeVar(x, n.type))
        ures case "failed" => "iterate"
        -- 4) Collect variable substitutions and valid signature.
        substList := [ures :: SUBST, :substList]
        sigs := [t, :sigs]
      subst := mergeSubstitutions(substList)

      empty? sigs => false

      if typeVar? nfun.type then
        limitTypeVar!(x, nfun.type :: MR, sigs)

      for s in entries subst repeat
        limitTypeVar!(x, s.key, s.entry)

      -- Fetch all inferred mappings.
      mappings : List(MT) := []
      for t in sigs repeat
        t := stripOriginIfCan t
        not mappingType? t => "iterate"
        mappings := [t :: MT, :mappings]
      -- Propagate function arguments and return type down the tree.
      for i in 1..#nargs for narg in nargs repeat
        limitNodeType!(x, narg, [(mt.args)(i) for mt in mappings])
      limitNodeType!(x, n, [mt.result for mt in mappings]) 
      true

    evalAssign(r : ASS, n : TN, x : TNA) : Boolean ==
      ln := node(x, r.lval) -- left node
      rn := node(x, r.rval) -- right node
      -- a) {%s[?]} := {%t[t1, t2, ...] | T}
      -- given a type information flows from nodes above during TNA
      -- construction and we don't know anything, let's accept types
      -- from below
      hasUnknownType?(x, ln) => limitNodeType!(x, ln, [rn.type])
      -- b) {%s[s1, s2, ...] | S} := {%t[?]}
      -- we simply don't know, wait for types to flow from below
      hasUnknownType?(x, rn) => true
      -- c) {%s[s1, s2, ...] | S} := {%t[t1, t2, ...] | T}
      -- now it's easy...
      not nodeSubType!(x, rn, ln) and not nodesTypeMatch!(x, ln, rn) => false
      limitNodeType!(x, n, [ln.type])

    evalCondExpr(r : CE, n : TN, x : TNA) : Boolean ==
      cn := node(x, r.cond) -- condition node
      tn := node(x, r.truebr) -- true branch node
      fn := node(x, r.falsebr) -- false branch node
      not limitNodeType!(x, cn, [booleanType]) => false
      nodeSubType!(x, tn, n) and nodeSubType!(x, fn, n) => true
      nodesTypeMatch!(x, n, tn) and nodesTypeMatch!(x, n, fn) => true
      typeUndef? tn.type and limitNodeType!(x, fn, [typeAny]) =>
        killNode!(x, n)
        true
      typeUndef? fn.type and limitNodeType!(x, tn, [typeAny]) =>
        killNode!(x, n)
        true
      false

    evalSubType(r : TE, n : TN, x : TNA) : Boolean ==
      n1 := node(x, r.expr)
      n2 := node(x, r.type)
      nodeSubType!(x, n1, n2)

    evalTypeOrigin(r : TE, n : TN, x : TNA) : Boolean ==
      fun := node(x, r.expr)
      limitNodeType!(x, n, [fun.type])

    evalCapsule(r : SEQ, n : TN, x : TNA) : Boolean ==
      items := r.list
      types : List(N) := []
      for item in items repeat
        tn := node(x, item)
        not done? tn => return true
        if function? tn.node then
          types := [nodeNamedType((tn.node :: FN).name, tn.type), :types]
      limitNodeType!(x, n, [nodeSeq("Capsule", types)])

    -- evaluates single rule; note that it can happen that nothing was changed
    -- even if no type error was detected (result "true" means yes or maybe)
    evalFormula(f : N, n : TN, x : TNA) : Boolean ==
      emptyNode? f => true
      nodeRef? f => true

      debug (["Running type inference for" :: PF, n.path :: PF,
              "of" :: PF, n.type :: PF, "type." :: PF])

      apply? f => evalApply(f :: APP, n, x)
      assign? f => evalAssign(f :: ASS, n, x)
      condExpr? f => evalCondExpr(f :: CE, n, x)
      subType? f => evalSubType(f :: TE, n, x)
      typeOrigin? f => evalTypeOrigin(f :: TE, n, x)
      capsule? f => evalCapsule(f :: SEQ, n, x)

      fail ["evalFormula: case not handled for" :: PF, f :: PF]
      error "Internal error!"

    evalAnyRule(n : TN, x : TNA) : Boolean ==
      rules := n.rules
      empty? rules => true
      while not empty? rules repeat
        fs := (first rules).formulas
        "and"/[evalFormula(f, n, x) for f in fs] => break
        rules := rest rules
      empty? rules => false
      -- Immediately remove rules that fail to apply.
      for victim in setDifference(references n.rules, references rules) repeat
        killNode!(x, victim)
      n.rules := rules
      true

    checkAndMarkIfDone! (x : TNA, n : TN) : Boolean ==
      unbound? n.type => false
      if not empty? n.rules then
        -- We only care about first rule, because it produced actual solution.
        rule := first n.rules
        for ref in references rule repeat
          cn := node(x, ref)
          import? cn.node or typeDecl? cn.node => "iterate"
          if unbound? cn.type then
            return false
        -- Remove leftovers from other alternative rules.
        for victim in setDifference(references n.rules, references rule) repeat
          killNode!(x, victim)
        n.node := rule.solution
      done! n; true

    walkPostOrder(n : TN, x : TNA) : List(TN) ==
      lst := [walkPostOrder(node(x, i), x) for i in references(n)]
      "concat"/concat(lst, [n])

    walk x ==
      q : Queue(TN) := empty()

      for n in walkPostOrder(node(x, 1), x) repeat 
        rewriteIfInferred!(x, n)
        enqueue!(n, q)

      info vconcat ["Tree ready for type checking..." :: PF, x :: PF]
      info ["Processing order:" :: PF, bracket [n.path :: PF for n in members q]]

      p := countProgress x
      s := 1 :: NNI

      while p.a > 0 or p.b > 0 repeat
        newQ : Queue(TN) := empty()

        -- perform meta-step
        while not empty? q repeat
          n := dequeue! q
          done? n => "iterate"

          --debug([number(s) :: PF, "Queue state" :: PF, "=>" :: PF,
          --       n.path :: PF, ":" :: PF,
          --       bracket [m.path :: PF for m in members q]])

          not evalAnyRule(n, x) =>
            fail pile([spaces ["Type error for node:" :: PF, n.path :: PF],
                       red(n.node :: PF)])
            debug (x :: PF)
            return false

          -- Check if we're done with processing type variable tied to this node.
          rewriteIfInferred!(x, n)

          -- If type is inferred for all formulas the node itself won't change
          checkAndMarkIfDone!(x, n) =>
            debug ["Processing node" :: PF, n.path :: PF, "completed!" :: PF]

          enqueue!(n, newQ)

        -- check if during meta-step the problem was reduced compared to
        -- previous meta-step
        newP := countProgress x
        correct :=
          newP.a < p.a => true
          newP.a = p.a and newP.b < p.b => true
          false
        not correct =>
          fail ("Type checker does not advance by applying known typing rules!" :: PF)
          debug (x :: PF)
          return false

        -- setup new meta-step
        p := newP
        q := newQ
        s := s + 1

      info (x :: PF)

      -- Rewrite the tree if succeeded !

      -- capture x in closure, so that we don't need to expose TCNA type to
      -- SpadTreeFillInTypes
      findTypeNode := ((path : MP) : TN +-> node(x, path))

      root := node(x, 1)
      root.node := rewrite(root.node)$SpadTreeFillInTypes(findTypeNode)

      true
