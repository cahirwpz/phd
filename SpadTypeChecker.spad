)abbrev package STCLEAN SpadTreeCleanUp
SpadTreeCleanUp() : SpadTreeWalkerCategory == Implementation where
  N ==> SpadNode
  APP ==> SpadApply(N)

  Implementation ==> add
    rewrite (a : APP) : N ==
      -- replace "exit(1, node)" with "node"
      fn := a.function
      symbol? fn and (fn :: Symbol) = 'exit and (a.args.1 :: Integer) = 1 =>
        rewrite a.args.2
      [[rewrite a.function, [rewrite arg for arg in a.args]] $ APP]

)abbrev package STMEXP SpadTreeMacroExpander
SpadTreeMacroExpander() : Exports == Implementation where
  N ==> SpadNode
  M ==> SpadMacro(N)
  AL ==> AssociationList(Symbol, M)
  SEQ ==> SpadSequence(N)

  Exports ==> SpadTreeWalkerCategory with 
    init : () -> Void

  Implementation ==> add
    env : Stack AL := stack [table()]
    lastCtx : AL := table()

    newCtx : () -> Void
    newCtx () == push!(table(), env)

    addCtx : AL -> Void
    addCtx ctx == push!(ctx, env)

    discardCtx : () -> AL
    discardCtx () == pop! env

    addMacro : M -> Void
    addMacro m ==
      ctx := top env
      ctx(m.name) := m

    findMacro : Symbol -> Union(M, "failed")
    findMacro name ==
      for ctx in parts env repeat
        if key?(name, ctx) then
          return ctx(name)
      "failed"

    init () ==
      env := stack [table()]
      lastCtx := table()

    rewrite (seq : SEQ) : N ==
      seq.kind ~= "prog" =>
        [[seq.kind, [rewrite ex for ex in seq.list]] $ SEQ]

      newCtx()
      nodes := [rewrite ex for ex in seq.list]
      lastCtx := discardCtx()

      -- eliminate leftovers after consumed macros
      nodes := [node for node in nodes | not emptyNode? node]
      empty? nodes => emptyNode()
      [[seq.kind, nodes] $ SEQ]

    rewrite (app : SpadApply(N)) : N ==
      if symbol? app.function then
        m := findMacro (app.function :: Symbol)
        m case M and #m.args > 0 =>
          #app.args ~= #m.args =>
            error concat(["Wrong number of arguments (", string(#app.args), ") ",
                          "passed to macro ", string(m.name), " (", string(#m.args), ")"])
          newCtx ()
          for m_arg in m.args for arg in app.args repeat
            -- skip argument rewriting if it doesn't require renaming
            if not(symbol? arg and (arg :: Symbol) = m_arg) then
              addMacro ([m_arg, [], arg] $ SpadMacro(N))
          app' := rewrite m.body
          discardCtx()
          return app'
      [[rewrite app.function, [rewrite arg for arg in app.args]] $ SpadApply(N)]

    rewrite (m : SpadMacro(N)) : N ==
      addMacro m
      emptyNode()

    rewrite (w : SpadWhere(N)) : N ==
      wenv := rewrite w.env
      -- because w.env is always (?) a sequence it produces a valid lastCtx environment
      addCtx(lastCtx)
      wbody := rewrite w.body
      discardCtx ()
      -- reduce where statement if environment contained only macros
      emptyNode? wenv => wbody
      
      [[wbody, wenv] $ SpadWhere(N)]

    rewrite (sym : Symbol) : N ==
      m := findMacro sym
      m case "failed" => [sym]
      #m.args ~= 0 =>
        error concat ["Attempted to apply arguments to parameterless macro '", string m.name, "'"]
      rewrite m.body

)abbrev domain STRP1 SpadTreeRewritePhase1
SpadTreeRewritePhase1() : SpadTreeWalkerCategory == Implementation where
  N ==> SpadNode
  APP ==> SpadApply(N)
  ASS ==> SpadAssign(N)
  SEQ ==> SpadSequence(N)

  Implementation ==> add
    rewrite (app : APP) : N ==
      nexps : List(N) := []
      nargs : List(N) := []
      for arg in app.args repeat
        narg := arg
        if not value? arg then
          narg := [gensym()]
          nexps := [rewrite [[narg, arg] $ ASS], :nexps]
        nargs := [rewrite narg, :nargs]
      reverse! nexps
      reverse! nargs
      app' := [[rewrite app.function, nargs] $ APP]
      empty? nexps => app'
      [["prog", [:nexps, app']] $ SEQ]

    rewrite (seq : SEQ) : N == 
      nodes : List(N) := [rewrite e for e in seq.list]
      if seq.kind = "prog" then
        nodes' : List(N) := []
        for node in nodes repeat
          if sequence? node then
            nseq := node :: SEQ
            nseq.kind = "prog" =>
              nodes' := concat(reverse nseq.list, nodes')
          nodes' := [node, :nodes']
        nodes := reverse nodes'
      [[seq.kind, nodes] $ SEQ]

)abbrev package SFWTEST SpadFrameworkTest
++ Author: Krystian Baclawski
++ Date Created: December 2013
++ Date Last Updated: January 2014
++ Description:
++ Experimental type checker with bottom-up approach.
SpadFrameworkTest() : with
    run : SExpression -> Void 
  == add
    import OutputForm
    import SpadNode
    import SpadTreeMacroExpander

    run e ==
      --print (e :: OutputForm)

      -- BUG: type annotation below is necessary otherwise compiler chooses
      -- "parse" function that fails to parse functor
      n : SpadNode := parse e

      n := rewrite(n) $ SpadTreeCleanUp
      print (n :: OutputForm)
      
      init() -- initalize macro expander
      n := rewrite(n) $ SpadTreeMacroExpander
      print (n :: OutputForm)
